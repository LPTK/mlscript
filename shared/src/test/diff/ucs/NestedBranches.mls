:NewParser
:NewDefs


class Some[A](val value: A)
module None
class Left[A](val leftValue: A)
class Right[A](val rightValue: A)
module Nil
class Cons[A](val head: A, val tail: Cons[A] | Nil)
class Pair[A, B](val fst: A, val snd: B)
//│ class Some[A](value: A)
//│ module None
//│ class Left[A](leftValue: A)
//│ class Right[A](rightValue: A)
//│ module Nil
//│ class Cons[A](head: A, tail: Cons[A] | Nil)
//│ class Pair[A, B](fst: A, snd: B)


fun optionApply(x, y, f) =
  if x is
    Some(xv) and y is
      Some(yv) then Some(f(xv, yv))
      None then None
    None then None
//│ fun optionApply: forall 'A 'A0 'a. (None | Some['A], None | Some['A0], (??A & 'A, ??A0 & 'A0) -> 'a) -> (None | Some['a])

let zeroToThree = Cons(0, Cons(1, Cons(2, Cons(3, Nil))))
//│ let zeroToThree: Cons['A]
//│   where
//│     'A :> 0 | 1 | 2 | 3
//│ zeroToThree
//│             = Cons {}

fun f(x) = if x % 2 == 0 then Left(x) else Right(x)
//│ fun f: forall 'A. (Int & 'A) -> (Left['A] | Right['A])

fun mapPartition(f, xs) = if xs is
  Nil then Pair(Nil, Nil)
  Cons(x, xs) and mapPartition(f, xs) is Pair(l, r) and f(x) is
    Left(v)  then Pair(Cons(v, l), r)
    Right(v) then Pair(l, Cons(v, r))
//│ fun mapPartition: forall 'A 'A0 'A1 'A2 'B 'A3 'A4 'A5 'A6 'A7 'A8. ((??A & 'A2) -> (Left['A & ('A0 | ~??A0)] | Right['A6 & ('A5 | ~??A1)]), Cons[in 'A2 out nothing] | Nil) -> (Pair[Cons[in 'A0 out 'A4] | Nil | 'A3, Cons[in 'A5 out 'A7] | Nil | 'B] & {
//│   Pair#B <: Cons[in 'A5 out 'A7] | Nil | 'B,
//│   Pair#A <: Cons[in 'A0 out 'A4] | Nil | 'A3
//│ })
//│ where
//│   'B :> ??B & (Cons[in 'A5 out 'A7] | Nil)
//│   'A3 :> ??A2 & (Cons[in 'A0 out 'A4] | Nil)
//│   'A5 <: 'A1
//│   'A1 :> 'A7 | ??A1 & 'A6
//│       <: 'A5
//│   'A7 :> 'A1 | ??A1 & 'A6
//│   'A0 <: 'A8
//│   'A8 :> 'A4 | ??A0 & 'A
//│       <: 'A0
//│   'A4 :> 'A8 | ??A0 & 'A

mapPartition(x => Left(x + 1), zeroToThree)
//│ forall 'A 'B. Pair[Cons[in 'A0 out 'A1] | Nil | 'A, Cons['A2] | Nil | 'B] & {Pair#B <: Cons['A2] | Nil | 'B, Pair#A <: Cons[in 'A0 out 'A1] | Nil | 'A}
//│   where
//│     'B :> ??B & (Cons['A2] | Nil)
//│     'A :> ??A & (Cons[in 'A0 out 'A1] | Nil)
//│     'A0 :> Int & ??A0 | 'A1
//│     'A1 :> Int & ??A0 | 'A0
//│ res
//│     = Pair {}

mapPartition(f, zeroToThree)
//│ forall 'A 'B. Pair[Cons[in 'A0 out 'A1] | Nil | 'A, Cons[in 'A2 out ??A & ??A0 & (0 | 1 | 2 | 3) | 'A2] | Nil | 'B] & {
//│   Pair#B <: Cons[in 'A2 out ??A & ??A0 & (0 | 1 | 2 | 3) | 'A2] | Nil | 'B,
//│   Pair#A <: Cons[in 'A0 out 'A1] | Nil | 'A
//│ }
//│ where
//│   'B :> ??B & (Cons[in 'A2 out ??A & ??A0 & (0 | 1 | 2 | 3) | 'A2] | Nil)
//│   'A :> ??A1 & (Cons[in 'A0 out 'A1] | Nil)
//│   'A0 :> 'A1 | ??A0 & ??A2 & (0 | 1 | 2 | 3)
//│   'A1 :> 'A0 | ??A0 & ??A2 & (0 | 1 | 2 | 3)
//│ res
//│     = Pair {}


fun mapPartition(f, xs) = if xs is
  Nil then Pair(Nil, Nil)
  Cons(x, xs) and
    mapPartition(f, xs) is Pair(l, r) and f(x) is
      Left(v)  then Pair(Cons(v, l), r)
      Right(v) then Pair(l, Cons(v, r))
//│ fun mapPartition: forall 'A 'A0 'A1 'A2 'A3 'A4 'A5 'B 'A6 'A7 'A8. ((??A & 'A1) -> (Left['A3 & ('A5 | ~??A0)] | Right['A & ('A8 | ~??A1)]), Cons[in 'A1 out nothing] | Nil) -> (Pair[Cons[in 'A5 out 'A7] | Nil | 'A0, Cons[in 'A8 out 'A2] | Nil | 'B] & {
//│   Pair#B <: Cons[in 'A8 out 'A2] | Nil | 'B,
//│   Pair#A <: Cons[in 'A5 out 'A7] | Nil | 'A0
//│ })
//│ where
//│   'B :> ??B & (Cons[in 'A8 out 'A2] | Nil)
//│   'A0 :> ??A2 & (Cons[in 'A5 out 'A7] | Nil)
//│   'A8 <: 'A4
//│   'A4 :> 'A2 | ??A1 & 'A
//│       <: 'A8
//│   'A2 :> 'A4 | ??A1 & 'A
//│   'A5 <: 'A6
//│   'A6 :> 'A7 | ??A0 & 'A3
//│       <: 'A5
//│   'A7 :> 'A6 | ??A0 & 'A3

mapPartition(f, zeroToThree)
//│ forall 'B 'A. Pair[Cons[in 'A0 out 'A1] | Nil | 'A, Cons[in 'A2 out ??A & ??A0 & (0 | 1 | 2 | 3) | 'A2] | Nil | 'B] & {
//│   Pair#B <: Cons[in 'A2 out ??A & ??A0 & (0 | 1 | 2 | 3) | 'A2] | Nil | 'B,
//│   Pair#A <: Cons[in 'A0 out 'A1] | Nil | 'A
//│ }
//│ where
//│   'B :> ??B & (Cons[in 'A2 out ??A & ??A0 & (0 | 1 | 2 | 3) | 'A2] | Nil)
//│   'A :> ??A1 & (Cons[in 'A0 out 'A1] | Nil)
//│   'A0 :> 'A1 | ??A & ??A2 & (0 | 1 | 2 | 3)
//│   'A1 :> 'A0 | ??A & ??A2 & (0 | 1 | 2 | 3)
//│ res
//│     = Pair {}


fun mapPartition(f, xs) = if xs is
  Nil then
    Pair(Nil, Nil)
  Cons(x, xs) and
    mapPartition(f, xs) is
      Pair(l, r) and
        f(x) is
          Left(v)  then
            Pair(Cons(v, l), r)
          Right(v) then
            Pair(l, Cons(v, r))
//│ fun mapPartition: forall 'A 'A0 'A1 'A2 'A3 'B 'A4 'A5 'A6 'A7 'A8. ((??A & 'A3) -> (Left['A0 & ('A8 | ~??A0)] | Right['A2 & ('A5 | ~??A1)]), Cons[in 'A3 out nothing] | Nil) -> (Pair[Cons[in 'A8 out 'A] | Nil | 'A4, Cons[in 'A5 out 'A1] | Nil | 'B] & {
//│   Pair#B <: Cons[in 'A5 out 'A1] | Nil | 'B,
//│   Pair#A <: Cons[in 'A8 out 'A] | Nil | 'A4
//│ })
//│ where
//│   'B :> ??B & (Cons[in 'A5 out 'A1] | Nil)
//│   'A4 :> ??A2 & (Cons[in 'A8 out 'A] | Nil)
//│   'A5 <: 'A7
//│   'A7 :> 'A1 | ??A1 & 'A2
//│       <: 'A5
//│   'A1 :> 'A7 | ??A1 & 'A2
//│   'A8 <: 'A6
//│   'A6 :> 'A | ??A0 & 'A0
//│       <: 'A8
//│   'A :> 'A6 | ??A0 & 'A0

mapPartition(f, zeroToThree)
//│ forall 'A 'B. Pair[Cons[in 'A0 out 'A1] | Nil | 'A, Cons[in 'A2 out ??A & ??A0 & (0 | 1 | 2 | 3) | 'A2] | Nil | 'B] & {
//│   Pair#B <: Cons[in 'A2 out ??A & ??A0 & (0 | 1 | 2 | 3) | 'A2] | Nil | 'B,
//│   Pair#A <: Cons[in 'A0 out 'A1] | Nil | 'A
//│ }
//│ where
//│   'B :> ??B & (Cons[in 'A2 out ??A & ??A0 & (0 | 1 | 2 | 3) | 'A2] | Nil)
//│   'A :> ??A1 & (Cons[in 'A0 out 'A1] | Nil)
//│   'A0 :> 'A1 | ??A2 & ??A0 & (0 | 1 | 2 | 3)
//│   'A1 :> 'A0 | ??A2 & ??A0 & (0 | 1 | 2 | 3)
//│ res
//│     = Pair {}

:e // TODO make this one work (needs tuple support)
fun mapPartition(f, xs) = if xs is
  Nil then [Nil, Nil]
  Cons(x, xs) and mapPartition(f, xs) is [l, r] and f(x) is
    Left(v)  then [Cons(v, l), r]
    Right(v) then [l, Cons(v, r)]
//│ ╔══[ERROR] type identifier not found: Tuple#2
//│ ╙──
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.161: 	fun mapPartition(f, xs) = if xs is
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.162: 	  Nil then [Nil, Nil]
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.163: 	  Cons(x, xs) and mapPartition(f, xs) is [l, r] and f(x) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.164: 	    Left(v)  then [Cons(v, l), r]
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.165: 	    Right(v) then [l, Cons(v, r)]
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── tuple literal of type `[Nil, Nil]` is not an instance of type `Object`
//│ ║  l.162: 	  Nil then [Nil, Nil]
//│ ║         	           ^^^^^^^^^^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.163: 	  Cons(x, xs) and mapPartition(f, xs) is [l, r] and f(x) is
//│ ║         	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.164: 	    Left(v)  then [Cons(v, l), r]
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.165: 	    Right(v) then [l, Cons(v, r)]
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from application:
//│ ║  l.163: 	  Cons(x, xs) and mapPartition(f, xs) is [l, r] and f(x) is
//│ ╙──       	                  ^^^^^^^^^^^^^^^^^^^
//│ fun mapPartition: (anything, Cons[in anything out nothing] | Nil) -> (error | [Nil, Nil])
//│ Code generation encountered an error:
//│   unknown match case: Tuple#2

:re // TODO
mapPartition(f, zeroToThree)
//│ error | [Nil, Nil]
//│ res
//│ Runtime error:
//│   ReferenceError: mapPartition3 is not defined


// * Vertical alignment is not allowed! (good)
:pe
:w
:e
:ge
fun mapPartition(f, xs) = if xs is
  Nil then [Nil, Nil]
  Cons(x, xs) and mapPartition(f, xs) is [l, r]
          and f(x) is Left(v)  then [Cons(v, l), r]
                      Right(v) then [l, Cons(v, r)]
//│ ╔══[PARSE ERROR] Unexpected 'then' keyword here
//│ ║  l.213: 	                      Right(v) then [l, Cons(v, r)]
//│ ╙──       	                               ^^^^
//│ ╔══[WARNING] Paren-less applications should use the 'of' keyword
//│ ║  l.212: 	          and f(x) is Left(v)  then [Cons(v, l), r]
//│ ║         	                                    ^^^^^^^^^^^^^^^
//│ ║  l.213: 	                      Right(v) then [l, Cons(v, r)]
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] type identifier not found: Tuple#2
//│ ╙──
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.209: 	fun mapPartition(f, xs) = if xs is
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.210: 	  Nil then [Nil, Nil]
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.211: 	  Cons(x, xs) and mapPartition(f, xs) is [l, r]
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.212: 	          and f(x) is Left(v)  then [Cons(v, l), r]
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.213: 	                      Right(v) then [l, Cons(v, r)]
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── tuple literal of type `[Nil, Nil]` is not an instance of type `Object`
//│ ║  l.210: 	  Nil then [Nil, Nil]
//│ ║         	           ^^^^^^^^^^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.211: 	  Cons(x, xs) and mapPartition(f, xs) is [l, r]
//│ ║         	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.212: 	          and f(x) is Left(v)  then [Cons(v, l), r]
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.213: 	                      Right(v) then [l, Cons(v, r)]
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from application:
//│ ║  l.211: 	  Cons(x, xs) and mapPartition(f, xs) is [l, r]
//│ ╙──       	                  ^^^^^^^^^^^^^^^^^^^
//│ fun mapPartition: (anything, Cons[in anything out nothing] | Nil) -> (error | [Nil, Nil])
//│ Code generation encountered an error:
//│   unknown match case: Tuple#2

