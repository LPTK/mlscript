:NoJS

:GeneralizeCurriedFunctions
:NoRecursiveTypes


// ------------ Dummy classes to represent the types in the examples ------------

class List[a]
  method Get: a
//│ Defined class List[+a]
//│ Declared List.Get: List['a] -> 'a

class ST[S, A]
  method Inv_S: S -> S
  method Cov_A: A
//│ Defined class ST[=S, +A]
//│ Declared ST.Inv_S: ST['S, ?] -> 'S -> 'S
//│ Declared ST.Cov_A: ST['S, 'A] -> 'A


// ============ Type signatures for functions used in the examples ============

def choose x y = if true then x else y
//│ choose: 'a -> (forall 'b, 'c, 'd. ('b & 'c & 'd) -> ('a | 'd))

def id x = x
//│ id: 'a -> 'a

def auto (x: forall 'a. 'a -> 'a) = x x
//│ auto: (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a | 'b)

def app f x = f x
//│ app: 'a -> (forall 'a, 'b, 'c. ('b -> 'c
//│   where
//│     'a <: 'b -> 'c))

def inc: int -> int
//│ inc: int -> int

// Used to represent `::` in the papers
def cons: 'a -> List['a] -> List['a]
//│ cons: 'a -> List['a] -> List['a]

// Used to represent `[]` in the papers
def nil: List['a]
//│ nil: List[nothing]

def single: 'a -> List['a]
//│ single: 'a -> List['a]

def head: List['a] -> 'a
//│ head: List['a] -> 'a

def tail: List['a] -> List['a]
//│ tail: List['a] -> List['a]

def append: List['a] -> List['a] -> List['a]
//│ append: List['a] -> List['a] -> List['a]

def runST: (forall 's. ST['s, 'v]) -> 'v
//│ runST: (forall 's. ST['s, 'v]) -> 'v

def argST: ST['s, int]
//│ argST: ST['s, int]


// ============ Raising ML to the power of System F (2003) ============

// This used to be `'a -> (forall 'b. 'b -> 'b | 'a)`, now it's wrong!
// FreezeML A2
choose id
//│ res: ('a & 'b & 'c) -> (forall 'c, 'd. 'd -> 'd | 'c)

fun (g: forall 'a. ('a -> 'a) -> ('a -> 'a)) -> fun (x: forall 'a. 'a -> 'a) -> fun a -> g a (x a)
//│ res: (forall 'a. ('a -> 'a) -> 'a -> 'a) -> (forall 'a0. 'a0 -> 'a0) -> (forall 'a1, 'b, 'c, 'a2, 'd. ('a1 -> ('a1 & 'b) & 'c & 'a2 & 'd & 'a1 & 'b) -> 'b)

choose id succ
//│ res: 'a -> 'a | 'b

// FreezeML A7
choose id auto
//│ res: 'a -> 'a | 'b

// nope, along with anything with it as a subterm
// i.e. unannotated auto
omega = fun x -> x x
//│ omega: ('a -> 'b & 'a) -> 'b

fun (x: forall 'a. 'a) -> x x
//│ res: (forall 'a. 'a) -> nothing

// i.e. auto
omegad = fun (x: forall 'a. 'a -> 'a) -> x x
//│ omegad: (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a | 'b)

// FreezeML A5
id auto
//│ res: (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a | 'b)

// ~ auto id (FreezeML F5, PolyML 1.1)
(fun x -> x id) auto
//│ res: 'a -> 'a | 'b

app auto id
//│ res: 'a -> 'a | 'b

// ------------ Sec 5.2 ------------

// Error in the paper (confirmed by Rémy via email).
:e
let f = choose id in (f auto) (f succ)
//│ res: 'a -> 'a | 'b

// Reproduced with an unnanotated auto:

def auto2 x = x x
//│ auto2: ('a -> 'b & 'a) -> 'b

choose id auto2
//│ res: 'a -> 'a | 'b

:e // This is a legit error
res (choose id succ)
//│ res: 'a -> 'a | 'b

// Didier Le Botlan suggested this fix by email:

let f = choose id in (f auto, f succ)
//│ res: (forall 'a, 'b. 'a -> 'a | 'b, forall 'a, 'c. 'a -> 'a | 'c,)

let f = choose id in (f auto2, f succ)
//│ res: (forall 'a, 'b. 'a -> 'a | 'b, forall 'a, 'c. 'a -> 'a | 'c,)

// ------------ Sec 6 ------------

// (λ(y) y I ; y K) (λ(x) x x)
// "typable in Fω but not in F [9]"
// [9] P. Giannini and S. R. D. Rocca. Characterization of typings in polymorphic type discipline. In Third annual Symposium on Logic in Computer Science, pages 61–70. IEEE, 1988.

// I := λx.x
I x = x
//│ I: 'a -> 'a

// K := λx.λy.x
K x y = x
//│ K: 'a -> (forall 'b. 'b -> 'a)

(fun y -> let tmp = y I in y K) (fun x -> x x)
//│ res: 'a -> (forall 'b. 'b -> (forall 'c. 'c -> 'b))

// Note: reduces to
let tmp = (fun x -> x x) I in (fun x -> x x) K
//│ res: 'a -> (forall 'b. 'b -> (forall 'c. 'c -> 'b))

// to
let tmp = I I in K K
//│ res: 'a -> (forall 'b. 'b -> (forall 'c. 'c -> 'b))


// ============ Recasting MLF (2009) ============

// ------------ Sec 1.3 ------------

// ~ FreezeML B1
(fun f -> (f 42, f "foo")) (fun x -> x)
//│ res: (42, "foo",)

(fun f -> (f succ, choose f auto)) (choose id)
//│ res: (forall 'b, 'c. 'b -> 'b | 'c, (forall 'a, 'd, 'e, 'f. 'a -> 'a & 'd & 'e & 'f) -> (forall 'b, 'a, 'f, 'g. ('b & 'a) -> ('a | 'b) | 'f | 'g),)

// ------------ Sec 2.3.1 ------------

// i.e. id auto (FreezeML A5)
(fun z -> z) omegad
(fun z -> z) omega
//│ res: (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a | 'b)
//│ res: ('a -> 'b & 'a) -> 'b

// i.e. auto id (FreezeML F5)
(fun x -> x x) id
//│ res: 'a -> 'a

fun z -> (z omegad)
fun z -> (z omega)
//│ res: ((forall 'b. (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a | 'b)) -> 'c) -> 'c
//│ res: ((forall 'a, 'b. ('a -> 'b & 'a) -> 'b) -> 'c) -> 'c

(fun y -> fun z -> z y) omegad
(fun y -> fun z -> z y) omega
//│ res: ((forall 'b. (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a | 'b)) -> 'c & 'd) -> 'c
//│ res: ((forall 'a, 'b. ('a -> 'b & 'a) -> 'b) -> 'c & 'd) -> 'c

fun z -> omegad z
fun z -> omega z
//│ res: (forall 'a. 'a -> 'a) -> (forall 'a, 'b. 'a -> 'a | 'b)
//│ res: ('a -> 'b & 'a) -> 'b

(fun x -> fun y -> x y) omegad
(fun x -> fun y -> x y) omega
//│ res: 'b -> 'c
//│   where
//│     forall 'd. (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a | 'd) <: 'b -> 'c
//│ res: 'a -> 'b
//│   where
//│     forall 'c, 'd. ('c -> 'd & 'c) -> 'd <: 'a -> 'b

// ------------ Sec 4.3 ------------
// affects the order of bindings in the result type in MLF, not very interesting otherwise

fun (x: forall 'a. 'a -> 'b -> 'a) -> x
//│ res: (forall 'a. 'a -> 'b -> 'a) -> (forall 'a. 'a -> 'b -> 'a)

fun (x: forall 'b 'a. 'a -> 'b -> 'a) -> x
//│ res: (forall 'a, 'b. 'a -> 'b -> 'a) -> (forall 'a, 'b. 'a -> 'b -> 'a)

// ============ Leijen 2007 ============

// ------------ Sec 2 ------------

// FreezeML B1
// nope
poly = fun f -> (f 1, f true)
//│ poly: (true -> 'a & 1 -> 'b & 'c) -> ('b, 'a,)

// FreezeML B2
polyL = fun xs -> poly (head xs)
//│ polyL: (List[true -> 'b & 1 -> 'c & 'a & 'd & 'e] & 'f) -> (('c, 'b,) | 'g)

let ids = single id in (polyL ids, append ids (single inc))
//│ res: (forall 'a. (1, true,) | 'a, List[forall 'b. (int & 'b) -> (int | 'b)],)

// ------------ Sec 5 ------------

// FreezeML C5
ids = single id
//│ ids: List[forall 'a. 'a -> 'a]

// Let-bound version of FreezeML A3
let f = choose nil in f ids
//│ res: List['a] | 'a

// FreezeML A3
choose nil ids
//│ res: List['a] | 'a

def g: (int -> (forall 'a. 'a -> 'a)) -> int
//│ g: (int -> (forall 'a. 'a -> 'a)) -> int

g (fun x -> id)
//│ res: int

let f = fun x -> id in g f
//│ res: int

// FreezeML D4
app runST argST
//│ res: int


// ============ Variations ported from supertype tests ============

killer_app = (fun x -> x id) auto
//│ killer_app: 'a

I x = x
K x y = x
//│ I: 'a -> 'a
//│ K: 'a -> (forall 'b. 'b -> 'a)

// """ In particular, we conjecture that the term ...
monster = (fun y -> (let tmp = y I in y K)) (fun x -> x x)
// """ ... that is typable in Fω but not in F [9] is not typable in MLF either.
//│ monster: 'a -> (forall 'b. 'b -> (forall 'c. 'c -> 'b))

ignore x y = y
//│ ignore: 'a -> (forall 'b. 'b -> 'b)

monsterThunk() = (fun y -> (ignore (y I) (y K))) (fun x -> x x)
//│ monsterThunk: () -> (forall 'a. 'a | 'b)

monster2 = (fun y -> (y I, y K)) (fun x -> x x)
//│ monster2: ('a, forall 'b. 'b -> (forall 'c. 'c -> (forall 'd. 'd -> 'c)),)

monster = (fun y -> (let tmp = y I in y K)) (fun x -> x x)
//│ monster: 'a -> (forall 'b. 'b -> (forall 'c. 'c -> 'b))

monsterThunk() = (fun y -> ignore (y I) (y K)) (fun x -> x x)
//│ monsterThunk: () -> (forall 'a. 'a | 'b)

monster2 = (fun y -> (y I, y K)) (fun x -> x x)
//│ monster2: ('a, forall 'b. 'b -> (forall 'c. 'c -> (forall 'd. 'd -> 'c)),)

K K
//│ res: 'a -> (forall 'b. 'b -> (forall 'c. 'c -> 'b))


