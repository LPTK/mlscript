// * Alternative: separate `Cons` and `Nil` types with definition of `mem` and `fold_left`
// * :RecursiveTypes is now needed due to the structural typing of Cons and Nil

// :NoRecursiveTypes
:NoJS


// ============ Sec 4.2 ============

// ------------ Dummy classes to represent the types in the examples ------------

class Nil: {}
class Cons[a]: { head: a; tail: List[a] }
type List[a] = Nil | Cons[a]
//│ Defined class Nil
//│ Defined class Cons[+a]
//│ Defined type alias List[+a]

def Nil = Nil {}
//│ Nil: Nil

def Cons head tail = Cons { head; tail }
//│ Cons: ('head & 'a) -> (List['a] & 'tail) -> (Cons['a] with {head: 'head, tail: 'tail})

// ------------ Type signatures for functions used in the examples ------------

rec def mem x l = case l of
  { Nil -> false
  | Cons -> if eq l.head x then true else mem x l.tail
  }
//│ /!!!\ Uncaught error: java.lang.StackOverflowError

rec def fold_left f x l = case l of
  { Nil -> x
  | Cons -> fold_left f (f x l.head) l.tail
  }
//│ /!!!\ Uncaught error: java.lang.StackOverflowError

// ------------ polymorphic methods ------------

class Collection[a]: { l: List[a] }
  method Mem x = mem x this.l
  method Fold f x = fold_left f x this.l
//│ /!!!\ Uncaught error: java.lang.StackOverflowError

def coll_mem c x = c.Mem x
//│ ╔══[ERROR] Method Mem not found
//│ ║  l.46: 	def coll_mem c x = c.Mem x
//│ ╙──      	                   ^^^^^
//│ coll_mem: anything -> anything -> error

// * Typo in the paper? it was `fun x -> fun y -> ...`
def simple_and_double c =
  let l1 = c.Fold (fun y -> fun x -> Cons x y) Nil in
  let l2 = c.Fold (fun y -> fun x -> Cons ((x, x),) y) Nil in
  (l1, l2)
//│ ╔══[ERROR] Method Fold not found
//│ ║  l.54: 	  let l1 = c.Fold (fun y -> fun x -> Cons x y) Nil in
//│ ╙──      	           ^^^^^^
//│ ╔══[ERROR] Method Fold not found
//│ ║  l.55: 	  let l2 = c.Fold (fun y -> fun x -> Cons ((x, x),) y) Nil in
//│ ╙──      	           ^^^^^^
//│ simple_and_double: anything -> (error, error,)



// * Note: the kind of errors we get witout recursive types:

:NoRecursiveTypes

:e
rec def mem x l = case l of
  { Nil -> false
  | Cons -> if eq l.head x then true else mem x l.tail
  }
//│ /!!!\ Uncaught error: java.lang.StackOverflowError


