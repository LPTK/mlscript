:NoJS
:GeneralizeCurriedFunctions
:NoRecursiveTypes

// ============ Sec 4.2 ============
// alternative: separate `Cons` and `Nil` types with definition of `mem` and `fold_left`

// ------------ Dummy classes to represent the types in the examples ------------

class Nil: {}
class Cons[a]: { head: a; tail: List[a] }
type List[a] = Nil | Cons[a]
//│ Defined class Nil
//│ Defined class Cons[+a]
//│ Defined type alias List[+a]

def Nil = Nil {}
//│ Nil: Nil

def Cons head tail = Cons { head; tail }
//│ Cons: 'b -> (forall 'c, 'a, 'tail, 'head, 'd. (List['a] & 'c & 'tail) -> ((Cons['a | 'b] with {head: 'head | 'b, tail: 'tail}) | 'd))

// ------------ Type signatures for functions used in the examples ------------
// (I guess)

rec def mem x l = case l of
  { Nil -> false
  | Cons -> if eq l.head x then true else mem x l.tail
  }
//│ mem: anything -> 'a -> bool
//│   where
//│     'a <: (Cons[?] with {tail: 'a}) | Nil

rec def fold_left f x l = case l of
  { Nil -> x
  | Cons -> fold_left f (f x l.head) l.tail
  }
//│ fold_left: ('a -> 'head -> 'a) -> 'a -> 'b -> 'a
//│   where
//│     'b <: (Cons[?] with {head: 'head, tail: 'b}) | Nil

// ------------ polymorphic methods ------------

:RecursiveTypes // needed for these recursive defs uses

class Collection[a]: { l: List[a] }
  method Mem x = mem x this.l
  method Fold f x = fold_left f x this.l
//│ Defined class Collection[+a]
//│ Defined Collection.Mem: Collection['a] -> (forall 'a, 'b, 'c, 'd. ('b & 'c & 'a) -> (forall 'e. false | true | 'd | 'e))
//│ Defined Collection.Fold: Collection['a] -> (forall 'b. 'b -> (forall 'head, 'c, 'd, 'e, 'b, 'f, 'a, 'g. (('c & 'e) -> (forall 'h. 'h | 'd | 'c)
//│   where
//│     'b <: 'c -> (('a | 'head) -> ('c & 'g) & 'f))))

def coll_mem c x = c.Mem x
//│ coll_mem: 'b -> (forall 'c, 'b, 'd, 'a, 'e, 'f, 'g. (('e & 'g & 'c & 'd) -> (forall 'h, 'i. false | true | 'h | 'f | 'i)
//│   where
//│     'b <: Collection['a]))

// typo in the paper? it was `fun x -> fun y -> ...`
def simple_and_double c =
  let l1 = c.Fold (fun y -> fun x -> Cons x y) Nil in
  let l2 = c.Fold (fun y -> fun x -> Cons ((x, x),) y) Nil in
  (l1, l2)
//│ simple_and_double: (Collection['a & 'b & 'c & 'a0 | 'a1 & 'd] & 'e) -> (forall 'a2, 'f, 'g, 'h, 'i, 'j. 'h | 'i | 'g | 'f, forall 'k, 'l, 'm, 'n, 'o, 'p, 'a3. 'o | 'k | 'l | 'n,)
//│   where
//│     'k :> forall 'q, 'head. Nil | 'q
//│     'q :> Cons[('m | 'd, 'm | 'd,) | 'a3 | 'p] with {head: ('m | 'd, 'm | 'd,) | 'head | 'p, tail: 'k}
//│     'i :> forall 'r, 'head0. Nil | 'r
//│     'r :> Cons['a2 | 'a0 | 'j | 'c] with {head: 'head0 | 'j | 'c, tail: 'i}
