:NewDefs
:GADTs

fun fst([x, y]) = x
fun snd([x, y]) = y 
fun (++) stringConcat(a, b) = concat(a)(b)
//│ fun fst: forall 'a. (['a, anything]) -> 'a
//│ fun snd: forall 'b. ([anything, 'b]) -> 'b
//│ fun (++) stringConcat: (Str, Str) -> Str

// statically typed format //

abstract class Format[type F]: D[F] | B[F] | L[F] | E
class D[F](fmt: Format[F]) extends Format[Int -> F]
class B[F](fmt: Format[F]) extends Format[Bool -> F]
class L[F](s: Str, fmt: Format[F]) extends Format[F]
module E extends Format[Str]
//│ abstract class Format[F]: B[F] | D[F] | E | L[F]
//│ class D[F](fmt: Format[F]) extends Format
//│ class B[F](fmt: Format[F]) extends Format
//│ class L[F](s: Str, fmt: Format[F]) extends Format
//│ module E extends Format

fun fmtGo: (Str, Format['F]) -> 'F
fun fmtGo(acc, f) = if f is
    D(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
    B(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
    L(s, fmt) then fmtGo(acc ++ s, fmt) : f.F
    E         then acc : f.F
//│ fun fmtGo: forall 'F 'a 'F0 'F1 'F2 'F3 'F4 'F5 'F6 'F7 'F8. (Str & 'F0, B[in 'F out 'F2] & {
//│   B#F :> 'F2 <: 'F,
//│   #fmt: Format[in 'F4 & 'F5 & 'F7 out 'F4 | 'F5 | 'F7],
//│   F :> anything -> 'F5 <: 'a
//│ } & ~{L#F :> 'F1 & 'F3 | ??F <: ??F0 & 'F3} | B[in 'F out 'F2] & {
//│   B#F :> 'F2 <: 'F,
//│   #fmt: Format[in 'F4 & 'F5 & 'F7 out 'F4 | 'F5 | 'F7],
//│   F :> anything -> ('F4 | 'F5) | 'F7 | 'F0 <: 'a,
//│   #s: Str
//│ } | B[in 'F out 'F2] & {
//│   B#F :> 'F2 <: 'F,
//│   #fmt: Format[in 'F5 & 'F7 out 'F5 | 'F7],
//│   F :> anything -> 'F5 <: 'a
//│ } & ~{D#F :> 'F6 & 'F8 | ??F1 <: ??F2 & 'F8} | B[in 'F out 'F2] & {
//│   B#F :> 'F2 <: 'F,
//│   #fmt: Format[in 'F4 & 'F5 & 'F7 out 'F4 | 'F5 | 'F7],
//│   F :> anything -> ('F4 | 'F5) & 'F7 | anything -> 'F5 | 'F0 <: 'a
//│ } | B[in 'F out 'F2] & {B#F :> 'F2 <: 'F, #fmt: Format['F5], F :> anything -> 'F5 <: 'a} | B[in 'F out 'F2] & {B#F :> 'F2 <: 'F} & ~#B | B[in 'F out 'F2] & {B#F :> 'F2 <: 'F} & ~{D#F :> 'F6 & 'F8 | ??F1 <: ??F2 & 'F8} & ~#B | B[in 'F out 'F2] & {B#F :> 'F2 <: 'F} & ~{L#F :> 'F1 & 'F3 | ??F <: ??F0 & 'F3} & ~#B | B[in 'F out 'F2] & {B#F :> 'F2 <: 'F} & ~{B#F :> 'F2 & 'F | ??F3 <: ??F4 & 'F} | D[in 'F8 out 'F6] & {
//│   #fmt: Format[in 'F4 & 'F5 & 'F7 out 'F4 | 'F5 | 'F7],
//│   F :> anything -> 'F4 <: 'a,
//│   D#F :> 'F6 <: 'F8
//│ } & ~{L#F :> 'F1 & 'F3 | ??F <: ??F0 & 'F3} | D[in 'F8 out 'F6] & {
//│   #fmt: Format[in 'F4 & 'F5 & 'F7 out 'F4 | 'F5 | 'F7],
//│   F :> anything -> ('F4 | 'F5) | 'F7 | 'F0 <: 'a,
//│   #s: Str,
//│   D#F :> 'F6 <: 'F8
//│ } | D[in 'F8 out 'F6] & {
//│   #fmt: Format[in 'F4 & 'F7 out 'F4 | 'F7],
//│   F :> anything -> 'F4 <: 'a,
//│   D#F :> 'F6 <: 'F8
//│ } & ~{B#F :> 'F2 & 'F | ??F3 <: ??F4 & 'F} | D[in 'F8 out 'F6] & {
//│   #fmt: Format[in 'F4 & 'F5 & 'F7 out 'F4 | 'F5 | 'F7],
//│   F :> anything -> ('F4 | 'F5) & 'F7 | anything -> 'F4 | 'F0 <: 'a,
//│   D#F :> 'F6 <: 'F8
//│ } | D[in 'F8 out 'F6] & {#fmt: Format['F4], F :> anything -> 'F4 <: 'a, D#F :> 'F6 <: 'F8} | D[in 'F8 out 'F6] & {D#F :> 'F6 <: 'F8} & ~#D | D[in 'F8 out 'F6] & {D#F :> 'F6 <: 'F8} & ~{B#F :> 'F2 & 'F | ??F3 <: ??F4 & 'F} & ~#D | D[in 'F8 out 'F6] & {D#F :> 'F6 <: 'F8} & ~{L#F :> 'F1 & 'F3 | ??F <: ??F0 & 'F3} & ~#D | D[in 'F8 out 'F6] & {D#F :> 'F6 <: 'F8} & ~{D#F :> 'F6 & 'F8 | ??F1 <: ??F2 & 'F8} | E & {F :> 'F0 <: 'a} | E & ~#E | E & ~{B#F :> 'F2 & 'F | ??F3 <: ??F4 & 'F} & ~#E | E & ~{D#F :> 'F6 & 'F8 | ??F1 <: ??F2 & 'F8} & ~#E | E & ~{L#F :> 'F1 & 'F3 | ??F <: ??F0 & 'F3} & ~#E | L[in 'F3 out 'F1] & {
//│   L#F :> 'F1 <: 'F3,
//│   #fmt: Format[in 'F4 & 'F5 & 'F7 out 'F4 | 'F5 | 'F7],
//│   F :> anything -> ('F4 | 'F5) | 'F7 | 'F0 <: 'a,
//│   #s: Str
//│ } | L[in 'F3 out 'F1] & {
//│   L#F :> 'F1 <: 'F3,
//│   #fmt: Format[in 'F4 & 'F5 & 'F7 out 'F4 | 'F5 | 'F7],
//│   F :> 'F7 | 'F0 | anything -> ('F4 & 'F5) <: 'a,
//│   #s: Str
//│ } | L[in 'F3 out 'F1] & {L#F :> 'F1 <: 'F3, #fmt: Format[in 'F5 & 'F7 out 'F5 | 'F7], F :> 'F7 <: 'a, #s: Str} & ~{D#F :> 'F6 & 'F8 | ??F1 <: ??F2 & 'F8} | L[in 'F3 out 'F1] & {L#F :> 'F1 <: 'F3, #fmt: Format[in 'F4 & 'F7 out 'F4 | 'F7], F :> 'F7 <: 'a, #s: Str} & ~{B#F :> 'F2 & 'F | ??F3 <: ??F4 & 'F} | L[in 'F3 out 'F1] & {L#F :> 'F1 <: 'F3, #fmt: Format['F7], F :> 'F7 <: 'a, #s: Str} | L[in 'F3 out 'F1] & {L#F :> 'F1 <: 'F3} & ~#L | L[in 'F3 out 'F1] & {L#F :> 'F1 <: 'F3} & ~{B#F :> 'F2 & 'F | ??F3 <: ??F4 & 'F} & ~#L | L[in 'F3 out 'F1] & {L#F :> 'F1 <: 'F3} & ~{D#F :> 'F6 & 'F8 | ??F1 <: ??F2 & 'F8} & ~#L | L[in 'F3 out 'F1] & {L#F :> 'F1 <: 'F3} & ~{L#F :> 'F1 & 'F3 | ??F <: ??F0 & 'F3}) -> 'a
//│ fun fmtGo: forall 'F9. (Str, Format['F9]) -> 'F9

fun fmt(f) = fmtGo("", f)
//│ fun fmt: forall 'F. Format['F] -> 'F

let test = L("int i = ", D(L(", bool b = ", B(E))))
//│ let test: L[Int -> 'F]
//│   where
//│     'F := Bool -> Str
//│ test
//│      = L {}

fmt(test)
//│ Int -> Bool -> Str
//│ res
//│     = [Function (anonymous)]

fmt(test)(114)(false)
//│ Str
//│ res
//│     = 'int i = 114, bool b = false'

:e
fmt(test)("hello")("world")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.98: 	fmt(test)("hello")("world")
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"hello"` is not an instance of type `Int`
//│ ║  l.98: 	fmt(test)("hello")("world")
//│ ║        	          ^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.14: 	class D[F](fmt: Format[F]) extends Format[Int -> F]
//│ ╙──      	                                          ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.98: 	fmt(test)("hello")("world")
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"world"` is not an instance of type `Bool`
//│ ║  l.98: 	fmt(test)("hello")("world")
//│ ║        	                   ^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.15: 	class B[F](fmt: Format[F]) extends Format[Bool -> F]
//│ ╙──      	                                          ^^^^
//│ Str | error
//│ res
//│     = 'int i = hello, bool b = world'


// typed ast //

abstract class Expr[type T]: Lit | Plus| Equals | If | Pair | Fst
class Lit(i: Int) extends Expr[Int]
class Plus(a: Expr[Int], b: Expr[Int]) extends Expr[Int]
class Equals(a: Expr[Int], b: Expr[Int]) extends Expr[Bool]
class If[A](p: Expr[Bool],a: Expr[A],b: Expr[A]) extends Expr[A]
class Pair[A, B](a: Expr[A], b: Expr[B]) extends Expr[[A, B]]
class Fst[A, B](p: Expr[[A, B]]) extends Expr[A]
//│ abstract class Expr[T]: Equals | Fst[?, ?] | If[?] | Lit | Pair[?, ?] | Plus
//│ class Lit(i: Int) extends Expr
//│ class Plus(a: Expr[Int], b: Expr[Int]) extends Expr
//│ class Equals(a: Expr[Int], b: Expr[Int]) extends Expr
//│ class If[A](p: Expr[Bool], a: Expr[A], b: Expr[A]) extends Expr
//│ class Pair[A, B](a: Expr[A], b: Expr[B]) extends Expr
//│ class Fst[A, B](p: Expr[[A, B]]) extends Expr

fun eval: Expr['T] -> 'T
fun eval(e: Expr['t]): e.T = if e is
    Lit(i) then i : e.T
    Plus(a, b) then eval(a) + eval(b) : e.T
    Equals(a, b) then (eval(a) == eval(b)) : e.T
    If(p, a, b) then if eval(p) then eval(a) : e.T else eval(b) : e.T
    Pair(a, b) then [eval(a), eval(b)] : e.T
    Fst(p) then fst(eval(p)) : e.T
//│ fun eval: forall 't. (e: Expr['t]) -> ('t & (Int | false | true | [??A, ??B] | ??A0 | ??A1))
//│ fun eval: forall 'T. Expr['T] -> 'T

eval(Plus(Lit(1), Lit(1)))
//│ Int
//│ res
//│     = 2

eval(If(Equals(Lit(3), Plus(Lit(1), Lit(1))), Fst(Pair(Lit(1), Lit(2))), Lit(3)))
//│ Int
//│ res
//│     = 3

:e
eval(Plus(Equals(Lit(1), Lit(2)), Lit(3)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.161: 	eval(Plus(Equals(Lit(1), Lit(2)), Lit(3)))
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Bool` is not an instance of `Int`
//│ ║  l.127: 	class Equals(a: Expr[Int], b: Expr[Int]) extends Expr[Bool]
//│ ║         	                                                      ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.126: 	class Plus(a: Expr[Int], b: Expr[Int]) extends Expr[Int]
//│ ╙──       	                   ^^^
//│ Int
//│ res
//│     = 3
