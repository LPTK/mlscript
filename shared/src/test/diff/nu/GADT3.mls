:NewDefs

abstract class Foo[type T]: Bar | Baz
class Bar extends Foo[Int]
class Baz[T](val x: Foo[T]) extends Foo[[T]]
//│ abstract class Foo[T]: Bar | Baz[?]
//│ class Bar extends Foo {
//│   constructor()
//│ }
//│ class Baz[T](x: Foo[T]) extends Foo

// TODO
fun foo[T](f: Foo[T]): Int = if f is
    Bar then 0
    Baz(x) then foo(x : Foo[x.T])
//│ ╔══[ERROR] Subtyping constraint of the form `([?a]) -> ?b <: ?c -> ?d` exceeded recursion depth limit (250)
//│ ║  l.13: 	fun foo[T](f: Foo[T]): Int = if f is
//│ ║        	                                ^^^^
//│ ║  l.14: 	    Bar then 0
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.15: 	    Baz(x) then foo(x : Foo[x.T])
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ ╔══[ERROR] Type error in definition
//│ ║  l.13: 	fun foo[T](f: Foo[T]): Int = if f is
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.14: 	    Bar then 0
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.15: 	    Baz(x) then foo(x : Foo[x.T])
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `T` leaks out of its scope
//│ ║  l.15: 	    Baz(x) then foo(x : Foo[x.T])
//│ ║        	                             ^^
//│ ╙── into expression of type `T | ~(Int & ??T)`
//│ ╔══[ERROR] Type error in definition
//│ ║  l.13: 	fun foo[T](f: Foo[T]): Int = if f is
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.14: 	    Bar then 0
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.15: 	    Baz(x) then foo(x : Foo[x.T])
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `T` leaks out of its scope
//│ ║  l.5: 	class Baz[T](val x: Foo[T]) extends Foo[[T]]
//│ ╙──     	          ^
//│ fun foo: forall 'T. (f: Foo['T]) -> Int

fun foo: Foo['a] -> Int
fun foo(f) = if f is
    Bar then 0
    Baz(x) then foo(x)
//│ fun foo: (Bar | Baz[in anything out nothing]) -> Int
//│ fun foo: forall 'a. Foo['a] -> Int

abstract class Foo[type T]: Bar | Baz[T]
class Bar extends Foo[Int]
class Baz[T](val x: Foo[T]) extends Foo[[T]]
//│ abstract class Foo[T]: Bar | Baz[T]
//│ class Bar extends Foo {
//│   constructor()
//│ }
//│ class Baz[T](x: Foo[T]) extends Foo

fun foo[T](f: Foo[T]): Int = if f is
    Bar then 0
    Baz(x) then foo(x : Foo[x.T])
//│ fun foo: forall 'T. (f: Foo['T]) -> Int

fun bar(f) = if f is 
    Bar then 0
    Baz(_) then 1
//│ fun bar: (Bar | Baz[in anything out nothing]) -> (0 | 1)

bar(Baz(new Bar))
//│ 0 | 1
//│ res
//│     = 1

abstract class C[type T]: D1 | D2
class D1 extends C[Int]
class D2[A, B](val a: C[A], val b: C[B]) extends C[[A, B]]
//│ abstract class C[T]: D1 | D2[?, ?]
//│ class D1 extends C {
//│   constructor()
//│ }
//│ class D2[A, B](a: C[A], b: C[B]) extends C

abstract class C[type T]: C1 | C2
class C1[type A](c: A) extends C[A]
class C2 extends C[Int]
//│ abstract class C[T]: C1[anything] | C2
//│ class C1[A](c: A) extends C
//│ class C2 extends C {
//│   constructor()
//│ }

// :d
:e // Needs type annot on parameter for GADT reasoning
fun foo: C['T] -> 'T
fun foo(x) = if x is
    C1(c) then c : x.T
    C2    then 0 : x.T
//│ ╔══[ERROR] Type error in definition
//│ ║  l.99: 	fun foo(x) = if x is
//│ ║        	    ^^^^^^^^^^^^^^^^
//│ ║  l.100: 	    C1(c) then c : x.T
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.101: 	    C2    then 0 : x.T
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.100: 	    C1(c) then c : x.T
//│ ║         	                    ^^
//│ ╟── into type `'T | ~??A`
//│ ║  l.98: 	fun foo: C['T] -> 'T
//│ ╙──      	                  ^^
//│ fun foo: forall 'A. (C1['A] | C2) -> (Int | ??A & 'A)
//│ fun foo: forall 'T. C['T] -> 'T

foo(C1(true))
//│ true
//│ res
//│     = true

foo(new C2)
//│ Int
//│ res
//│     = 0

fun foo(x: C['a]): x.T = if x is
    C1(c) then c : x.T
    C2    then 0 : x.T
//│ fun foo: forall 'a. (x: C['a]) -> ('a & (Int | ??A))

abstract class Option[type T]: None | Some[T]
module None extends Option[nothing]
class Some[A](get: A) extends Option[A]
//│ abstract class Option[T]: None | Some[T]
//│ module None extends Option
//│ class Some[A](get: A) extends Option

fun getOr(x, d) = if x is
    None then d
    Some(g) then g
//│ fun getOr: forall 'A 'a. (None | Some['A], 'a) -> (??A & 'A | 'a)

fun getOr(x: Option['a], d) = if x is
    None then d
    Some(g) then g
//│ fun getOr: forall 'a 'b. (x: Option['a], 'b) -> (??A & 'a | 'b)

fun getOr[T](x: Option[T], d: T): T = if x is
    None then d
    Some(g) then g
//│ fun getOr: forall 'T. (x: Option['T], d: 'T) -> 'T

fun get(x) = if x is Some(r) then r else error
//│ fun get: forall 'A. (Object & ~#Some | Some['A]) -> (??A & 'A)

fun get(x: Option['a]): x.T = if x is Some(r) then r else error
//│ fun get: forall 'a. (x: Option['a]) -> 'a
