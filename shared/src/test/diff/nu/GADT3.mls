:NewDefs
:GADTs

abstract class Foo[type T]: Bar | Baz
class Bar extends Foo[Int]
class Baz[T](val x: Foo[T]) extends Foo[[T]]
//│ abstract class Foo[T]: Bar | Baz[?]
//│ class Bar extends Foo {
//│   constructor()
//│ }
//│ class Baz[T](x: Foo[T]) extends Foo

:e
fun foo[T](f: Foo[T]): Int = if f is
    Bar then 0
    Baz(x) then foo(x)
//│ ╔══[ERROR] Type error in definition
//│ ║  l.14: 	fun foo[T](f: Foo[T]): Int = if f is
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.15: 	    Bar then 0
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.16: 	    Baz(x) then foo(x)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `T` leaks out of its scope
//│ ║  l.6: 	class Baz[T](val x: Foo[T]) extends Foo[[T]]
//│ ║       	          ^
//│ ╙── into expression of type `T | ~??T`
//│ ╔══[ERROR] Type error in definition
//│ ║  l.14: 	fun foo[T](f: Foo[T]): Int = if f is
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.15: 	    Bar then 0
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.16: 	    Baz(x) then foo(x)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `T` leaks out of its scope
//│ ║  l.6: 	class Baz[T](val x: Foo[T]) extends Foo[[T]]
//│ ╙──     	          ^
//│ fun foo: forall 'T. (f: Foo['T]) -> Int

fun foo(f) = if f is
    Bar then 0
    Baz(x) then foo(x)
fun foo: Foo['a] -> Int
//│ fun foo: forall 'T 'a 'T0. (Bar | Bar & ~{Baz#T :> 'T0 & 'T | ??T <: ??T0 & 'T} | Baz[in 'T out 'T0] & {Baz#T :> 'T0 <: 'T, #x: Foo['a]} | Baz[in 'T out 'T0] & {Baz#T :> 'T0 <: 'T} & ~#Baz | Baz[in 'T out 'T0] & {Baz#T :> 'T0 <: 'T} & ~{Baz#T :> 'T0 & 'T | ??T <: ??T0 & 'T}) -> Int
//│ fun foo: forall 'a0. Foo['a0] -> Int

abstract class Foo[type T]: Bar | Baz[T]
class Bar extends Foo[Int]
class Baz[T](val x: Foo[T]) extends Foo[[T]]
//│ abstract class Foo[T]: Bar | Baz[T]
//│ class Bar extends Foo {
//│   constructor()
//│ }
//│ class Baz[T](x: Foo[T]) extends Foo

fun foo[T](f: Foo[T]): Int = if f is
    Bar then 0
    Baz(x) then foo(x : Foo[x.T])
//│ fun foo: forall 'T. (f: Foo['T]) -> Int

fun bar(f) = if f is 
    Bar then 0
    Baz(_) then 1
//│ fun bar: forall 'T 'T0. (Bar | Bar & ~{Baz#T :> 'T & 'T0 | ??T <: ??T0 & 'T0} | Baz[in 'T0 out 'T] & {Baz#T :> 'T <: 'T0, #x: anything} | Baz[in 'T0 out 'T] & {Baz#T :> 'T <: 'T0} & ~#Baz | Baz[in 'T0 out 'T] & {Baz#T :> 'T <: 'T0} & ~{Baz#T :> 'T & 'T0 | ??T <: ??T0 & 'T0}) -> (0 | 1)

bar(Baz(new Bar))
//│ 0 | 1
//│ res
//│     = 1

abstract class C[type T]: D1 | D2
class D1 extends C[Int]
class D2[A, B](val a: C[A], val b: C[B]) extends C[[A, B]]
//│ abstract class C[T]: D1 | D2[?, ?]
//│ class D1 extends C {
//│   constructor()
//│ }
//│ class D2[A, B](a: C[A], b: C[B]) extends C
