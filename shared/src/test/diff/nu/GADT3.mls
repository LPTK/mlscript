:NewDefs
:GADTs

abstract class Foo[type T]: Bar | Baz
class Bar extends Foo[Int]
class Baz[T](val x: Foo[T]) extends Foo[[T]]
//│ abstract class Foo[T]: Bar | Baz[?]
//│ class Bar extends Foo {
//│   constructor()
//│ }
//│ class Baz[T](x: Foo[T]) extends Foo

// TODO
fun foo[T](f: Foo[T]): Int = if f is
    Bar then 0
    Baz(x) then foo(x : Foo[x.T])
//│ ╔══[ERROR] Subtyping constraint of the form `([?a]) -> ?b <: ?c -> ?d` exceeded recursion depth limit (250)
//│ ║  l.14: 	fun foo[T](f: Foo[T]): Int = if f is
//│ ║        	                                ^^^^
//│ ║  l.15: 	    Bar then 0
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.16: 	    Baz(x) then foo(x : Foo[x.T])
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ ╔══[ERROR] Type error in definition
//│ ║  l.14: 	fun foo[T](f: Foo[T]): Int = if f is
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.15: 	    Bar then 0
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.16: 	    Baz(x) then foo(x : Foo[x.T])
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `T` leaks out of its scope
//│ ║  l.16: 	    Baz(x) then foo(x : Foo[x.T])
//│ ║        	                             ^^
//│ ╙── into expression of type `T | ~(Int & ??T)`
//│ ╔══[ERROR] Type error in definition
//│ ║  l.14: 	fun foo[T](f: Foo[T]): Int = if f is
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.15: 	    Bar then 0
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.16: 	    Baz(x) then foo(x : Foo[x.T])
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `T` leaks out of its scope
//│ ║  l.6: 	class Baz[T](val x: Foo[T]) extends Foo[[T]]
//│ ╙──     	          ^
//│ fun foo: forall 'T. (f: Foo['T]) -> Int

abstract class Foo[type T]: Bar | Baz[T]
class Bar extends Foo[Int]
class Baz[T](val x: Foo[T]) extends Foo[[T]]
//│ abstract class Foo[T]: Bar | Baz[T]
//│ class Bar extends Foo {
//│   constructor()
//│ }
//│ class Baz[T](x: Foo[T]) extends Foo

fun foo[T](f: Foo[T]): Int = if f is
    Bar then 0
    Baz(x) then foo(x : Foo[x.T])
//│ fun foo: forall 'T. (f: Foo['T]) -> Int
