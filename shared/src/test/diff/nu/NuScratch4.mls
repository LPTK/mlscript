:NewDefs
:NoJS


class Ref[T](x: T -> T)
//│ class Ref[T](x: T -> T)


// fun refined[A](r: Ref[A])
// fun refined[A, B](r: A): A & Ref[B]
fun refined: forall 'A, 'B: (r: 'A) -> ('A & Ref['B])
//│ fun refined: forall 'A 'B. (r: 'A) -> (Ref['B] & 'A)

fun test(x: 'x) =
  let foo() = refined(x)
  foo
//│ fun test: forall 'x. (x: 'x) -> (forall 'B. () -> (Ref['B] & 'x))

// fun refined: forall 'A, 'B, 'C: (r: 'A, s: 'B) -> ('A & 'B & Ref['C])
fun refined: forall 'A, 'B, 'C: (r: 'A, s: 'B) -> ('A & 'B)
//│ fun refined: forall 'A 'B. (r: 'A, s: 'B) -> ('A & 'B)

// fun test(x: 'x) =
//   let foo(y: Ref['r] & 'y) = y
//   foo(x)

:d
fun test(x: 'x) =
  let foo(y) = refined(x, y) : Ref['r]
  foo
//│ 0. Typing TypingUnit(List(NuFunDef(None,Var(test),None,List(),Left(Lam(Tup(List((Some(Var(x)),Fld(_,Var('x))))),Blk(List(NuFunDef(Some(false),Var(foo),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(y))))),Asc(App(Var(refined),Tup(List((None,Fld(_,Var(x))), (None,Fld(_,Var(y)))))),AppliedType(TypeName(Ref),List('r)))))), Var(foo))))))))
//│ | 0. Created lazy type info for NuFunDef(None,Var(test),None,List(),Left(Lam(Tup(List((Some(Var(x)),Fld(_,Var('x))))),Blk(List(NuFunDef(Some(false),Var(foo),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(y))))),Asc(App(Var(refined),Tup(List((None,Fld(_,Var(x))), (None,Fld(_,Var(y)))))),AppliedType(TypeName(Ref),List('r)))))), Var(foo))))))
//│ | Completing fun test = (x: 'x,) => {let foo = (y,) => refined(x, y,) : Ref['r]; foo}
//│ | | Type params 
//│ | | Params 
//│ | | Type test polymorphically? true && (0 === 0 || false || false
//│ | | 1. Typing term (x: 'x,) => {let foo = (y,) => refined(x, y,) : Ref['r]; foo}
//│ | | | 1. Typing pattern [x: 'x,]
//│ | | | | 1. Typing pattern x : 'x
//│ | | | | | Typing type 'x
//│ | | | | | | vars=Map() newDefsInfo=Map()
//│ | | | | | | 1. type 'x
//│ | | | | | | => 'x74'
//│ | | | | | => 'x74' ——— 'x74'
//│ | | | | 1. : 'x74'
//│ | | | 1. : (x: 'x74',)
//│ | | | 1. Typing term {let foo = (y,) => refined(x, y,) : Ref['r]; foo}
//│ | | | | 1. Typing TypingUnit(List(NuFunDef(Some(false),Var(foo),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(y))))),Asc(App(Var(refined),Tup(List((None,Fld(_,Var(x))), (None,Fld(_,Var(y)))))),AppliedType(TypeName(Ref),List('r)))))), Var(foo)))
//│ | | | | | 1. Created lazy type info for NuFunDef(Some(false),Var(foo),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(y))))),Asc(App(Var(refined),Tup(List((None,Fld(_,Var(x))), (None,Fld(_,Var(y)))))),AppliedType(TypeName(Ref),List('r))))))
//│ | | | | | Completing let foo = (y,) => refined(x, y,) : Ref['r]
//│ | | | | | | Type params 
//│ | | | | | | Params 
//│ | | | | | | Type foo polymorphically? true && (1 === 0 || false || true
//│ | | | | | | 2. Typing term (y,) => refined(x, y,) : Ref['r]
//│ | | | | | | | 2. Typing pattern [y,]
//│ | | | | | | | | 2. Typing pattern y
//│ | | | | | | | | 2. : y75''
//│ | | | | | | | 2. : (y75'',)
//│ | | | | | | | 2. Typing term refined(x, y,) : Ref['r]
//│ | | | | | | | | 2. Typing term refined(x, y,)
//│ | | | | | | | | | 2. Typing term refined
//│ | | | | | | | | | 2. : ‹∀ 0. ‹∀ 1. ((r: 'A62'', s: 'B63'',) -> ('A62'' & 'B63''))››
//│ | | | | | | | | | 2. Typing term x
//│ | | | | | | | | | 2. : 'x74'
//│ | | | | | | | | | 2. Typing term y
//│ | | | | | | | | | 2. : y75''
//│ | | | | | | | | | CONSTRAIN ‹∀ 0. ‹∀ 1. ((r: 'A62'', s: 'B63'',) -> ('A62'' & 'B63''))›› <! (('x74', y75'',) -> α76'')
//│ | | | | | | | | |   where 
//│ | | | | | | | | | 2. C ‹∀ 0. ‹∀ 1. ((r: 'A62'', s: 'B63'',) -> ('A62'' & 'B63''))›› <! (('x74', y75'',) -> α76'')    (0)
//│ | | | | | | | | | | 2. C ‹∀ 1. ((r: 'A62'', s: 'B63'',) -> ('A62'' & 'B63''))› <! (('x74', y75'',) -> α76'')    (2)
//│ | | | | | | | | | | | could be distribbed: Set('A62'', 'B63'')
//│ | | | | | | | | | | | cannot be distribbed: Set('A62'', 'B63'')
//│ | | | | | | | | | | | INST [1]   ‹∀ 1. ((r: 'A62'', s: 'B63'',) -> ('A62'' & 'B63''))›
//│ | | | | | | | | | | |   where  
//│ | | | | | | | | | | | TO [2] ~>  ((r: 'A62_77'', s: 'B63_78'',) -> ('A62_77'' & 'B63_78''))
//│ | | | | | | | | | | |   where  
//│ | | | | | | | | | | | 2. C ((r: 'A62_77'', s: 'B63_78'',) -> ('A62_77'' & 'B63_78'')) <! (('x74', y75'',) -> α76'')    (4)
//│ | | | | | | | | | | | | 2. C ('x74', y75'',) <! (r: 'A62_77'', s: 'B63_78'',)    (3)
//│ | | | | | | | | | | | | | 2. C 'x74' <! 'A62_77''    (4)
//│ | | | | | | | | | | | | | | 2. C 'x74' <! 'A62_77''    (4)
//│ | | | | | | | | | | | | | | | NEW 'A62_77'' LB (1)
//│ | | | | | | | | | | | | | 2. C y75'' <! 'B63_78''    (4)
//│ | | | | | | | | | | | | | | 2. C y75'' <! 'B63_78''    (4)
//│ | | | | | | | | | | | | | | | NEW y75'' UB (2)
//│ | | | | | | | | | | | | 2. C ('A62_77'' & 'B63_78'') <! α76''    (3)
//│ | | | | | | | | | | | | | NEW α76'' LB (2)
//│ | | | | | | | | 2. : α76''
//│ | | | | | | | | Typing type AppliedType(TypeName(Ref),List('r))
//│ | | | | | | | | | vars=Map() newDefsInfo=Map()
//│ | | | | | | | | | 2. type AppliedType(TypeName(Ref),List('r))
//│ | | | | | | | | | | 2. type 'r
//│ | | | | | | | | | | => 'r79''
//│ | | | | | | | | | => Ref['r79'']
//│ | | | | | | | | => Ref['r79''] ——— 'r79''
//│ | | | | | | | | CONSTRAIN α76'' <! Ref['r79'']
//│ | | | | | | | |   where 
//│ 		α76'' :> ('A62_77'' & 'B63_78'')
//│ 		'A62_77'' :> 'x74'
//│ | | | | | | | | 2. C α76'' <! Ref['r79'']    (0)
//│ | | | | | | | | | NEW α76'' UB (2)
//│ | | | | | | | | | 2. C ('A62_77'' & 'B63_78'') <! Ref['r79'']    (2)
//│ | | | | | | | | | | Passing T :: T30' <=< 'r79''
//│ | | | | | | | | | | 2. C ('A62_77'' & 'B63_78'') <! (#Ref<Object> & {Ref#T: mut 'r79''..'r79''})    (4)
//│ | | | | | | | | | | | 2. C ('A62_77'' & 'B63_78'') <! #Ref<Object>    (6)
//│ | | | | | | | | | | | | 2. ARGH  DNF(2, 'A62_77''∧'B63_78'')  <!  DNF(0, #Ref<Object>{})
//│ | | | | | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | | | | | 2. C 'A62_77'' <! (#Ref<Object> | ~('B63_78''))    (8)
//│ | | | | | | | | | | | | | | NEW 'A62_77'' UB (2)
//│ | | | | | | | | | | | | | | 2. C 'x74' <! (#Ref<Object> | ~('B63_78''))    (10)
//│ | | | | | | | | | | | | | | | 2. C 'B63_78'' <! (~('x74') | #Ref<Object>)    (10)
//│ | | | | | | | | | | | | | | | | NEW 'B63_78'' UB (1)
//│ | | | | | | | | | | | 2. C ('A62_77'' & 'B63_78'') <! {Ref#T: mut 'r79''..'r79''}    (6)
//│ | | | | | | | | | | | | 2. ARGH  DNF(2, 'A62_77''∧'B63_78'')  <!  DNF(2, {Ref#T: mut 'r79''..'r79''})
//│ | | | | | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | | | | | 2. C 'A62_77'' <! ({Ref#T: mut 'r79''..'r79''} | ~('B63_78''))    (8)
//│ | | | | | | | | | | | | | | NEW 'A62_77'' UB (2)
//│ | | | | | | | | | | | | | | 2. C 'x74' <! ({Ref#T: mut 'r79''..'r79''} | ~('B63_78''))    (10)
//│ | | | | | | | | | | | | | | | 2. C 'B63_78'' <! (~('x74') | {Ref#T: mut 'r79''..'r79''})    (10)
//│ | | | | | | | | | | | | | | | | NEW 'B63_78'' UB (2)
//│ | | | | | | | 2. : Ref['r79'']
//│ | | | | | | 2. : (y75'' -> Ref['r79''])
//│ | | | | | | CONSTRAIN (y75'' -> Ref['r79'']) <! foo80''
//│ | | | | | |   where 
//│ 		y75'' <: 'B63_78''
//│ 		'B63_78'' <: (~('x74') | {Ref#T: mut 'r79''..'r79''}) & (~('x74') | #Ref<Object>)
//│ | | | | | | 2. C (y75'' -> Ref['r79'']) <! foo80''    (0)
//│ | | | | | | | NEW foo80'' LB (2)
//│ | | | | | Completed TypedNuFun(1,NuFunDef(Some(false),Var(foo),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(y))))),Asc(App(Var(refined),Tup(List((None,Fld(_,Var(x))), (None,Fld(_,Var(y)))))),AppliedType(TypeName(Ref),List('r)))))),(y75'' -> Ref['r79''])) where 
//│ 		y75'' <: 'B63_78''
//│ 		'B63_78'' <: (~('x74') | {Ref#T: mut 'r79''..'r79''}) & (~('x74') | #Ref<Object>)
//│ | | | | | Typing unit statements
//│ | | | | | | 1. Typing term foo
//│ | | | | | | 1. : ‹∀ 1. (y75'' -> Ref['r79''])›
//│ | | | | | : Some(‹∀ 1. (y75'' -> Ref['r79''])›)
//│ | | | 1. : ‹∀ 1. (y75'' -> Ref['r79''])›
//│ | | 1. : ((x: 'x74',) -> ‹∀ 1. (y75'' -> Ref['r79''])›)
//│ | | CONSTRAIN ((x: 'x74',) -> ‹∀ 1. (y75'' -> Ref['r79''])›) <! test81'
//│ | |   where 
//│ 		y75'' <: 'B63_78''
//│ 		'B63_78'' <: (~('x74') | {Ref#T: mut 'r79''..'r79''}) & (~('x74') | #Ref<Object>)
//│ | | 1. C ((x: 'x74',) -> ‹∀ 1. (y75'' -> Ref['r79''])›) <! test81'    (0)
//│ | | | NEW test81' LB (1)
//│ | Completed TypedNuFun(0,NuFunDef(None,Var(test),None,List(),Left(Lam(Tup(List((Some(Var(x)),Fld(_,Var('x))))),Blk(List(NuFunDef(Some(false),Var(foo),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(y))))),Asc(App(Var(refined),Tup(List((None,Fld(_,Var(x))), (None,Fld(_,Var(y)))))),AppliedType(TypeName(Ref),List('r)))))), Var(foo)))))),((x: 'x74',) -> ‹∀ 1. (y75'' -> Ref['r79''])›)) where 
//│ 		y75'' <: 'B63_78''
//│ 		'B63_78'' <: (~('x74') | {Ref#T: mut 'r79''..'r79''}) & (~('x74') | #Ref<Object>)
//│ | Typing unit statements
//│ | : None
//│ ======== TYPED ========
//│ fun test: ‹∀ 0. ((x: 'x74',) -> ‹∀ 1. (y75'' -> Ref['r79''])›)› where 
//│ |		y75'' <: 'B63_78''
//│ |		'B63_78'' <: (~('x74') | {Ref#T: mut 'r79''..'r79''}) & (~('x74') | #Ref<Object>)
//│ fun test: forall 'x. (x: 'x) -> (forall 'r. (Ref['r] | ~'x) -> Ref['r])





