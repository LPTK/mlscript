:NewDefs


abstract class IO[A] {
  fun bind(f) = Bind(this, f)
  fun hey = this
  fun run: A
}
class Bind[CC, AA](underlying: IO[CC], f: CC -> IO[AA]) extends IO[AA] {
  fun run = f(underlying.run).run
}
class Pure[A](value: A) extends IO[A] {
  fun run = value
}
//│ abstract class IO[A] {
//│   fun bind: forall 'CC 'AA. ('CC -> IO['AA]) -> Bind['CC, 'AA]
//│   fun hey: IO[A]
//│   fun run: A
//│ }
//│ class Bind[CC, AA](underlying: IO[CC], f: CC -> IO[AA]) extends IO {
//│   fun bind: forall 'CC0 'AA0. ('CC0 -> IO['AA0]) -> Bind['CC0, 'AA0]
//│   fun hey: IO['A]
//│   fun run: AA
//│ }
//│ class Pure[A](value: A) extends IO {
//│   fun bind: forall 'CC1 'AA1. ('CC1 -> IO['AA1]) -> Bind['CC1, 'AA1]
//│   fun hey: IO['A0]
//│   fun run: A
//│ }
//│ where
//│   'A0 := A
//│   'A := AA

module readInt extends IO[Int] { fun run: Int = 42 }
//│ module readInt extends IO {
//│   fun bind: forall 'CC 'AA. ('CC -> IO['AA]) -> Bind['CC, 'AA]
//│   fun hey: IO['A]
//│   fun run: Int
//│ }
//│ where
//│   'A := Int


let ri(f) = Bind(Pure(42), f)
// let ri(f) = Bind(Pure(42) : IO[Int], f)
// let ri(f) = Bind(error : IO[Int], f)
//│ let ri: forall 'CC 'AA. ('CC -> IO['AA]) -> Bind['CC, 'AA]
//│   where
//│     'CC :> 42
//│ ri
//│    = [Function: ri]

ri(Pure)
//│ Bind['CC, 'AA]
//│   where
//│     'CC :> 42
//│         <: 'AA
//│     'AA :> 42
//│ res
//│     = Bind {}

readInt.bind
//│ forall 'CC 'AA. ('CC -> IO['AA]) -> Bind['CC, 'AA]
//│ res
//│     = [Function: bind]

Bind(readInt, Pure)
//│ Bind[Int & 'AA, 'AA]
//│   where
//│     'AA :> Int
//│ res
//│     = Bind {}


// TODO prevent JS method extrusion; force explicit use of eta epxansion

let b = readInt.bind : (Int -> IO['B]) -> Bind[Int, 'B]
//│ let b: (Int -> IO['B]) -> Bind[Int, 'B]
//│ b
//│   = [Function: bind]

let b = readInt.bind : ('A -> IO['B]) -> Bind['A, 'B] where 'A : Int
//│ let b: ('A -> IO['B]) -> Bind['A, 'B]
//│   where
//│     'A <: Int
//│ b
//│   = [Function: bind]

let b = readInt.bind : ('A -> IO['B]) -> Bind['A, 'B] where Int : 'A
//│ let b: ('A -> IO['B]) -> Bind['A, 'B]
//│   where
//│     'A :> Int
//│ b
//│   = [Function: bind]


let r = b of Pure
//│ let r: Bind['A, 'B]
//│   where
//│     'A :> Int
//│        <: 'B
//│     'B :> Int
//│ r
//│   = Bind {}

:re // FIXME `undefined` due to JS method extrusion
r.run
//│ Int
//│ res
//│ Runtime error:
//│   TypeError: Cannot read properties of undefined (reading 'run')


let r = readInt.bind of Pure
//│ let r: Bind['CC, 'A]
//│   where
//│     'CC <: 'A
//│ r
//│   = Bind {}

r.run
//│ nothing
//│ res
//│     = 42

x => readInt.bind of x
//│ forall 'CC 'AA. ('CC -> IO['AA]) -> Bind['CC, 'AA]
//│ res
//│     = [Function: res]

readInt.bind of Pure
//│ Bind['CC, 'A]
//│   where
//│     'CC <: 'A
//│ res
//│     = Bind {}

readInt: IO['a]
//│ IO[Int]
//│ res
//│     = readInt { class: [class readInt extends IO] }

(readInt : IO[Int]).bind
//│ forall 'CC 'AA. ('CC -> IO['AA]) -> Bind['CC, 'AA]
//│ res
//│     = [Function: bind]

readInt.run
//│ Int
//│ res
//│     = 42

x => Pure(x).run
//│ forall 'run. 'run -> 'run
//│ res
//│     = [Function: res]


fun loop0 = readInt.bind of Pure
fun loop1 = readInt.bind of (Pure : Int => IO[Int])
fun loop2 = readInt.bind of ((x: Int) => Pure(x))
fun loop3 = readInt.bind of (x => Pure(x) : IO[Int])
//│ fun loop0: forall 'CC 'A. Bind['CC, 'A]
//│ fun loop1: forall 'CC0. Bind['CC0, Int]
//│ fun loop2: forall 'CC1 'AA. Bind['CC1, 'AA]
//│ fun loop3: forall 'CC2. Bind['CC2, Int]
//│ where
//│   'CC2 <: Int
//│   'AA :> Int
//│   'CC1 <: Int
//│   'CC0 <: Int
//│   'CC <: 'A

fun (#>>) bindOp(x, f) = x.bind(f)
//│ fun (#>>) bindOp: forall 'a 'b. ({bind: 'a -> 'b}, 'a) -> 'b

fun loop =
  readInt #>> n =>
  Pure(n)
//│ fun loop: forall 'CC 'A. Bind['CC, 'A]
//│   where
//│     'CC <: 'A



val x: Bind['A, 'B] where undefined : 'A; 'A : 'B
//│ val x: forall 'A 'B. Bind['A, 'B]
//│   where
//│     'A :> ()
//│        <: 'B
//│     'B :> ()
//│ x
//│   = <missing implementation>

x.run
//│ ()
//│ res
//│     = <no result>
//│       x is not implemented

val x: Bind['A, 'B] where 'A : undefined; 'A : 'B
//│ val x: forall 'A 'B. Bind['A, 'B]
//│   where
//│     'A <: () & 'B
//│ x
//│   = <missing implementation>

x.run
//│ nothing
//│ res
//│     = <no result>
//│       x is not implemented

val x: Bind[Int, Bool]
//│ val x: Bind[Int, Bool]
//│ x
//│   = <missing implementation>

// :d
x.run
//│ Bool
//│ res
//│     = <no result>
//│       x is not implemented




