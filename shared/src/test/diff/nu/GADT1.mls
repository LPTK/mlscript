:NewDefs
:GADTs

// natural numbers  for index //

class Z
class S[type P]
//│ class Z {
//│   constructor()
//│ }
//│ class S[P] {
//│   constructor()
//│ }

// sized list //

abstract class Vec[type L, type T]: Nil[T] | Cons[S, T]
class Nil[T] extends Vec[Z, T]
class Cons[L, T](val h: T, val t: Vec[L, T]) extends Vec[S[L], T]
//│ abstract class Vec[L, T]: Cons[in S[in anything out nothing] out S[?], T] | Nil[T]
//│ class Nil[T] extends Vec {
//│   constructor()
//│ }
//│ class Cons[L, T](h: T, t: Vec[L, T]) extends Vec

// functions //

fun head[T](xs: Vec[S['l], T]): T =
    if xs is Cons(h, t) then h : xs.T else error
//│ fun head: forall 'l 'T. (xs: Vec[S['l], 'T]) -> 'T

fun tail[L, T](xs: Vec[S[L], T]): Vec[L, T] =
    if xs is Cons(h, t) then t : Vec[xs.L.P, xs.T] else error
//│ fun tail: forall 'L 'T. (xs: Vec[S['L], 'T]) -> Vec['L, 'T]

fun len: Vec['l, 'a] -> Int
fun len(xs) = if xs is
    Nil then 0
    Cons(h, t) then 1 + len(t : Vec[xs.L.P, xs.T])
//│ fun len: forall 'P 'P0 'L 'T 'L0 'T0 'T1 'T2. (Cons[in 'L out 'L0, in 'T0 out 'T2] & {Cons#L :> 'L0 <: 'L, Cons#T :> 'T2 <: 'T0} & ~#Cons | Cons[in 'L out 'L0, in 'T0 out 'T2] & {Cons#L :> 'L0 <: 'L, Cons#T :> 'T2 <: 'T0} & ~{Cons#L :> 'L0 & 'L | ??L <: ??L0 & 'L} | Cons[in 'L out 'L0, in 'T0 out 'T2] & {Cons#L :> 'L0 <: 'L, Cons#T :> 'T2 <: 'T0} & ~{Cons#T :> 'T2 & 'T0 | ??T <: ??T0 & 'T0} | Cons[in 'L out 'L0, in 'T0 out 'T2] & {
//│   L <: {P :> 'P <: 'P & 'P0},
//│   T :> 'T <: 'T & 'T1,
//│   Cons#T :> 'T2 <: 'T0,
//│   #t: Vec[in 'P out 'P0, in 'T out 'T1],
//│   Cons#L :> 'L0 <: 'L,
//│   #h: anything
//│ } | Nil[in anything out nothing] & {
//│   L <: {P :> 'P <: 'P & 'P0},
//│   T :> 'T <: 'T & 'T1,
//│   #h: anything,
//│   #t: Vec[in 'P out 'P0, in 'T out 'T1]
//│ } | Nil[in anything out nothing] | Nil[in anything out nothing] & ~{Cons#L :> 'L0 & 'L | ??L <: ??L0 & 'L} | Nil[in anything out nothing] & ~{Cons#T :> 'T2 & 'T0 | ??T <: ??T0 & 'T0}) -> Int
//│ fun len: forall 'l 'a. Vec['l, 'a] -> Int

fun map: ('A -> 'B, Vec['L, 'A]) -> Vec['L, 'B]
fun map[B](f, xs) = if xs is
    Nil then new Nil : Vec[xs.L, B]
    Cons(h, t) then Cons(f(h), map(f, t)) : Vec[xs.L, B]
//│ fun map: forall 'A 'L 'T 'B 'L0 'L1 'L2 'L3 'L4 'L5 'a 'T0 'T1 'T2 'L6. (('A | 'a) -> 'B, Cons[in 'L6 out 'L3, in 'T1 out 'T0] & {Cons#L :> 'L3 <: 'L6, Cons#T :> 'T0 <: 'T1} & ~#Cons | Cons[in 'L6 out 'L3, in 'T1 out 'T0] & {Cons#L :> 'L3 <: 'L6, Cons#T :> 'T0 <: 'T1} & ~{Nil#T :> 'T & 'T2 | ??T <: ??T0 & 'T2} & ~#Cons | Cons[in 'L6 out 'L3, in 'T1 out 'T0] & {Cons#L :> 'L3 <: 'L6, Cons#T :> 'T0 <: 'T1} & ~{Cons#L :> 'L3 & 'L6 | ??L <: ??L0 & 'L6} | Cons[in 'L6 out 'L3, in 'T1 out 'T0] & {Cons#L :> 'L3 <: 'L6, Cons#T :> 'T0 <: 'T1} & ~{Cons#T :> 'T0 & 'T1 | ??T1 <: ??T2 & 'T1} | Cons[in 'L6 out 'L3, in 'T1 out 'T0] & {
//│   L :> S[in 'L4 out 'L4 | 'L1] | Z | 'L <: nothing,
//│   Cons#T :> 'T0 <: 'T1,
//│   #t: Vec[in 'L5 out 'L5 | 'L4 | 'L2, 'A],
//│   Cons#L :> 'L3 <: 'L6,
//│   #h: 'a
//│ } | Cons[in 'L6 out 'L3, in 'T1 out 'T0] & {
//│   L :> S[in 'L4 out 'L4 | 'L1] | 'L <: S[in 'L1 & 'L2 out 'L4 | 'L2 | 'L5] & 'L0,
//│   Cons#T :> 'T0 <: 'T1,
//│   #t: Vec[in 'L5 out 'L5 | 'L4 | 'L2, 'A],
//│   Cons#L :> 'L3 <: 'L6,
//│   #h: 'a
//│ } | Cons[in 'L6 out 'L3, in 'T1 out 'T0] & {
//│   L :> S[in 'L4 out 'L4 | 'L1] | 'L <: S[in 'L1 & 'L2 out 'L4 | 'L2 | 'L5] & 'L0,
//│   Cons#T :> 'T0 <: 'T1,
//│   #t: Vec[in 'L5 out 'L5 | 'L4 | 'L2, 'A],
//│   Cons#L :> 'L3 <: 'L6,
//│   #h: 'a
//│ } & ~{Nil#T :> 'T & 'T2 | ??T <: ??T0 & 'T2} | Nil[in 'T2 out 'T] & {
//│   #h: 'a,
//│   Nil#T :> 'T <: 'T2,
//│   L :> S[in 'L4 out 'L4 | 'L1] | Z | 'L <: nothing,
//│   #t: Vec[in 'L5 out 'L5 | 'L4 | 'L2, 'A]
//│ } | Nil[in 'T2 out 'T] & {Nil#T :> 'T <: 'T2, L :> Z | 'L <: Z & 'L0} | Nil[in 'T2 out 'T] & {Nil#T :> 'T <: 'T2, L :> Z | 'L <: Z & 'L0} & ~{Cons#L :> 'L3 & 'L6 | ??L <: ??L0 & 'L6} | Nil[in 'T2 out 'T] & {Nil#T :> 'T <: 'T2, L :> Z | 'L <: Z & 'L0} & ~{Cons#T :> 'T0 & 'T1 | ??T1 <: ??T2 & 'T1} | Nil[in 'T2 out 'T] & {Nil#T :> 'T <: 'T2} & ~#Nil | Nil[in 'T2 out 'T] & {Nil#T :> 'T <: 'T2} & ~{Cons#L :> 'L3 & 'L6 | ??L <: ??L0 & 'L6} & ~#Nil | Nil[in 'T2 out 'T] & {Nil#T :> 'T <: 'T2} & ~{Cons#T :> 'T0 & 'T1 | ??T1 <: ??T2 & 'T1} & ~#Nil | Nil[in 'T2 out 'T] & {Nil#T :> 'T <: 'T2} & ~{Nil#T :> 'T & 'T2 | ??T <: ??T0 & 'T2}) -> Vec[in 'L out 'L0, 'B]
//│ fun map: forall 'L7 'A0 'B0. ('A0 -> 'B0, Vec['L7, 'A0]) -> Vec['L7, 'B0]
//│ where
//│   'L5 <: 'L1

fun zip: (Vec['L, 'A], Vec['L, 'B]) -> Vec['L, ['A, 'B]]
fun zip[A, B](xs, ys) = 
    if xs is Nil and ys is Nil then new Nil : Vec[xs.L, [A, B]]
    else if xs is Cons(x, tx) and ys is Cons(y, ty) then 
        Cons([x, y], zip(tx, ty)) : Vec[xs.L, [A, B]]
    else error
//│ fun zip: forall 'T 'L 'L0 'A 'L1 'L2 'T0 'L3 'T1 'T2 'L4 'L5 'L6 'B 'L7 'L8 'L9. (Cons[in 'L out 'L1, in 'T1 out 'T2] & {Cons#L :> 'L1 <: 'L, Cons#T :> 'T2 <: 'T1} & ~#Cons | Cons[in 'L out 'L1, in 'T1 out 'T2] & {Cons#L :> 'L1 <: 'L, Cons#T :> 'T2 <: 'T1} & ~{Nil#T :> 'T0 & 'T | ??T <: ??T0 & 'T} & ~#Cons | Cons[in 'L out 'L1, in 'T1 out 'T2] & {Cons#L :> 'L1 <: 'L, Cons#T :> 'T2 <: 'T1} & ~{Cons#L :> 'L1 & 'L | ??L <: ??L0 & 'L} | Cons[in 'L out 'L1, in 'T1 out 'T2] & {Cons#L :> 'L1 <: 'L, Cons#T :> 'T2 <: 'T1} & ~{Cons#T :> 'T2 & 'T1 | ??T1 <: ??T2 & 'T1} | Cons[in 'L out 'L1, in 'T1 out 'T2] & {
//│   L :> S[in 'L6 out 'L6 | 'L4] | Z | 'L3 <: nothing,
//│   Cons#T :> 'T2 <: 'T1,
//│   #t: Vec[in 'L4 & 'L0 & 'L7 & 'L2 out 'L7 | 'L6 | 'L9, 'A],
//│   Cons#L :> 'L1 <: 'L,
//│   #h: 'A
//│ } | Cons[in 'L out 'L1, in 'T1 out 'T2] & {
//│   L :> S[in 'L6 out 'L6 | 'L4] | 'L3 <: S[in 'L4 & 'L9 out 'L6 | 'L9 | 'L0] & 'L8,
//│   Cons#T :> 'T2 <: 'T1,
//│   #t: Vec[in 'L4 & 'L0 & 'L7 & 'L2 out 'L7 | 'L6 | 'L9, 'A],
//│   Cons#L :> 'L1 <: 'L,
//│   #h: 'A
//│ } | Cons[in 'L out 'L1, in 'T1 out 'T2] & {
//│   L :> S[in 'L6 out 'L6 | 'L4] | 'L3 <: S[in 'L4 & 'L9 out 'L6 | 'L9 | 'L0] & 'L8,
//│   Cons#T :> 'T2 <: 'T1,
//│   #t: Vec[in 'L4 & 'L0 & 'L7 & 'L2 out 'L7 | 'L6 | 'L9, 'A],
//│   Cons#L :> 'L1 <: 'L,
//│   #h: 'A
//│ } & ~{Nil#T :> 'T0 & 'T | ??T <: ??T0 & 'T} | Nil[in 'T out 'T0] & {
//│   #h: 'A,
//│   Nil#T :> 'T0 <: 'T,
//│   L :> S[in 'L6 out 'L6 | 'L4] | Z | 'L3 <: nothing,
//│   #t: Vec[in 'L4 & 'L0 & 'L7 & 'L2 out 'L7 | 'L6 | 'L9, 'A]
//│ } | Nil[in 'T out 'T0] & {Nil#T :> 'T0 <: 'T, L :> Z | 'L3 <: Z & 'L8} | Nil[in 'T out 'T0] & {Nil#T :> 'T0 <: 'T, L :> Z | 'L3 <: Z & 'L8} & ~{Cons#L :> 'L1 & 'L | ??L <: ??L0 & 'L} | Nil[in 'T out 'T0] & {Nil#T :> 'T0 <: 'T, L :> Z | 'L3 <: Z & 'L8} & ~{Cons#T :> 'T2 & 'T1 | ??T1 <: ??T2 & 'T1} | Nil[in 'T out 'T0] & {Nil#T :> 'T0 <: 'T} & ~#Nil | Nil[in 'T out 'T0] & {Nil#T :> 'T0 <: 'T} & ~{Cons#L :> 'L1 & 'L | ??L <: ??L0 & 'L} & ~#Nil | Nil[in 'T out 'T0] & {Nil#T :> 'T0 <: 'T} & ~{Cons#T :> 'T2 & 'T1 | ??T1 <: ??T2 & 'T1} & ~#Nil | Nil[in 'T out 'T0] & {Nil#T :> 'T0 <: 'T} & ~{Nil#T :> 'T0 & 'T | ??T <: ??T0 & 'T} | Object & ~#Cons & ~#Nil | Object & ~{Cons#L :> 'L1 & 'L | ??L <: ??L0 & 'L} & ~#Cons & ~#Nil | Object & ~{Cons#T :> 'T2 & 'T1 | ??T1 <: ??T2 & 'T1} & ~#Cons & ~#Nil | Object & ~{Nil#T :> 'T0 & 'T | ??T <: ??T0 & 'T} & ~#Cons & ~#Nil, Cons[in anything out nothing, in anything out nothing] & {#h: 'B, #t: Vec[in 'L4 & 'L0 & 'L7 & 'L5 out 'L2 | 'L5 | 'L6 | 'L9, 'B]} | Cons[in anything out nothing, in anything out nothing] & ~#Cons | Cons[in anything out nothing, in anything out nothing] & ~{Cons#L :> anything <: nothing} | Cons[in anything out nothing, in anything out nothing] & ~{Cons#T :> anything <: nothing} | Nil[in anything out nothing] | Object & ~#Cons & ~#Nil | Object & ~{Cons#L :> anything <: nothing} & ~#Cons & ~#Nil | Object & ~{Cons#T :> anything <: nothing} & ~#Cons & ~#Nil) -> Vec[in 'L3 out 'L8, ['A, 'B]]
//│ fun zip: forall 'L10 'A0 'B0. (Vec['L10, 'A0], Vec['L10, 'B0]) -> Vec['L10, ['A0, 'B0]]

fun sum: Vec['l, Int] -> Int
fun sum(xs) = if xs is
    Nil then 0
    Cons(h, t) then h + sum(t)
//│ fun sum: forall 'L 'T 'L0 'T0 'l. (Cons[in 'L0 out 'L, in 'T out 'T0] & {#h: Int, Cons#L :> 'L <: 'L0, Cons#T :> 'T0 <: 'T, #t: Vec['l, Int]} | Cons[in 'L0 out 'L, in 'T out 'T0] & {Cons#L :> 'L <: 'L0, Cons#T :> 'T0 <: 'T} & ~#Cons | Cons[in 'L0 out 'L, in 'T out 'T0] & {Cons#L :> 'L <: 'L0, Cons#T :> 'T0 <: 'T} & ~{Cons#L :> 'L & 'L0 | ??L <: ??L0 & 'L0} | Cons[in 'L0 out 'L, in 'T out 'T0] & {Cons#L :> 'L <: 'L0, Cons#T :> 'T0 <: 'T} & ~{Cons#T :> 'T0 & 'T | ??T <: ??T0 & 'T} | Nil[in anything out nothing] & {#h: Int, #t: Vec['l, Int]} | Nil[in anything out nothing] | Nil[in anything out nothing] & ~{Cons#L :> 'L & 'L0 | ??L <: ??L0 & 'L0} | Nil[in anything out nothing] & ~{Cons#T :> 'T0 & 'T | ??T <: ??T0 & 'T}) -> Int
//│ fun sum: forall 'l0. Vec['l0, Int] -> Int

// construct lisp style list lol
// fun toList: (Vec['l, 'a]) -> (['a, 'xs] as 'xs)
fun toList: (((Vec['l, 'a]) -> 'xs) where ['a, 'xs] | [] : 'xs)
fun toList(xs) = if xs is
    Nil then []
    Cons(h, t) then [h, toList(t)]
//│ fun toList: forall 'L 'l 'L0 'a 'T '#h 'T0. (Cons[in 'L out 'L0, in 'T out 'T0] & {#h: '#h, Cons#L :> 'L0 <: 'L, Cons#T :> 'T0 <: 'T, #t: Vec['l, 'a]} | Cons[in 'L out 'L0, in 'T out 'T0] & {Cons#L :> 'L0 <: 'L, Cons#T :> 'T0 <: 'T} & ~#Cons | Cons[in 'L out 'L0, in 'T out 'T0] & {Cons#L :> 'L0 <: 'L, Cons#T :> 'T0 <: 'T} & ~{Cons#L :> 'L0 & 'L | ??L <: ??L0 & 'L} | Cons[in 'L out 'L0, in 'T out 'T0] & {Cons#L :> 'L0 <: 'L, Cons#T :> 'T0 <: 'T} & ~{Cons#T :> 'T0 & 'T | ??T <: ??T0 & 'T} | Nil[in anything out nothing] & {#h: '#h, #t: Vec['l, 'a]} | Nil[in anything out nothing] | Nil[in anything out nothing] & ~{Cons#L :> 'L0 & 'L | ??L <: ??L0 & 'L} | Nil[in anything out nothing] & ~{Cons#T :> 'T0 & 'T | ??T <: ??T0 & 'T}) -> Array[forall 'xs. '#h | 'xs]
//│ fun toList: forall 'l0 'a0 'xs0. Vec['l0, 'a0] -> 'xs0
//│ where
//│   'xs0 :> Array['a0 | 'xs0]
//│   'xs :> Array['a | 'xs]

:e
head(new Nil)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.139: 	head(new Nil)
//│ ║         	^^^^^^^^^^^^^
//│ ╟── type `Z` is not an instance of `S['l]`
//│ ║  l.18: 	class Nil[T] extends Vec[Z, T]
//│ ║        	                         ^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.28: 	fun head[T](xs: Vec[S['l], T]): T =
//│ ╙──      	                    ^^^^^
//│ error
//│ res
//│ Runtime error:
//│   Error: an error was thrown

:e
tail(new Nil)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.155: 	tail(new Nil)
//│ ║         	^^^^^^^^^^^^^
//│ ╟── type `Z` is not an instance of `S[?L]`
//│ ║  l.18: 	class Nil[T] extends Vec[Z, T]
//│ ║        	                         ^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.32: 	fun tail[L, T](xs: Vec[S[L], T]): Vec[L, T] =
//│ ╙──      	                       ^^^^
//│ Vec['L, 'T] | error
//│ res
//│ Runtime error:
//│   Error: an error was thrown

head(Cons(1, Cons(2, new Nil)))
//│ 1 | 2
//│ res
//│     = 1

tail(Cons(1, Cons(2, new Nil)))
//│ Vec[S[Z], 'T]
//│   where
//│     'T :> 1 | 2
//│ res
//│     = Cons {}

len(new Nil)
//│ Int
//│ res
//│     = 0

len(Cons(1, Cons(2, new Nil)))
//│ Int
//│ res
//│     = 2

:e
zip(Cons(1, new Nil), new Nil)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.193: 	zip(Cons(1, new Nil), new Nil)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Z` is not an instance of `S[?L]`
//│ ║  l.18: 	class Nil[T] extends Vec[Z, T]
//│ ║        	                         ^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.19: 	class Cons[L, T](val h: T, val t: Vec[L, T]) extends Vec[S[L], T]
//│ ║        	                                                         ^^^^
//│ ╟── from type variable:
//│ ║  l.87: 	fun zip: (Vec['L, 'A], Vec['L, 'B]) -> Vec['L, ['A, 'B]]
//│ ╙──      	                           ^^
//│ Vec[out S[Z] | Z, ['A, 'B]] | error
//│   where
//│     'A :> 1
//│ res
//│ Runtime error:
//│   Error: an error was thrown

zip(Cons(1, new Nil), Cons(2, new Nil))
//│ Vec[S[Z], ['A, 'B]]
//│   where
//│     'B :> 2
//│     'A :> 1
//│ res
//│     = Cons {}

let vec1 = Cons(1, Cons(2, Cons(3, new Nil)))
//│ let vec1: Cons[S[S[Z]], 'T]
//│   where
//│     'T :> 1 | 2 | 3
//│ vec1
//│      = Cons {}

vec1 : Vec['l, Int]
//│ Vec[S[S[S[Z]]], Int]
//│ res
//│     = Cons {}

:e
vec1 : Vec[Z, Int]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.234: 	vec1 : Vec[Z, Int]
//│ ║         	^^^^
//│ ╟── type `S[?L]` is not an instance of `Z`
//│ ║  l.19: 	class Cons[L, T](val h: T, val t: Vec[L, T]) extends Vec[S[L], T]
//│ ║        	                                                         ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.234: 	vec1 : Vec[Z, Int]
//│ ╙──       	           ^
//│ Vec[Z, Int]
//│ res
//│     = Cons {}

map(x => x * 2, vec1)
//│ Vec[S[S[S[Z]]], 'B]
//│   where
//│     'B :> Int
//│ res
//│     = Cons {}

sum(vec1)
//│ Int
//│ res
//│     = 6

toList(vec1)
//│ forall 'xs. 'xs
//│   where
//│     'xs :> Array[Int | 'xs]
//│ res
//│     = [ 1, [ 2, [ 3, [] ] ] ]
