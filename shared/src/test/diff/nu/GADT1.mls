:NewDefs
:GADTs

// natural numbers  for index //

class Z
class S[type P]
//│ class Z {
//│   constructor()
//│ }
//│ class S[P] {
//│   constructor()
//│ }

// sized list //

abstract class Vec[type L, type T]: Nil[T] | Cons[L, T]
class Nil[T] extends Vec[Z, T]
class Cons[L, T](val h: T, val t: Vec[L, T]) extends Vec[S[L], T]
//│ abstract class Vec[L, T]: Cons[L, T] | Nil[T]
//│ class Nil[T] extends Vec {
//│   constructor()
//│ }
//│ class Cons[L, T](h: T, t: Vec[L, T]) extends Vec

// functions //

fun head[T](xs: Vec[S['l], T]): T =
    if xs is Cons(h, t) then h : xs.T else error
//│ fun head: forall 'l 'T. (xs: Vec[S['l], 'T]) -> 'T

fun tail[L, T](xs: Vec[S[L], T]): Vec[L, T] =
    if xs is Cons(h, t) then t : Vec[xs.L.P, xs.T] else error
//│ fun tail: forall 'L 'T. (xs: Vec[S['L], 'T]) -> Vec['L, 'T]

fun len[L](xs: Vec[L, 'a]): Int = if xs is
    Nil then 0
    Cons(h, t) then 1 + len(t : Vec[xs.L.P, xs.T])
//│ fun len: forall 'L 'a. (xs: Vec['L, 'a]) -> Int

fun map[L, A, B](f: A -> B, xs: Vec[L, A]): Vec[L, B] = if xs is
    Nil then new Nil : Vec[xs.L, B]
    Cons(h, t) then Cons(f(h), map(f, t)) : Vec[xs.L, B]
//│ fun map: forall 'A 'B 'L. (f: 'A -> 'B, xs: Vec['L, 'A]) -> Vec['L, 'B]

fun zip[L, A, B](xs: Vec[L, A], ys: Vec[L, B]): Vec[L, [A, B]] = 
    if xs is Nil and ys is Nil then new Nil : Vec[xs.L, [A, B]]
    else if xs is Cons(x, tx) and ys is Cons(y, ty) then 
        Cons([x, y], zip(tx, ty)) : Vec[xs.L, [A, B]]
    else error
//│ fun zip: forall 'B 'L 'A. (xs: Vec['L, 'A], ys: Vec['L, 'B]) -> Vec['L, ['A, 'B]]

:e
head(new Nil)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.54: 	head(new Nil)
//│ ║        	^^^^^^^^^^^^^
//│ ╟── type `Z` is not an instance of `S['l]`
//│ ║  l.18: 	class Nil[T] extends Vec[Z, T]
//│ ║        	                         ^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.28: 	fun head[T](xs: Vec[S['l], T]): T =
//│ ╙──      	                    ^^^^^
//│ error
//│ res
//│ Runtime error:
//│   Error: an error was thrown

:e
tail(new Nil)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.70: 	tail(new Nil)
//│ ║        	^^^^^^^^^^^^^
//│ ╟── type `Z` is not an instance of `S[?L]`
//│ ║  l.18: 	class Nil[T] extends Vec[Z, T]
//│ ║        	                         ^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.32: 	fun tail[L, T](xs: Vec[S[L], T]): Vec[L, T] =
//│ ╙──      	                       ^^^^
//│ Vec['L, 'T] | error
//│ res
//│ Runtime error:
//│   Error: an error was thrown

head(Cons(1, Cons(2, new Nil)))
//│ 1 | 2
//│ res
//│     = 1

tail(Cons(1, Cons(2, new Nil)))
//│ Vec[S[Z], 'T]
//│   where
//│     'T :> 1 | 2
//│ res
//│     = Cons {}

len(new Nil)
//│ Int
//│ res
//│     = 0

len(Cons(1, Cons(2, new Nil)))
//│ Int
//│ res
//│     = 2

:e
zip(Cons(1, new Nil), new Nil)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.108: 	zip(Cons(1, new Nil), new Nil)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Z` is not an instance of `S[?L]`
//│ ║  l.18: 	class Nil[T] extends Vec[Z, T]
//│ ║        	                         ^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.19: 	class Cons[L, T](val h: T, val t: Vec[L, T]) extends Vec[S[L], T]
//│ ║        	                                                         ^^^^
//│ ╟── Note: method type parameter L is defined at:
//│ ║  l.46: 	fun zip[L, A, B](xs: Vec[L, A], ys: Vec[L, B]): Vec[L, [A, B]] = 
//│ ╙──      	        ^
//│ Vec[out S[Z] | Z, ['A, 'B]] | error
//│   where
//│     'A :> 1
//│ res
//│ Runtime error:
//│   Error: an error was thrown

zip(Cons(1, new Nil), Cons(2, new Nil))
//│ Vec[S[Z], ['A, 'B]]
//│   where
//│     'B :> 2
//│     'A :> 1
//│ res
//│     = Cons {}

map(x => x * 2, Cons(1, Cons(2, Cons(3, new Nil))))
//│ Vec[S[S[S[Z]]], 'B]
//│   where
//│     'B :> Int
//│ res
//│     = Cons {}
