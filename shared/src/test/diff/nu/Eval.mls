:NewDefs



// * Standard definitions:


declare fun String: anything -> Str
//│ fun String: anything -> Str

fun (++) stringConcat(a, b) = concat(a)(b)
//│ fun (++) stringConcat: (Str, Str) -> Str

fun (|>) pipe(x, f) = f(x)
fun (<|) pepi(f, x) = f(x)
//│ fun (|>) pipe: forall 'a 'b. ('a, 'a -> 'b) -> 'b
//│ fun (<|) pepi: forall 'c 'd. ('c -> 'd, 'c) -> 'd


// * Hack to throw exceptions
declare class throw(arg: anything): nothing
//│ declare class throw(arg: anything): nothing

:w // * Due to current limitations of self types
:re
throw(1); 0
//│ ╔══[WARNING] Expression in statement position should have type `unit`.
//│ ╟── Use the `discard` function to discard non-unit values, making the intent clearer.
//│ ╟── Type mismatch in application:
//│ ║  l.26: 	throw(1); 0
//│ ║        	^^^^^^^^
//│ ╙── application of type `throw` does not match type `()`
//│ 0
//│ res
//│ Runtime error:
//│   1

:w
fun test = throw(1); 0
//│ ╔══[WARNING] Expression in statement position should have type `unit`.
//│ ╟── Use the `discard` function to discard non-unit values, making the intent clearer.
//│ ╟── Type mismatch in application:
//│ ║  l.39: 	fun test = throw(1); 0
//│ ║        	           ^^^^^^^^
//│ ╙── application of type `throw` does not match type `()`
//│ fun test: 0

:re
test
//│ 0
//│ res
//│ Runtime error:
//│   1

:w
fun test =
  throw(1)
  error
//│ ╔══[WARNING] Expression in statement position should have type `unit`.
//│ ╟── Use the `discard` function to discard non-unit values, making the intent clearer.
//│ ╟── Type mismatch in application:
//│ ║  l.57: 	  throw(1)
//│ ║        	  ^^^^^^^^
//│ ╙── application of type `throw` does not match type `()`
//│ fun test: nothing

:re
test
//│ nothing
//│ res
//│ Runtime error:
//│   1


abstract class Option[out A]
class Some[out A](val value: A) extends Option[A]
module None extends Option[nothing]
//│ abstract class Option[A]
//│ class Some[A](value: A) extends Option
//│ module None extends Option

abstract class List[out A]: Cons[A] | Nil { virtual val length: Int }
class Cons[out A](val head: A, val tail: List[A]) extends List[A] {
  val length: Int
  val length = tail.length + 1
  fun toString() = "Cons(" ++ String(head) ++ ", " ++ String(tail) ++ ")"
}
module Nil extends List[nothing] {
  val length = 0
  fun toString() = "Nil"
}
//│ abstract class List[A]: Cons[A] | Nil {
//│   val length: Int
//│ }
//│ class Cons[A](head: A, tail: List[A]) extends List {
//│   val length: Int
//│   fun toString: () -> Str
//│ }
//│ module Nil extends List {
//│   val length: 0
//│   fun toString: () -> "Nil"
//│ }

fun (::) cons(x, xs) = Cons(x, xs)
fun (:::) concatList(xs, ys) = if xs is
  Nil then ys
  Cons(x, xs) then x :: xs ::: ys
//│ fun (::) cons: forall 'A. ('A, List['A]) -> Cons['A]
//│ fun (:::) concatList: forall 'A0 'A1 'a. (Cons['A0] | Nil, List['A1] & 'a) -> (Cons['A1 | ??A & 'A0] | 'a)

module Lists { // TODO use name List when module overloading is supported:
  
  fun map(f) = case
    Nil then Nil
    Cons(x, xs) then f(x) :: map(f)(xs)
  
  fun zip(xs, ys) = if xs is
    Nil then Nil
    Cons(x, xs) then if ys is
      Nil then Nil
      Cons(y, ys) then
        [x, y] :: zip(xs, ys)
  
  fun assoc(e) = case
    Cons(kv, rest) then
      if kv.key === e then Some(kv.value)
      else assoc(e)(rest)
    Nil then None
  
}
//│ module Lists {
//│   fun assoc: forall 'a 'A. 'a -> (Cons[{key: Eql['a], value: 'A} | ~??A] | Nil) -> (None | Some['A])
//│   fun map: forall 'A0 'A1. ((??A0 & 'A0) -> 'A1) -> (Cons['A0] | Nil) -> (Cons['A1] | Nil)
//│   fun zip: forall 'A2 'A3. (Cons['A2] | Nil, Cons['A3] | Nil) -> (Cons[[??A1 & 'A2, ??A2 & 'A3]] | Nil)
//│ }

let xs = 1 :: 2 :: 3 :: Nil
//│ let xs: Cons[1 | 2 | 3]
//│ xs
//│    = Cons {}

String of xs ::: 4 :: 5 :: Nil
//│ Str
//│ res
//│     = 'Cons(1, Cons(2, Cons(3, Cons(4, Cons(5, Nil)))))'


let ls = {key: "a", value: 0} :: Nil
//│ let ls: Cons[{key: "a", value: 0}]
//│ ls
//│    = Cons {}

ls |> Lists.assoc("a")
//│ None | Some[0]
//│ res
//│     = Some {}



// * Our little language:


abstract class Term: Var | App | Lam | Sel | Rcd[Term]
class Var(val name: Str) extends Term
class App(val lhs: Term, val args: List[Term]) extends Term
class Lam(val params: List[Str], val body: Term) extends Term
class Rcd[out Sub](val fields: List[{key: Str, value: Sub}]) extends Term
class Sel(val prefix: Term, val fieldName: Str) extends Term
abstract class Lit[out A](val value: A): IntLit | StrLit extends Term
class IntLit(v: Int) extends Lit[Int](v)
class StrLit(v: Str) extends Lit[Str](v)
//│ abstract class Term: App | Lam | Rcd[Term] | Sel | Var
//│ class Var(name: Str) extends Term
//│ class App(lhs: Term, args: List[Term]) extends Term
//│ class Lam(params: List[Str], body: Term) extends Term
//│ class Rcd[Sub](fields: List[{key: Str, value: Sub}]) extends Term
//│ class Sel(prefix: Term, fieldName: Str) extends Term
//│ abstract class Lit[A](value: A): IntLit | StrLit extends Term
//│ class IntLit(v: Int) extends Lit, Term
//│ class StrLit(v: Str) extends Lit, Term

type Value = Lam | Lit | Rcd[Value]
//│ type Value = Lam | Lit[anything] | Rcd[Value]


:w
fun err(msg) =
  throw(concat("Evaluation error: " ++ msg))
  error
//│ ╔══[WARNING] Expression in statement position should have type `unit`.
//│ ╟── Use the `discard` function to discard non-unit values, making the intent clearer.
//│ ╟── Type mismatch in application:
//│ ║  l.188: 	  throw(concat("Evaluation error: " ++ msg))
//│ ║         	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── application of type `throw` does not match type `()`
//│ fun err: Str -> nothing

// :d // FIXME with this it passes!!?
:e // FIXME recursion depth
fun eval(t, env) = if t is
  Var(nme) then if env |> Lists.assoc(nme) is Some(v)
    then v
    else err("variable not found: " ++ nme)
  Lit then t
  Lam then t
  App(f, args) then
    let fe = eval(f, env)
    if fe is Lam(ps, bod) then
      val argse = args |> Lists.map(a => eval(a, env))
      if ps.length === argse.length then () else err("wrong number of arguments")
      let envp = Lists.zip(ps, argse) |> Lists.map of ([key, value]) => {key, value}
      eval(bod, envp ::: env)
    else err(String(fe) ++ " cannot be applied")
  Sel(pre, nme) then
    let pree = eval(pre, env)
    if pree is Rcd(xs) and xs |> Lists.assoc(nme) is Some(v) then v
    else err(String(pree) ++ " does not have field " ++ nme)
  Rcd(fs) then
    Rcd of fs |> Lists.map of {key, value} => {key, value: eval(value, env)}
//│ ╔══[ERROR] Subtyping constraint of the form `(?a, ?b) -> (?c | ?d | ?e | ?f | ?g | ?h) <: ?eval` exceeded recursion depth limit (250)
//│ ║  l.200: 	fun eval(t, env) = if t is
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.201: 	  Var(nme) then if env |> Lists.assoc(nme) is Some(v)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.202: 	    then v
//│ ║         	^^^^^^^^^^
//│ ║  l.203: 	    else err("variable not found: " ++ nme)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.204: 	  Lit then t
//│ ║         	^^^^^^^^^^^^
//│ ║  l.205: 	  Lam then t
//│ ║         	^^^^^^^^^^^^
//│ ║  l.206: 	  App(f, args) then
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ║  l.207: 	    let fe = eval(f, env)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.208: 	    if fe is Lam(ps, bod) then
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.209: 	      val argse = args |> Lists.map(a => eval(a, env))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.210: 	      if ps.length === argse.length then () else err("wrong number of arguments")
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.211: 	      let envp = Lists.zip(ps, argse) |> Lists.map of ([key, value]) => {key, value}
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.212: 	      eval(bod, envp ::: env)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.213: 	    else err(String(fe) ++ " cannot be applied")
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.214: 	  Sel(pre, nme) then
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.215: 	    let pree = eval(pre, env)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.216: 	    if pree is Rcd(xs) and xs |> Lists.assoc(nme) is Some(v) then v
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.217: 	    else err(String(pree) ++ " does not have field " ++ nme)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.218: 	  Rcd(fs) then
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.219: 	    Rcd of fs |> Lists.map of {key, value} => {key, value: eval(value, env)}
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ fun eval: forall 'a 'A 'Sub 'A0 'Sub0. (App | Lam | Lit['A0] | Rcd['Sub] | Sel | Var, Cons[{key: Eql[Str], value: 'A} | ~??A] & {List#A <: {key: Eql[Str], value: 'A} | ~??A} & List[{key: Eql[Str], value: 'A} | ~??A] | Nil & {List#A <: {key: Eql[Str], value: 'A} | ~??A} & List[{key: Eql[Str], value: 'A} | ~??A]) -> 'a
//│   where
//│     'A :> ??A0 & 'a
//│        <: Object & ~#Rcd | Rcd['Sub0] | ~??A1
//│     'a :> Lam | Lit[??A2 & 'A0] | Rcd['a] | ??A1 & 'A | ??Sub & ??A3 & 'Sub0
//│     'Sub0 :> 'a
//│           <: Object & ~#Rcd | Rcd['Sub0] | ~(??Sub & ??A3)
//│     'Sub <: App | Lam | Lit['A0] | Rcd['Sub] | Sel | Var | ~??Sub0

:e // FIXME recursion depth
eval : (Term, List[{key: Str, value: Value}]) -> Value
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?a ?b ?c ?d ?e ?f ?g ?h. (?c, ?g) -> (?e | ?f | ?h | ?b | ?d | ?a) <: (Term, List[{key: Str, value: Value}]) -> Value` exceeded recursion depth limit (250)
//│ ║  l.272: 	eval : (Term, List[{key: Str, value: Value}]) -> Value
//│ ║         	^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ (Term, List[{key: Str, value: Value}]) -> Value
//│ res
//│     = [Function: eval]

let rcd = Rcd({key: "a", value: IntLit(0)} :: Nil)
//│ let rcd: Rcd[IntLit]
//│ rcd
//│     = Rcd {}

eval of rcd, Nil
//│ 'a
//│   where
//│     'a :> Lam | Lit[Int & ??A] | Rcd['a]
//│ res
//│     = Rcd {}

eval of Sel(rcd, "a"), Nil
//│ 'a
//│   where
//│     'a :> Lam | Lit[nothing] | Rcd['a]
//│ res
//│     = IntLit {}

eval of App(Lam("x" :: Nil, Sel(Var("x"), "a")), rcd :: Nil), Nil
//│ 'a
//│   where
//│     'a :> Lam | Lit[nothing] | Rcd['a]
//│ res
//│     = IntLit {}


