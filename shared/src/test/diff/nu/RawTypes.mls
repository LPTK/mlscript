:NewDefs

// * currently
// Foo => Foo[?] ? is rigid can be uncovered in pattern matching
// * future
// Foo => Foo['a] can place bounds on 'a

class Foo[type A](val a: A)
//│ class Foo[A](a: A)


// FIXME
fun foo(f: Foo) = f.a
//│ fun foo: (f: Foo[anything]) -> ??A

fun foo(f: Foo[Int]) = f.a
//│ fun foo: (f: Foo[Int]) -> Int

// FIXME
fun foo(f: Foo): Int = if f is Foo(a) then a : f.A
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.20: 	fun foo(f: Foo): Int = if f is Foo(a) then a : f.A
//│ ║        	                          ^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.8: 	class Foo[type A](val a: A)
//│ ║       	                      ^
//│ ╟── into type `Int | ~??A`
//│ ║  l.20: 	fun foo(f: Foo): Int = if f is Foo(a) then a : f.A
//│ ╙──      	                 ^^^
//│ fun foo: (f: Foo[anything]) -> Int

fun foo(f: Foo['a]): Int = if f is Foo(a) then a : f.A
//│ fun foo: forall 'a. (f: Foo['a]) -> Int
//│   where
//│     'a <: Int | ~??A

fun foo(f: Foo['a]) = f.a : f.A
//│ fun foo: forall 'a. (f: Foo['a]) -> 'a

fun foo(a, f: Foo[a]): Int = f.a : f.A
//│ fun foo: forall 'a. ('a, f: Foo['a]) -> Int
//│   where
//│     'a <: Int

fun bar(f): Int = f.a : f.A
//│ fun bar: {A <: Int, a: Int} -> Int

foo(2, Foo(1))
//│ Int
//│ res
//│     = 1

bar(Foo(1))
//│ Int
//│ res
//│     = 1

class Foo[A](val a: A -> A)
//│ class Foo[A](a: A -> A)

fun foo(f: Foo) = f.a
//│ fun foo: (f: Foo[in anything out nothing]) -> ??A -> ??A0


fun foo(f) = f : Foo
//│ fun foo: Foo[in anything out nothing] -> Foo[?]

abstract class Foo[type T]: Bar
class Bar(val b: Int) extends Foo[Int]
//│ abstract class Foo[T]: Bar
//│ class Bar(b: Int) extends Foo

:d
fun foo(x: Foo): x.T = if x is Bar then x.b : x.T
//│ 0. Typing ‹fun foo = (x: Foo,) => if (is(x, Bar,)) then (x).b : x.T : x.T›
//│ | 0. Created lazy type info for fun foo = (x: Foo,) => if (is(x, Bar,)) then (x).b : x.T : x.T
//│ | Completing fun foo = (x: Foo,) => if (is(x, Bar,)) then (x).b : x.T : x.T
//│ | | Type params 
//│ | | Params 
//│ | | 1. Typing term (x: Foo,) => if (is(x, Bar,)) then (x).b : x.T : x.T
//│ | | | 1. Typing pattern [x: Foo,]
//│ | | | | 1. Typing pattern x : Foo
//│ | | | | | Typing type TypeName(Foo)
//│ | | | | | | vars=Map() newDefsInfo=Map()
//│ | | | | | | 1. type TypeName(Foo)
//│ | | | | | | => #Foo<Object>
//│ | | | | | => #Foo<Object> ——— 
//│ | | | | 1. : #Foo<Object>
//│ | | | 1. : (x: #Foo<Object>,)
//│ | | | 1. Typing term if (is(x, Bar,)) then (x).b : x.T : x.T
//│ | | | | 1. Typing term if (is(x, Bar,)) then (x).b : x.T
//│ | | | | | [Desugarer.destructPattern] scrutinee = x; pattern = Bar
//│ | | | | | [Desugarer.destructPattern] Result: «x is Bar»
//│ | | | | | Desugared term: case x of { Bar => (x).b : x.T }
//│ | | | | | 1. Typing term case x of { Bar => (x).b : x.T }
//│ | | | | | | 1. Typing term x
//│ | | | | | | 1. : #Foo<Object>
//│ | | | | | | CONSTRAIN #Foo<Object> <! Object
//│ | | | | | |   where 
//│ | | | | | | 1. C #Foo<Object> <! Object    (0)
//│ | | | | | | | Already a subtype by <:<
//│ | | | | | | Match arm Bar: #Bar<Object,Foo> & ⊤ intl ⊤
//│ | | | | | | 2. Typing term (x).b : x.T
//│ | | | | | | | 2. Typing term (x).b
//│ | | | | | | | | 2. Typing term x
//│ | | | | | | | | 2. : #Bar<Object,Foo>
//│ | | | | | | | | CONSTRAIN #Bar<Object,Foo> <! {b: b160''}
//│ | | | | | | | |   where 
//│ | | | | | | | | 2. C #Bar<Object,Foo> <! {b: b160''}    (0)
//│ | | | | | | | | | Looking up field b in Some(Bar) & TreeSet() & {...}
//│ | | | | | | | | | | Lookup Bar.b : Some(Int) where 
//│ | | | | | | | | | | Fresh[0] Bar.b : Some(Int) where Some()
//│ | | | | | | | | | |   & None  (from refinement)
//│ | | | | | | | | | 2. C Int <! b160''    (1)
//│ | | | | | | | | | | NEW b160'' LB (0)
//│ | | | | | | | 2. : b160''
//│ | | | | | | | Typing type Selection(TypeName(x),TypeName(T))
//│ | | | | | | | | vars=Map() newDefsInfo=Map()
//│ | | | | | | | | 2. type Selection(TypeName(x),TypeName(T))
//│ | | | | | | | | | 2. type TypeName(x)
//│ | | | | | | | | | | ty var: x : #Bar<Object,Foo>
//│ | | | | | | | | | => #Bar<Object,Foo>
//│ | | | | | | | | => T148_152#
//│ | | | | | | | => T148_152# ——— 
//│ | | | | | | | CONSTRAIN b160'' <! T148_152#
//│ | | | | | | |   where 
//│ 		T148_152# := Int
//│ 		b160'' :> Int
//│ | | | | | | | 2. C b160'' <! T148_152#    (0)
//│ | | | | | | | | 2. C b160'' <! Int    (2)
//│ | | | | | | | | | NEW b160'' UB (0)
//│ | | | | | | | | | 2. C Int <! Int    (4)
//│ | | | | | | | | | | Already a subtype by <:<
//│ | | | | | | 2. : T148_152#
//│ | | | | | | CONSTRAIN T148_152# <! α159'
//│ | | | | | |   where 
//│ 		T148_152# := Int
//│ | | | | | | 2. C T148_152# <! α159'    (0)
//│ | | | | | | | 2. C Int <! α159'    (2)
//│ | | | | | | | | NEW α159' LB (0)
//│ | | | | | | CONSTRAIN #Foo<Object> <! #Bar<Object,Foo>
//│ | | | | | |   where 
//│ | | | | | | 1. C #Foo<Object> <! #Bar<Object,Foo>    (0)
//│ | | | | | | | CONSTRAINT FAILURE: #Foo<Object> <: #Bar<Object,Foo>
//│ | | | | | | | allVarPols: 
//│ | | | | | | | normLike[+] #Foo<Object>
//│ | | | | | | | | norm[+] #Foo<Object>
//│ | | | | | | | | | DNF: DNF(0, #Foo<Object>{})
//│ | | | | | | | | | rcd2 {}
//│ | | | | | | | | | typeRef Foo[⊥..⊤]
//│ | | | | | | | | | Assigning T :: T148' := ⊥..⊤ where 
//│ | | | | | | | | | Set T148_161 ~> T148'
//│ | | | | | | | | | clsFields T -> mut ⊥..⊤..⊥..⊤
//│ | | | | | | | | ~> Foo[⊥..⊤]
//│ | | | | | | | CONSTRAIN #error<> <! α159'
//│ | | | | | | |   where 
//│ 		α159' :> Int
//│ | | | | | | | 1. C #error<> <! α159'    (0)
//│ | | | | | | | | NEW α159' LB (0)
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.74: 	fun foo(x: Foo): x.T = if x is Bar then x.b : x.T
//│ ║        	                          ^^^^^^^^^^^^^^^^^
//│ ╟── type `Foo[?]` is not an instance of type `Bar`
//│ ║  l.74: 	fun foo(x: Foo): x.T = if x is Bar then x.b : x.T
//│ ║        	           ^^^
//│ ╟── Note: constraint arises from class pattern:
//│ ║  l.74: 	fun foo(x: Foo): x.T = if x is Bar then x.b : x.T
//│ ╙──      	                               ^^^
//│ | | | | | 1. : α159'
//│ | | | | 1. : α159'
//│ | | | | Typing type Selection(TypeName(x),TypeName(T))
//│ | | | | | vars=Map() newDefsInfo=Map()
//│ | | | | | 1. type Selection(TypeName(x),TypeName(T))
//│ | | | | | | 1. type TypeName(x)
//│ | | | | | | | ty var: x : #Foo<Object>
//│ | | | | | | => #Foo<Object>
//│ | | | | | => ‘T148'
//│ | | | | => ‘T148' ——— 
//│ | | | | CONSTRAIN α159' <! ‘T148'
//│ | | | |   where 
//│ 		α159' :> #error<> | Int
//│ | | | | 1. C α159' <! ‘T148'    (0)
//│ | | | | | NEW α159' UB (1)
//│ | | | | | 1. C #error<> <! ‘T148'    (2)
//│ | | | | | 1. C Int <! ‘T148'    (2)
//│ | | | | | | 1. C #Int<Object,Num> <! ‘T148'    (4)
//│ | | | | | | | CONSTRAINT FAILURE: #Int<Object,Num> <: ‘T148'
//│ | | | | | | | allVarPols: -T148'
//│ | | | | | | | normLike[-] ‘T148'
//│ | | | | | | | | norm[-] ‘T148'
//│ | | | | | | | | | DNF: DNF(1, {}∧‘T148')
//│ | | | | | | | | ~> ‘T148'
//│ | | | | | | | allVarPols: 
//│ | | | | | | | normLike[+] #Int<Object,Num>
//│ | | | | | | | | norm[+] #Int<Object,Num>
//│ | | | | | | | | | DNF: DNF(0, #Int<Object,Num>{})
//│ | | | | | | | | ~> #Int<Object,Num>
//│ | | | | | | | CONSTRAIN #error<> <! ‘T148'
//│ | | | | | | |   where 
//│ | | | | | | | 1. C #error<> <! ‘T148'    (0)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.74: 	fun foo(x: Foo): x.T = if x is Bar then x.b : x.T
//│ ║        	                          ^^^^^^^^^^^^^^^^^
//│ ╟── type `Int` does not match type `T`
//│ ║  l.69: 	class Bar(val b: Int) extends Foo[Int]
//│ ║        	                                  ^^^
//│ ╟── Note: constraint arises from type parameter:
//│ ║  l.68: 	abstract class Foo[type T]: Bar
//│ ╙──      	                        ^
//│ | | | 1. : ‘T148'
//│ | | 1. : ((x: #Foo<Object>,) -> ‘T148')
//│ | | CONSTRAIN ((x: #Foo<Object>,) -> ‘T148') <! foo162'
//│ | |   where 
//│ | | 1. C ((x: #Foo<Object>,) -> ‘T148') <! foo162'    (0)
//│ | | | NEW foo162' LB (1)
//│ | Completed TypedNuFun(0,fun foo = (x: Foo,) => if (is(x, Bar,)) then (x).b : x.T : x.T,((x: #Foo<Object>,) -> ‘T148')) where 
//│ | Typing unit statements
//│ | : None
//│ ======== TYPED ========
//│ fun foo: ‹∀ 0. ((x: #Foo<Object>,) -> ‘T148')› where 
//│ fun foo: (x: Foo[in anything out nothing]) -> nothing
