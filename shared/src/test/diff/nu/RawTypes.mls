:NewDefs

// * currently
// Foo => Foo[?] ? is rigid can be uncovered in pattern matching
// * future
// Foo => Foo['a] can place bounds on 'a

class Foo[type A](val a: A)
//│ class Foo[A](a: A)

fun foo(f: Foo): Int = f.a : f.A
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.11: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                       ^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.11: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                       ^^^
//│ ╟── back into type variable `A`
//│ ║  l.11: 	fun foo(f: Foo): Int = f.a : f.A
//│ ╙──      	                              ^^
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.11: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                       ^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.11: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                              ^^
//│ ╟── into type `Int`
//│ ║  l.11: 	fun foo(f: Foo): Int = f.a : f.A
//│ ╙──      	                 ^^^
//│ fun foo: (f: Foo[anything]) -> Int

fun foo(f: Foo[?]) = f.a : f.A
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.32: 	fun foo(f: Foo[?]) = f.a : f.A
//│ ║        	                     ^^^
//│ ╟── type variable `?` leaks out of its scope
//│ ║  l.32: 	fun foo(f: Foo[?]) = f.a : f.A
//│ ║        	               ^
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this field selection:
//│ ║  l.32: 	fun foo(f: Foo[?]) = f.a : f.A
//│ ║        	                     ^^^
//│ ╟── Note: constraint arises from type selection:
//│ ║  l.32: 	fun foo(f: Foo[?]) = f.a : f.A
//│ ╙──      	                            ^^
//│ fun foo: forall '?. (f: Foo['?]) -> ???

foo(Foo(1))
//│ ???
//│ res
//│     = 1

// FIXME
fun foo(f: Foo) = f.a
//│ fun foo: (f: Foo[anything]) -> ??A

fun foo(f: Foo[Int]) = f.a
//│ fun foo: (f: Foo[Int]) -> Int

// FIXME
fun foo(f: Foo): Int = if f is Foo(a) then a : f.A
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.61: 	fun foo(f: Foo): Int = if f is Foo(a) then a : f.A
//│ ║        	                          ^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.61: 	fun foo(f: Foo): Int = if f is Foo(a) then a : f.A
//│ ║        	                                                ^^
//│ ╟── into type `Int | ~??A`
//│ ║  l.61: 	fun foo(f: Foo): Int = if f is Foo(a) then a : f.A
//│ ╙──      	                 ^^^
//│ fun foo: (f: Foo[anything]) -> Int

fun foo(f: Foo[?]): Int = if f is Foo(a) then a : f.A else 0
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.73: 	fun foo(f: Foo[?]): Int = if f is Foo(a) then a : f.A else 0
//│ ║        	                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `?` leaks out of its scope
//│ ║  l.73: 	fun foo(f: Foo[?]): Int = if f is Foo(a) then a : f.A else 0
//│ ║        	               ^
//│ ╟── into type `Int | ~(?? & ??A)`
//│ ║  l.73: 	fun foo(f: Foo[?]): Int = if f is Foo(a) then a : f.A else 0
//│ ╙──      	                    ^^^
//│ fun foo: forall '?. (f: Foo['?]) -> Int

fun foo(f: Foo['a]) = f.a : f.A
//│ fun foo: forall 'a. (f: Foo['a]) -> 'a

fun foo(a, f: Foo[a]): Int = f.a : f.A
//│ fun foo: forall 'a. ('a, f: Foo['a]) -> Int
//│   where
//│     'a <: Int

fun bar(f): Int = f.a : f.A
//│ fun bar: forall 'A. {A :> 'A <: Int, a: 'A} -> Int

foo(2, Foo(1))
//│ Int
//│ res
//│     = 1

bar(Foo(1))
//│ Int
//│ res
//│     = 1

class Foo[A](val a: A -> A)
//│ class Foo[A](a: A -> A)

fun foo(f: Foo) = f.a
//│ fun foo: (f: Foo[in anything out nothing]) -> ??A -> ??A0


fun foo(f) = f : Foo
//│ fun foo: Foo[in anything out nothing] -> Foo[?]

abstract class Foo[type T]: Bar
class Bar(val b: Int) extends Foo[Int]
//│ abstract class Foo[T]: Bar
//│ class Bar(b: Int) extends Foo

fun foo(x: Foo[?]) = if x is Bar then x.b : x.T
//│ fun foo: forall '?. (x: Foo['?]) -> (Int & ???)

foo(Bar(1))
//│ Int & ???
//│ res
//│     = 1

fun foo(x: Foo['a]) = if x is Bar then x.b : x.T
//│ fun foo: forall 'a. (x: Foo['a]) -> (Int & 'a)

