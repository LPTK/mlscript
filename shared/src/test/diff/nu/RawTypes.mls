:NewDefs

// * currently
// Foo => Foo[?] ? is rigid can be uncovered in pattern matching
// * future
// Foo => Foo['a] can place bounds on 'a

class Foo[type A](val a: A)
//│ class Foo[A](a: A)

:e
fun foo(f: Foo): Int = f.a : f.A
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.12: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                       ^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.12: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                       ^^^
//│ ╟── back into type variable `A`
//│ ║  l.12: 	fun foo(f: Foo): Int = f.a : f.A
//│ ╙──      	                              ^^
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.12: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                       ^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.12: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                              ^^
//│ ╟── into type `Int`
//│ ║  l.12: 	fun foo(f: Foo): Int = f.a : f.A
//│ ╙──      	                 ^^^
//│ fun foo: (f: Foo[anything]) -> Int

// TODO
fun foo(f: Foo[?]) = f.a : f.A
//│ ╔══[ERROR] wildcard type notation currently unsupported
//│ ║  l.34: 	fun foo(f: Foo[?]) = f.a : f.A
//│ ╙──      	               ^
//│ fun foo: forall 'A. (f: Foo['A]) -> 'A

foo(Foo(1))
//│ 1
//│ res
//│     = 1

// FIXME
fun foo(f: Foo) = f.a
//│ fun foo: (f: Foo[anything]) -> ??A

fun foo(f: Foo[Int]) = f.a
//│ fun foo: (f: Foo[Int]) -> Int

// FIXME
fun foo(f: Foo): Int = if f is Foo(a) then a : f.A
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.53: 	fun foo(f: Foo): Int = if f is Foo(a) then a : f.A
//│ ║        	                          ^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.53: 	fun foo(f: Foo): Int = if f is Foo(a) then a : f.A
//│ ║        	                                                ^^
//│ ╟── into type `Int | ~??A`
//│ ║  l.53: 	fun foo(f: Foo): Int = if f is Foo(a) then a : f.A
//│ ╙──      	                 ^^^
//│ fun foo: (f: Foo[anything]) -> Int

// TODO
fun foo(f: Foo[?]): Int = if f is Foo(a) then a : f.A else 0
//│ ╔══[ERROR] wildcard type notation currently unsupported
//│ ║  l.66: 	fun foo(f: Foo[?]): Int = if f is Foo(a) then a : f.A else 0
//│ ╙──      	               ^
//│ fun foo: forall 'A. (f: Foo['A]) -> Int

fun foo(f: Foo['a]) = f.a : f.A
//│ fun foo: forall 'a. (f: Foo['a]) -> 'a

fun foo(a, f: Foo[a]): Int = f.a : f.A
//│ fun foo: forall 'a. ('a, f: Foo['a]) -> Int
//│   where
//│     'a <: Int

fun bar(f): Int = f.a : f.A
//│ fun bar: forall 'A. {A :> 'A <: Int, a: 'A} -> Int

foo(2, Foo(1))
//│ Int
//│ res
//│     = 1

bar(Foo(1))
//│ Int
//│ res
//│     = 1

class Foo[A](val a: A -> A)
//│ class Foo[A](a: A -> A)

fun foo(f: Foo) = f.a
//│ fun foo: (f: Foo[in anything out nothing]) -> ??A -> ??A0


fun foo(f) = f : Foo
//│ fun foo: Foo[in anything out nothing] -> Foo[?]

abstract class Foo[type T]: Bar
class Bar(val b: Int) extends Foo[Int]
//│ abstract class Foo[T]: Bar
//│ class Bar(b: Int) extends Foo

// TODO
fun foo(x: Foo[?]) = if x is Bar then x.b : x.T
//│ ╔══[ERROR] wildcard type notation currently unsupported
//│ ║  l.109: 	fun foo(x: Foo[?]) = if x is Bar then x.b : x.T
//│ ╙──       	               ^
//│ fun foo: forall 'a. (x: Foo['a]) -> (Int & 'a)

foo(Bar(1))
//│ Int
//│ res
//│     = 1

fun foo(x: Foo['a]) = if x is Bar then x.b : x.T
//│ fun foo: forall 'a. (x: Foo['a]) -> (Int & 'a)
