:NewDefs
:GADTs

// dependent types? //
// * this is actually broken due to the PairRep case

abstract class Rep[type T]: IntRep | BoolRep | PairRep[T, T] // ? seems not correct
class IntRep extends Rep[Int]
class BoolRep extends Rep[Bool]
class PairRep[A, B](val a: Rep[A], val b: Rep[B]) extends Rep[[A, B]]
//│ abstract class Rep[T]: BoolRep | IntRep | PairRep[T, T]
//│ class IntRep extends Rep {
//│   constructor()
//│ }
//│ class BoolRep extends Rep {
//│   constructor()
//│ }
//│ class PairRep[A, B](a: Rep[A], b: Rep[B]) extends Rep

fun equal[T](ev: Rep[T], x: T, y: T): Bool = if ev is
    IntRep then (x : ev.T) == (y : ev.T)
    BoolRep then ((x : ev.T) && (y : ev.T)) && (not(x : ev.T) && not(y : ev.T))
    // ! swapping the evidence a, b won't affect anything
    PairRep(a, b) then equal(a, (x : ev.T)._1, (y : ev.T)._1) && equal(b, (x : ev.T)._2, (y : ev.T)._2)
//│ fun equal: forall 'T. (ev: Rep['T], x: 'T, y: 'T) -> Bool

equal(new IntRep, 1+1, 2)
//│ Bool
//│ res
//│     = true

:e
equal(new BoolRep, 1+1, true)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.33: 	equal(new BoolRep, 1+1, true)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `Int` is not an instance of `Bool`
//│ ║  l.33: 	equal(new BoolRep, 1+1, true)
//│ ║        	                   ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.9: 	class BoolRep extends Rep[Bool]
//│ ║       	                          ^^^^
//│ ╟── Note: method type parameter T is defined at:
//│ ║  l.20: 	fun equal[T](ev: Rep[T], x: T, y: T): Bool = if ev is
//│ ╙──      	          ^
//│ error | false | true
//│ res
//│     = false

// TODO
equal(PairRep(PairRep(new IntRep, new IntRep), new IntRep), [[1,0], 2], [[4,1], 3])
//│ Bool
//│ res
//│ Runtime error:
//│   TypeError: Cannot read properties of undefined (reading '_1')

// TODO
equal(PairRep(new IntRep, new BoolRep), [1, false], [1, false])
//│ Bool
//│ res
//│     = undefined

// perfect binary tree //

abstract class Perfect[type T]: Leaf | Node[T]
class Leaf(val a: Int) extends Perfect[Int]
class Node[A](val l: Perfect[A], val r: Perfect[A]) extends Perfect[[A, A]]
//│ abstract class Perfect[T]: Leaf | Node[T]
//│ class Leaf(a: Int) extends Perfect
//│ class Node[A](l: Perfect[A], r: Perfect[A]) extends Perfect

fun size[T](t: Perfect[T]): Int = if t is
    Node(l, r) then size(l) + size(r)
    else 1
//│ fun size: forall 'T. (t: Perfect['T]) -> Int

fun head[T](t: Perfect[T]): Int = if t is
    Leaf(a) then a
    Node(l, r) then head(l)
//│ fun head: forall 'T. (t: Perfect['T]) -> Int

fun flip[A](t: Perfect[A]): Perfect[A] = if t is
    Leaf(a) then Leaf(a) : Perfect[t.T]
    Node(l, r) then Node(flip(r), flip(l)) : Perfect[t.T]
//│ fun flip: forall 'A. (t: Perfect['A]) -> Perfect['A]

let test1 = Node(Node(Leaf(1), Leaf(2)), Node(Leaf(3), Leaf(4)))
//│ let test1: Node[[Int, Int]]
//│ test1
//│       = Node {}

:e
let test2 = Node(Leaf(1), Node(Leaf(2), Leaf(3)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.93: 	let test2 = Node(Leaf(1), Node(Leaf(2), Leaf(3)))
//│ ║        	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `[?A, ?A]` is not an instance of type `Int`
//│ ║  l.67: 	class Node[A](val l: Perfect[A], val r: Perfect[A]) extends Perfect[[A, A]]
//│ ║        	                                                                    ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.66: 	class Leaf(val a: Int) extends Perfect[Int]
//│ ║        	                                       ^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.67: 	class Node[A](val l: Perfect[A], val r: Perfect[A]) extends Perfect[[A, A]]
//│ ╙──      	           ^
//│ let test2: Node[out Int | [Int, Int]] | error
//│ test2
//│       = Node {}

:e
head(Node(Node(Leaf(1), Leaf(2)), Leaf(3)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.111: 	head(Node(Node(Leaf(1), Leaf(2)), Leaf(3)))
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Int` is not a 2-element tuple
//│ ║  l.66: 	class Leaf(val a: Int) extends Perfect[Int]
//│ ║        	                                       ^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.67: 	class Node[A](val l: Perfect[A], val r: Perfect[A]) extends Perfect[[A, A]]
//│ ║        	                                                                    ^^^^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.67: 	class Node[A](val l: Perfect[A], val r: Perfect[A]) extends Perfect[[A, A]]
//│ ╙──      	           ^
//│ Int
//│ res
//│     = 1

head(test1)
//│ Int
//│ res
//│     = 1

flip(test1)
//│ Perfect[[[Int, Int], [Int, Int]]]
//│ res
//│     = Node {}

size(test1)
//│ Int
//│ res
//│     = 4
