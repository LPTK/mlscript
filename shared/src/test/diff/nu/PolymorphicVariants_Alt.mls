:NewDefs
:NoJS


// * Adapted example from Code reuse through polymorphic variants (FOSE 2000)
// * This time with an ML-style List data type encoding.


// TODO improvements/things to investigate:
//  - constraining loop with unannotated `list_assoc` ascription
//  - still a number of quite ugly types


class List<out A> {
  fun match: forall 'res: (ifNil: () => 'res, ifCons: (A, List[A]) => 'res) => 'res
  fun match = error
}
let Nil: () => List<'a>
let Cons: (head: 'a, tail: List<'a>) => List<'a>
//│ class List[A] {
//│   constructor()
//│   fun match: forall 'res. (ifNil: () -> 'res, ifCons: (A, List[A]) -> 'res) -> 'res
//│ }
//│ let Nil: () -> List[nothing]
//│ let Cons: forall 'a. (head: 'a, tail: List['a]) -> List['a]

module NotFound
class Success<out A>(result: A)
//│ module NotFound
//│ class Success[A](result: A)

fun eq(l: Str, r: Str): Bool
//│ fun eq: (l: Str, r: Str) -> Bool

// * Annotation currently needed to avoid later ascription loop (due to excessive TV refreshing?)
// fun list_assoc(s, l) =
fun list_assoc(s, l: List<'a>) =
  l.match(
    ifNil: () => NotFound,
    ifCons: (h, t) =>
      if eq(s, h.0) then Success(h.1)
      else list_assoc(s, t)
  )
//│ fun list_assoc: forall 'A. (Str, l: List[{0: Str, 1: 'A}]) -> (NotFound | Success['A])

list_assoc : (Str, List<{ 0: Str, 1: 'b }>) => (NotFound | Success['b])
//│ (Str, List[{0: Str, 1: 'b}]) -> (NotFound | Success['b])

fun list_assoc(s: Str, l: List<{ 0: Str, 1: 'b }>): NotFound | Success['b]
//│ fun list_assoc: forall 'b. (s: Str, l: List[{0: Str, 1: 'b}]) -> (NotFound | Success['b])

class Var(s: Str)
//│ class Var(s: Str)

mixin EvalVar {
  fun eval(sub, v) =
    if v is Var(s) then
      if list_assoc(s, sub) is
        NotFound then v
        Success(r) then r
}
//│ mixin EvalVar() {
//│   fun eval: (List[{0: Str, 1: 'b}], Var) -> (Var | ??A & 'b)
//│ }

class Abs<out A>(x: Str, t: A)
class App<out A>(s: A, t: A)
//│ class Abs[A](x: Str, t: A)
//│ class App[A](s: A, t: A)

fun incr(x: {a: Int}): unit
//│ fun incr: (x: {a: Int}) -> unit

fun gensym(): Str
//│ fun gensym: () -> Str

fun Int_to_string(x: Int): Str
//│ fun Int_to_string: (x: Int) -> Str

mixin EvalLambda {
  fun eval(sub, v) =
    if v is
      App(t1, t2) then
        let l1 = this.eval(sub, t1)
        let l2 = this.eval(sub, t2)
        if t1 is
          Abs(x, t) then this.eval(Cons([x, l2], Nil()), t)
        else
          App(l1, l2)
      Abs(x, t) then
        let s = gensym()
        Abs(s, this.eval(Cons([x, Var(s)], sub), t))
    else
      super.eval(sub, v)
}
//│ mixin EvalLambda() {
//│   super: {eval: ('b, 'c) -> 'd}
//│   this: {
//│     eval: ('b, ??A & 'A) -> 'e & (List[[Str, 'e]], ??A0 & 'A0) -> 'd & (List['a | [Str, Var]], ??A1 & 'A1) -> 'f
//│   }
//│   fun eval: (List['a] & 'b, Abs['A1] | App['A & (Abs['A0] | Object & ~#Abs | ~??A2)] | Object & 'c & ~#Abs & ~#App) -> (Abs['f] | App['e] | 'd)
//│ }

module Test1 extends EvalVar, EvalLambda
//│ module Test1 {
//│   fun eval: (List[{0: Str, 1: 'b}], Abs['A] | App['A0] | Var) -> (Abs['a] | App['a] | 'a)
//│ }
//│ where
//│   'A <: Abs['A] | App['A0] | Var | ~??A
//│   'A0 <: Abs['A & (Abs['A] | App['A0] | Var | ~??A0)] | Abs['A] & ~#Abs | App['A0] | Var | ~??A1
//│   'b :> 'a
//│   'a :> App[nothing] | Abs[nothing] | Var | ??A2 & 'b

Test1.eval(Nil(), Var("a"))
//│ 'a
//│   where
//│     'a :> Var | App['a] | Abs['a]

Test1.eval(Nil(), Abs("b", Var("a")))
//│ 'a
//│   where
//│     'a :> App['a] | Abs['a] | Var

Test1.eval(Cons(["c", Var("d")], Nil()), App(Abs("b", Var("b")), Var("c")))
//│ 'a
//│   where
//│     'a :> App['a] | Abs['a] | Var

Test1.eval(Cons(["c", Abs("d", Var("d"))], Nil()), App(Abs("b", Var("b")), Var("c")))
//│ 'a
//│   where
//│     'a :> App['a] | Abs['a] | Abs[Var] & ??A | Var

class Numb(n: Int)
class Add<out A>(l: A, r: A)
class Mul<out A>(l: A, r: A)
//│ class Numb(n: Int)
//│ class Add[A](l: A, r: A)
//│ class Mul[A](l: A, r: A)

fun map_expr(f, v) =
  if v is
    Var then v
    Numb then v
    Add(l, r) then Add(f(l), f(r))
    Mul(l, r) then Mul(f(l), f(r))
//│ fun map_expr: forall 'a 'A 'b 'A0. ((??A & 'A0) -> 'a & (??A0 & 'A) -> 'b, Add['A0] | Mul['A] | Numb | Var) -> (Add['a] | Mul['b] | Numb | Var)

mixin EvalExpr {
  fun eval(sub, v) =
    let eta(e) = this.eval(sub, e)
    let vv = map_expr(eta, v)
    if vv is
      Var then super.eval(sub, vv)
      Add(Numb(l), Numb(r)) then Numb(l + r)
      Mul(Numb(l), Numb(r)) then Numb(l * r)
    else v
}
//│ mixin EvalExpr() {
//│   super: {eval: ('a, Var) -> 'b}
//│   this: {eval: ('a, ??A & 'A | ??A0 & 'A0) -> (Object | ~??A1 & ~??A2)}
//│   fun eval: ('a, 'b & (Add['A0] | Mul['A] | Numb | Var)) -> (Numb | 'b)
//│ }

module Test2 extends EvalVar, EvalExpr
//│ module Test2 {
//│   fun eval: forall 'a. (List[{0: Str, 1: 'b & (Object | ~??A | ~??A0 & ~??A1)}], 'a & (Add['A] | Mul['A0] | Numb | Var)) -> (Numb | Var | ??A2 & 'A0 | ??A & 'b | ??A3 & 'A | 'a)
//│ }
//│ where
//│   'A <: Add['A] | Mul['A0] | Numb | Var | ~??A3
//│   'A0 <: Add['A] | Mul['A0] | Numb | Var | ~??A2

Test2.eval(Nil(), Var("a"))
//│ Numb | Var

Test2.eval(Cons(["c", Abs("d", Var("d"))], Nil()), Var("a"))
//│ Abs[Var] & ??A | Numb | Var

Test2.eval(Cons(["a", Numb(1)], Nil()), Var("a"))
//│ Numb | Var

Test2.eval(Cons(["a", Abs("d", Var("d"))], Nil()), Add(Numb(1), Var("a")))
//│ Abs[Var] & ??A | Add[Numb | Var] | Numb | Var

module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ module Test3 {
//│   fun eval: (List[{0: Str, 1: 'b}], Abs['A] | App['A0] | Object & 'a & ~#Abs & ~#App) -> (Abs['c] | App['c] | 'c)
//│ }
//│ where
//│   'b :> 'c
//│      <: Object | ~(??A & (??A0 | ??A1))
//│   'c :> App[nothing] | Abs[nothing] | Numb | Var | ??A & 'b | 'a
//│   'a <: Add[Abs['A] | App['A0] | 'a & (Object & ~#Abs & ~#App | ~#Abs & ~#App & ~??A2) | ~??A2] | Mul[Abs['A] | App['A0] | 'a & (Object & ~#Abs & ~#App | ~#Abs & ~#App & ~??A3) | ~??A3] | Numb | Var
//│   'A <: Abs['A] | App['A0] | 'a & (Object & ~#Abs & ~#App | ~#Abs & ~#App & ~??A4) | ~??A4
//│   'A0 <: Abs['A & (Abs['A] | App['A0] | Object & 'a & ~#Abs & ~#App | ~??A5)] | Abs['A] & ~#Abs | App['A0] | Object & 'a & ~#Abs & ~#App | ~??A6

Test3.eval(Cons(["c", Abs("d", Var("d"))], Nil()), Abs("a", Var("a")))
//│ 'a
//│   where
//│     'a :> App['a] | Abs['a] | Abs[Var] & ??A | Numb | Var

Test3.eval(Cons(["c", Abs("d", Var("d"))], Nil()), App(Abs("a", Var("a")), Add(Numb(1), Var("c"))))
//│ 'a
//│   where
//│     'a :> App['a] | Abs['a] | Abs[Var] & ??A | Add[Numb | Var] & ??A0 | Numb | Numb & ??A1 | Var

module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ module Test3 {
//│   fun eval: (List[{0: Str, 1: 'b}], 'a & (Add['A] | Mul['A0] | Numb | Var)) -> (??A & 'A0 | ??A0 & 'A | 'a)
//│ }
//│ where
//│   'b :> ??A & 'A0 | ??A0 & 'A | 'a
//│      <: Object | ~(??A1 & (??A2 | ??A3))
//│   'a :> Abs[nothing] | App[nothing] | Numb | Var | ??A & 'A0 | ??A1 & 'b | ??A0 & 'A
//│   'A0 <: Add['A] | Mul['A0] | Numb | Var | ~??A
//│   'A <: Add['A] | Mul['A0] | Numb | Var | ~??A0

