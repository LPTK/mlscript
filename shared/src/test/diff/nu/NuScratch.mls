:NewDefs

class Ty[type T]
//│ class Ty[T] {
//│   constructor()
//│ }

class Foo[type A](val a: A): Bar | Baz
module Bar extends Foo[Int](1)
module Baz extends Foo[Bool](true)
//│ ╔══[WARNING] Self-type annotations have no effects on non-abstract class definitions
//│ ║  l.8: 	class Foo[type A](val a: A): Bar | Baz
//│ ║       	                             ^^^^^^^^^
//│ ╙── Did you mean to use `extends` and inherit from a parent class?
//│ TEST CASE FAILURE: There was an unexpected warning
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.8: 	class Foo[type A](val a: A): Bar | Baz
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `#Foo & {A = A, a: A}` does not match type `Bar | Baz`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.8: 	class Foo[type A](val a: A): Bar | Baz
//│ ╙──     	                             ^^^^^^^^^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ class Foo[A](a: A): Bar | Baz
//│ module Bar extends Foo
//│ module Baz extends Foo

fun foo(t)(x: Foo[t.T]): t.T = if x is 
    Bar then x.a
    Baz then x.a
//│ fun foo: forall 'T 'T0. {T :> 1 | true | 'T <: 'T0} -> (x: Foo[in 'T out 'T0]) -> 'T0

foo(new Ty)(Bar)
//│ 1 | true
//│ res
//│     = 1

abstract class S[type T]: A | B
module A extends S[Int]
module B extends S[Bool]
//│ abstract class S[T]: A | B
//│ module A extends S
//│ module B extends S

fun f(x: S['a]) = if x is
    A then 1 : x.T
    B then 2 : x.T
//│ fun f: forall 'a. (x: S['a]) -> ('a & (Int | false | true))
//│   where
//│     'a :> 2

f(A)
//│ Int
//│ res
//│     = 1

:e
f(B)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.58: 	f(B)
//│ ║        	^^^^
//│ ╟── integer literal of type `2` is not an instance of type `Bool`
//│ ║  l.47: 	    B then 2 : x.T
//│ ║        	           ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.40: 	module B extends S[Bool]
//│ ║        	                   ^^^^
//│ ╟── Note: type parameter T is defined at:
//│ ║  l.38: 	abstract class S[type T]: A | B
//│ ╙──      	                      ^
//│ 2 | error | false | true
//│ res
//│     = 2

:e
fun f(x: S): x.T = if x is A then 1 else 0
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.76: 	fun f(x: S): x.T = if x is A then 1 else 0
//│ ║        	                      ^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `T` leaks out of its scope
//│ ║  l.76: 	fun f(x: S): x.T = if x is A then 1 else 0
//│ ╙──      	                                  ^
//│ fun f: (x: S[in anything out nothing]) -> ??T

// TODO
fun f(x: S[?]): x.T = if x is 
    A then 1 : x.T
    B then true : x.T
    _ then error
//│ ╔══[ERROR] wildcard type notation currently unsupported
//│ ║  l.86: 	fun f(x: S[?]): x.T = if x is 
//│ ╙──      	           ^
//│ fun f: forall 'a. (x: S['a]) -> ('a & (Int | false | true))

f(A)
//│ Int
//│ res
//│     = 1

:e
let y: ? = 1
//│ ╔══[ERROR] wildcard type notation currently unsupported
//│ ║  l.101: 	let y: ? = 1
//│ ╙──       	       ^
//│ let y: 1
//│ y
//│   = 1

:e
let x = ?
//│ ╔══[ERROR] Cannot use ? as expression
//│ ║  l.110: 	let x = ?
//│ ╙──       	        ^
//│ let x: error
//│ Code generation encountered an error:
//│   cannot generate code for term WildcardType()

:e
if x is ? then 1
//│ ╔══[ERROR] illegal pattern
//│ ║  l.119: 	if x is ? then 1
//│ ╙──       	        ^
//│ error
//│ Code generation encountered an error:
//│   if expression was not desugared

abstract class C[type S, type T]: R | I
class R[A] extends C[A, A]
class I[A](val f: A => Int) extends C[A, Int]
//│ abstract class C[S, T]: I[nothing] | R[?]
//│ class R[A] extends C {
//│   constructor()
//│ }
//│ class I[A](f: A -> Int) extends C

fun foo[A, B](x: A, ev: C[A, B]): B = if ev is 
    R then (x : ev.S) : ev.T
    I(f) then ev.f(x : ev.S) : ev.T
//│ fun foo: forall 'A 'B. (x: 'A, ev: C['A, 'B]) -> 'B

foo(true, new R)
//│ true
//│ res
//│     = true

foo(1, I(x => x + 1))
//│ Int
//│ res
//│     = 2


// ;;
// :
// new A.B



module Foo { val a = 1 }
//│ module Foo {
//│   val a: 1
//│ }

Foo.a
//│ 1
//│ res
//│     = 1



:e
123 { 4 }
//│ ╔══[ERROR] Refinement terms are not yet supported
//│ ║  l.171: 	123 { 4 }
//│ ╙──       	^^^^^^^^^
//│ error
//│ Code generation encountered an error:
//│   cannot generate code for term Rft(IntLit(123),TypingUnit(List(IntLit(4))))


class A
//│ class A {
//│   constructor()
//│ }

:e
new A { }
//│ ╔══[ERROR] Refinement terms are not yet supported
//│ ║  l.186: 	new A { }
//│ ╙──       	^^^^^^^^^
//│ error
//│ Code generation encountered an error:
//│   cannot generate code for term Rft(NuNew(Var(A)),TypingUnit(List()))




:w
class Foo { constructor(x: Int){};; val y = 2 }
//│ ╔══[WARNING] Pure expression does nothing in statement position.
//│ ║  l.198: 	class Foo { constructor(x: Int){};; val y = 2 }
//│ ╙──       	                                 ^
//│ ╔══[WARNING] Pure expression does nothing in statement position.
//│ ║  l.198: 	class Foo { constructor(x: Int){};; val y = 2 }
//│ ╙──       	                                  ^
//│ class Foo {
//│   constructor(x: Int)
//│   val y: 2
//│ }

:pe
:e
class Foo { constructor(x: Int){}; val y = 2 }
//│ ╔══[WARNING] Pure expression does nothing in statement position.
//│ ║  l.212: 	class Foo { constructor(x: Int){}; val y = 2 }
//│ ╙──       	                                 ^
//│ TEST CASE FAILURE: There was an unexpected warning
//│ class Foo {
//│   constructor(x: Int)
//│   val y: 2
//│ }
//│ TEST CASE FAILURE: There was an unexpected lack of parse error
//│ TEST CASE FAILURE: There was an unexpected lack of type error

class Foo {
  constructor(x: Int){}
  val y = 2
}
//│ class Foo {
//│   constructor(x: Int)
//│   val y: 2
//│ }

:e
Foo
//│ ╔══[ERROR] Construction of unparameterized class Foo should use the `new` keyword
//│ ║  l.234: 	Foo
//│ ╙──       	^^^
//│ (x: Int) -> Foo
//│ res
//│     = [class Foo]

// :d
:e
new Foo
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.244: 	new Foo
//│ ║         	    ^^^
//│ ╟── argument list of type `[]` does not match type `[x: Int]`
//│ ║  l.244: 	new Foo
//│ ╙──       	       ^
//│ Foo | error
//│ res
//│     = Foo {}

:e
let f = new Foo
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.256: 	let f = new Foo
//│ ║         	            ^^^
//│ ╟── argument list of type `[]` does not match type `[x: Int]`
//│ ║  l.256: 	let f = new Foo
//│ ╙──       	               ^
//│ let f: Foo | error
//│ f
//│   = Foo {}

:e
f(1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.268: 	f(1)
//│ ║         	^^^^
//│ ╟── application of type `Foo` is not a function
//│ ║  l.256: 	let f = new Foo
//│ ║         	            ^^^
//│ ╟── but it flows into reference with expected type `1 -> ?a`
//│ ║  l.268: 	f(1)
//│ ╙──       	^
//│ error
//│ res
//│ Runtime error:
//│   TypeError: f3 is not a function


new Foo(2)
//│ Foo
//│ res
//│     = Foo {}

// new Foo("2")

:e
new Foo()
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.292: 	new Foo()
//│ ║         	^^^^^^^^^
//│ ╟── argument list of type `[]` does not match type `[x: Int]`
//│ ║  l.292: 	new Foo()
//│ ╙──       	       ^^
//│ Foo | error
//│ res
//│     = Foo {}


// :dp
new Foo(1).y
//│ 2
//│ res
//│     = 2






