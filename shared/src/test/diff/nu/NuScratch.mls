:NewDefs



:d
fun f(x) = x
//│ 0. Typing ‹fun f = (x,) => x›
//│ | 0. Created lazy type info for fun f = (x,) => x
//│ | Completing fun f = (x,) => x
//│ | | Type params 
//│ | | Params 
//│ | | 1. Typing term (x,) => x
//│ | | | 1. Typing pattern [x,]
//│ | | | | 1. Typing pattern x
//│ | | | | 1. : x29'
//│ | | | 1. : (x29',)
//│ | | | 1. Typing term x
//│ | | | 1. : x29'
//│ | | 1. : (x29' -> x29')
//│ | | CONSTRAIN (x29' -> x29') <! f30'
//│ | |   where 
//│ | | 1. C (x29' -> x29') <! f30'    (0)
//│ | | | NEW f30' LB (1)
//│ | Completed TypedNuFun(0,fun f = (x::0,) => x,(x29' -> x29')) where 
//│ | Typing unit statements
//│ | : None
//│ ======== TYPED ========
//│ fun f: ‹∀ 0. (x29' -> x29')› where 
//│ fun f: forall 'x. 'x -> 'x

abstract class S[type T]: A | B
module A extends S[Int]
module B extends S[Bool]
//│ abstract class S[T]: A | B
//│ module A extends S
//│ module B extends S

fun f(x: S['a]) = if x is
    A then 1
    B then 2
//│ fun f: forall 'a. (x: S['a]) -> (1 | 2)

fun f(x: S): x.T = if x is 
    A then
        let ret = 1 as x.T
        ret
    B then
        let ret = true as x.T
        ret
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.43: 	fun f(x: S): x.T = if x is 
//│ ║        	                      ^^^^^
//│ ║  l.44: 	    A then
//│ ║        	^^^^^^^^^^
//│ ║  l.45: 	        let ret = 1 as x.T
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.46: 	        ret
//│ ║        	^^^^^^^^^^^
//│ ║  l.47: 	    B then
//│ ║        	^^^^^^^^^^
//│ ║  l.48: 	        let ret = true as x.T
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.49: 	        ret
//│ ║        	^^^^^^^^^^^
//│ ╟── type `S[?]` does not match type `A | B`
//│ ║  l.43: 	fun f(x: S): x.T = if x is 
//│ ║        	         ^
//│ ╟── but it flows into reference with expected type `A | B`
//│ ║  l.43: 	fun f(x: S): x.T = if x is 
//│ ╙──      	                      ^
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.43: 	fun f(x: S): x.T = if x is 
//│ ║        	                      ^^^^^
//│ ║  l.44: 	    A then
//│ ║        	^^^^^^^^^^
//│ ║  l.45: 	        let ret = 1 as x.T
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.46: 	        ret
//│ ║        	^^^^^^^^^^^
//│ ║  l.47: 	    B then
//│ ║        	^^^^^^^^^^
//│ ║  l.48: 	        let ret = true as x.T
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.49: 	        ret
//│ ║        	^^^^^^^^^^^
//│ ╟── type `Int` does not match type `T`
//│ ║  l.32: 	module A extends S[Int]
//│ ║        	                   ^^^
//│ ╟── but it flows into reference with expected type `T`
//│ ║  l.46: 	        ret
//│ ║        	        ^^^
//│ ╟── Note: constraint arises from type parameter:
//│ ║  l.31: 	abstract class S[type T]: A | B
//│ ╙──      	                      ^
//│ fun f: (x: S[in anything out nothing]) -> nothing

fun foo(x: S[?]) = x
//│ fun foo: (x: S[nothing]) -> S[nothing]

:e
foo(A)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.101: 	foo(A)
//│ ║         	^^^^^^
//│ ╟── type `Int` does not match type `?`
//│ ║  l.32: 	module A extends S[Int]
//│ ║        	                   ^^^
//│ ╟── Note: constraint arises from wildcard:
//│ ║  l.97: 	fun foo(x: S[?]) = x
//│ ╙──      	             ^
//│ S[nothing] | error
//│ res
//│     = A { class: [class A extends S] }

// todo
let y: ? = 1
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.116: 	let y: ? = 1
//│ ║         	           ^
//│ ╟── integer literal of type `1` does not match type `?`
//│ ╟── Note: constraint arises from wildcard:
//│ ║  l.116: 	let y: ? = 1
//│ ╙──       	       ^
//│ let y: nothing
//│ y
//│   = 1

:e
let x = ?
//│ ╔══[ERROR] Cannot use ? as expression
//│ ║  l.129: 	let x = ?
//│ ╙──       	        ^
//│ let x: error
//│ Code generation encountered an error:
//│   cannot generate code for term ?
