:NewDefs



:d
fun f(x) = x
//│ 0. Typing ‹fun f = (x,) => x›
//│ | 0. Created lazy type info for fun f = (x,) => x
//│ | Completing fun f = (x,) => x
//│ | | Type params 
//│ | | Params 
//│ | | 1. Typing term (x,) => x
//│ | | | 1. Typing pattern [x,]
//│ | | | | 1. Typing pattern x
//│ | | | | 1. : x29'
//│ | | | 1. : (x29',)
//│ | | | 1. Typing term x
//│ | | | 1. : x29'
//│ | | 1. : (x29' -> x29')
//│ | | CONSTRAIN (x29' -> x29') <! f30'
//│ | |   where 
//│ | | 1. C (x29' -> x29') <! f30'    (0)
//│ | | | NEW f30' LB (1)
//│ | Completed TypedNuFun(0,fun f = (x::0,) => x,(x29' -> x29')) where 
//│ | Typing unit statements
//│ | : None
//│ ======== TYPED ========
//│ fun f: ‹∀ 0. (x29' -> x29')› where 
//│ fun f: forall 'x. 'x -> 'x

class Ty[type T]
//│ class Ty[T] {
//│   constructor()
//│ }

class Foo[type A](val a: A): Bar | Baz
module Bar extends Foo[Int](1)
module Baz extends Foo[Bool](true)
//│ class Foo[A](a: A): Bar | Baz
//│ module Bar extends Foo
//│ module Baz extends Foo

fun foo(t)(x: Foo[t.T]): t.T = if x is 
    Bar then x.a
    Baz then x.a
//│ fun foo: forall 'T 'T0. {T :> 1 | true | 'T0 <: 'T} -> (x: Foo[in 'T0 out 'T]) -> 'T

foo(new Ty)(Bar)
//│ 1 | true
//│ res
//│     = 1

abstract class S[type T]: A | B
module A extends S[Int]
module B extends S[Bool]
//│ abstract class S[T]: A | B
//│ module A extends S
//│ module B extends S

fun f(x: S['a]) = if x is
    A then 1
    B then 2
//│ fun f: forall 'a. (x: S['a]) -> (1 | 2)

fun f(x: S): x.T = if x is A then 1 else 0
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.65: 	fun f(x: S): x.T = if x is A then 1 else 0
//│ ║        	                      ^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `T` leaks out of its scope
//│ ║  l.65: 	fun f(x: S): x.T = if x is A then 1 else 0
//│ ╙──      	                                  ^
//│ fun f: (x: S[in anything out nothing]) -> ??T

fun f(x: S): x.T = if x is 
    A then 1 : x.T
    B then true : x.T
    _ then error
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.74: 	fun f(x: S): x.T = if x is 
//│ ║        	                      ^^^^^
//│ ║  l.75: 	    A then 1 : x.T
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.76: 	    B then true : x.T
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.77: 	    _ then error
//│ ║        	^^^^^^^^^^^^^^^^
//│ ╟── type variable `T` leaks out of its scope
//│ ║  l.54: 	module A extends S[Int]
//│ ╙──      	                   ^^^
//│ fun f: (x: S[in anything out nothing]) -> ??T

// todo unbounded wildcard type ?
let y: ? = 1
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.93: 	let y: ? = 1
//│ ║        	           ^
//│ ╟── integer literal of type `1` does not match type `?`
//│ ╟── Note: constraint arises from wildcard:
//│ ║  l.93: 	let y: ? = 1
//│ ╙──      	       ^
//│ let y: nothing
//│ y
//│   = 1

:e
let x = ?
//│ ╔══[ERROR] Cannot use ? as expression
//│ ║  l.106: 	let x = ?
//│ ╙──       	        ^
//│ let x: error
//│ Code generation encountered an error:
//│   cannot generate code for term ?

:e
if x is ? then 1
//│ ╔══[ERROR] illegal pattern
//│ ║  l.115: 	if x is ? then 1
//│ ╙──       	        ^
//│ error
//│ Code generation encountered an error:
//│   if expression was not desugared

abstract class Fmt[type T]
class D[T](k: Fmt[T]) extends Fmt[Int -> T]
class B[T](k: Fmt[T]) extends Fmt[Bool -> T]
class L[T](s: string, k: Fmt[T]) extends Fmt[T]
class E extends Fmt[string]
//│ abstract class Fmt[T]
//│ class D[T](k: Fmt[T]) extends Fmt
//│ class B[T](k: Fmt[T]) extends Fmt
//│ class L[T](s: string, k: Fmt[T]) extends Fmt
//│ class E extends Fmt {
//│   constructor()
//│ }

class S[type S, type T]: R
class R[A] extends S[A, A]
//│ class S[S, T]: R[?] {
//│   constructor()
//│ }
//│ class R[A] extends S {
//│   constructor()
//│ }

// FIXME
fun f[A, B](x: A, ev: S[A, B]): B =
    if ev is R then x : ev.T
//│ ╔══[ERROR] Type error in `case` expression
//│ ║  l.147: 	    if ev is R then x : ev.T
//│ ║         	       ^^^^^^^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.137: 	class R[A] extends S[A, A]
//│ ╙──       	        ^
//│ fun f: forall 'A 'B. (x: 'A, ev: S['A, 'B]) -> 'B

