:NewDefs


// ?A' :> `S <: `S
// ?A :> ??S <: ??S and ?A' :> `S | ?A <: `S & ?A'
// the bounds of ??A are now eqt to ?A :> Top <: Bot
// which fails


class Box[type A](val get: A)
abstract class F[type A]: MkF
class MkF[T](t: T) extends F[Box[T]]
//│ class Box[A](get: A)
//│ abstract class F[A]: MkF[anything]
//│ class MkF[T](t: T) extends F

// :d
fun f[T](x: F[T]): T = if x is MkF(t) then Box(t) as x.A
//│ fun f: forall 'T. (x: F['T]) -> 'T



fun f: Box[?]
//│ fun f: Box[anything]

// :ds
f
//│ Box[anything]
//│ res
//│     = <no result>
//│       f is not implemented


fun foo(b: Box['X]) = b.get + 1
//│ fun foo: forall 'X. (b: Box['X]) -> Int
//│   where
//│     'X <: Int

fun foo(b: Box['X] & Box[Int]) = [b, b.get + 1]
//│ fun foo: forall 'X. (b: Box[Int | 'X]) -> [Box[Int & 'X], Int]


type List[out A] = Cons[A]
module Nil
class Cons[A](head: A, tail: List[A])
//│ type List[A] = Cons[A]
//│ module Nil
//│ class Cons[A](head: A, tail: List[A])

fun listConcat(xs) =
  if xs is
    Cons(x, xs2) then Cons(x, listConcat(xs2))
//│ fun listConcat: forall 'A 'A0. Cons['A] -> Cons['A0]
//│   where
//│     'A0 :> ??A & 'A

