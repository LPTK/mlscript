:NewDefs


module M {
  type T = Int -> Int
  class C(n: Int)
  fun mkC = C
}
//│ module M {
//│   class C(n: Int)
//│   type T = Int -> Int
//│   fun mkC: (n: Int) -> C
//│ }

let x: M.T = id
//│ ╔══[ERROR] Access to type alias member not yet supported
//│ ║  l.15: 	let x: M.T = id
//│ ╙──      	        ^^
//│ ╔══[ERROR] Type mismatch in type selection:
//│ ║  l.15: 	let x: M.T = id
//│ ║        	        ^^
//│ ╙── expression of type `M` does not have field 'T'
//│ let x: error
//│ x
//│   = [Function: id]

fun foo(x: M.C) = x
//│ ╔══[ERROR] Access to class member not yet supported
//│ ║  l.27: 	fun foo(x: M.C) = x
//│ ╙──      	            ^^
//│ ╔══[ERROR] Type mismatch in type selection:
//│ ║  l.27: 	fun foo(x: M.C) = x
//│ ║        	            ^^
//│ ╙── expression of type `M` does not have field 'C'
//│ fun foo: (x: anything) -> error


foo(M.mkC(42))
//│ error
//│ res
//│     = C {}


:e
42 : M.mkC
//│ ╔══[ERROR] Type mismatch in type selection:
//│ ║  l.45: 	42 : M.mkC
//│ ║        	      ^^^^
//│ ╙── expression of type `M` does not have field 'mkC'
//│ (n: Int) -> C
//│ res
//│     = 42


