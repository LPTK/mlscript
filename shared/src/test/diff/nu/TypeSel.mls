:NewDefs

:AllowParseErrors // TODO rm
:AllowTypeErrors // TODO rm


// * To support:
// *  - type parameter members
// *  - accessing type members in variables (for now, no need for path dependence)
// *  - Interpret absence of type parameters as some fresh type variables: `Foo` means `Foo['a]`

// * For the future:
// *  - Type refinement syntax, as in `Foo { A = Int }`
// *  - Support wildcard type argument syntax: `Foo[?]` (for what we currently write `Foo`)
// *  - `as` syntax for upcasting

class Foo[type A] {
  fun f: A -> Int
  fun f(x) = 1
}
//│ class Foo[A] {
//│   constructor()
//│   fun f: A -> Int
//│ }

fun foo(f: Foo[Int], g: Foo[f.A], x: f.A) = g.f(f.f(x))
//│ fun foo: (f: Foo[Int], g: Foo[Int], x: Int) -> Int

class Bar(val f: Foo[Int])
//│ class Bar(f: Foo[Int])

fun foo(b: Bar): b.f.A = 1
//│ fun foo: (b: Bar) -> Int

// TODO i think we will just not support this
fun foo(b: Bar) =
  let f = id(b).f
  1: f.A
//│ ╔══[ERROR] cannot use variable f as type
//│ ║  l.38: 	  1: f.A
//│ ╙──      	     ^
//│ ╔══[ERROR] as defined in here
//│ ║  l.37: 	  let f = id(b).f
//│ ╙──      	      ^^^^^^^^^^^
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: Can't find `error`


fun foo(p, q, f: (p,q) -> Int) = f(p,q)
//│ fun foo: forall 'a 'b. ('a, 'b, f: ('a, 'b) -> Int) -> Int

foo(1, 0, (x, y) => x + y)
//│ Int

class Foo[type A](val a: A)
//│ class Foo[A](a: A)

fun foo(f: Foo[Int]): Int = f.a : f.A
//│ fun foo: (f: Foo[Int]) -> Int

// raw type example
// TODO support
fun foo(f: Foo): Int = f.a : f.A
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.62: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                       ^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.62: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                       ^^^
//│ ╟── into type `A`
//│ ║  l.54: 	class Foo[type A](val a: A)
//│ ╙──      	               ^
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.62: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                       ^^^
//│ ╟── type `A` is not an instance of type `Int`
//│ ║  l.54: 	class Foo[type A](val a: A)
//│ ║        	               ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.62: 	fun foo(f: Foo): Int = f.a : f.A
//│ ╙──      	                 ^^^
//│ fun foo: (f: Foo[anything]) -> Int

// FIXME
fun foo(f: Foo) = f.a : f.A
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.84: 	fun foo(f: Foo) = f.a : f.A
//│ ║        	                  ^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.84: 	fun foo(f: Foo) = f.a : f.A
//│ ║        	                  ^^^
//│ ╟── into type `A`
//│ ║  l.54: 	class Foo[type A](val a: A)
//│ ╙──      	               ^
//│ fun foo: (f: Foo[anything]) -> nothing

// TODO reject for now
fun foo(f: Foo[?]): Int = f.a : f.A
//│ ╔══[PARSE ERROR] Unexpected operator here
//│ ║  l.97: 	fun foo(f: Foo[?]): Int = f.a : f.A
//│ ╙──      	               ^
//│ ╔══[ERROR] Wrong number of type arguments – expected 1, found 0
//│ ║  l.97: 	fun foo(f: Foo[?]): Int = f.a : f.A
//│ ╙──      	           ^^^^^^
//│ fun foo: forall 'a. (f: Foo['a]) -> Int
//│   where
//│     'a <: Int

// FIXME
// * TODO infer (f: 'f) -> 'b where 'f <: { a: 'a;; A: 'a..'b }, 'a <: 'b
fun foo(f) = f.a : f.A
//│ ╔══[ERROR] Member A not found in ?a
//│ ║  l.110: 	fun foo(f) = f.a : f.A
//│ ╙──       	                   ^
//│ fun foo: {a: error} -> error

// FIXME
fun foo(f): Int = f.a : f.A
//│ ╔══[ERROR] Member A not found in ?a
//│ ║  l.117: 	fun foo(f): Int = f.a : f.A
//│ ╙──       	                        ^
//│ fun foo: {a: error} -> Int


class Foo[type A]
//│ class Foo[A] {
//│   constructor()
//│ }

module Bar extends Foo[Int]
module Baz extends Foo[Str]
//│ module Bar extends Foo
//│ module Baz extends Foo

123 : Bar.A
//│ Int

// FIXME
fun foo(f, x) = x : f.A
//│ ╔══[ERROR] Member A not found in ?a
//│ ║  l.138: 	fun foo(f, x) = x : f.A
//│ ╙──       	                    ^
//│ fun foo: (anything, error) -> error

// FIXME
foo(Bar, 123)
//│ error


// FIXME
fun test(f) = if f is
  Bar then 123 : f.A
//│ fun test: Bar -> Int

// FIXME
fun test(f) = if f is
  Bar then 123 : f.A
  Baz then "hello" : f.A
//│ fun test: (Bar | Baz) -> (Int | Str)

// FIXME
[test(Bar), test(Baz)]
//│ [Int | Str, Int | Str]


// FIXME

fun test(f: Foo) = if f is
  Bar then 123 : f.A
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.167: 	fun test(f: Foo) = if f is
//│ ║         	                      ^^^^
//│ ║  l.168: 	  Bar then 123 : f.A
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `Foo[?]` is not an instance of type `Bar`
//│ ║  l.167: 	fun test(f: Foo) = if f is
//│ ║         	            ^^^
//│ ╟── but it flows into reference with expected type `Bar`
//│ ║  l.167: 	fun test(f: Foo) = if f is
//│ ║         	                      ^
//│ ╟── Note: constraint arises from class pattern:
//│ ║  l.168: 	  Bar then 123 : f.A
//│ ╙──       	  ^^^
//│ fun test: (f: Foo[in anything out nothing]) -> (Int | error)

// FIXME
fun test(f: Foo) = if f is
  Bar then 123 : f.A
  Baz then "hello" : f.A
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.186: 	fun test(f: Foo) = if f is
//│ ║         	                      ^^^^
//│ ║  l.187: 	  Bar then 123 : f.A
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.188: 	  Baz then "hello" : f.A
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── type `Foo[?]` does not match type `Bar | Baz`
//│ ║  l.186: 	fun test(f: Foo) = if f is
//│ ║         	            ^^^
//│ ╟── but it flows into reference with expected type `Bar | Baz`
//│ ║  l.186: 	fun test(f: Foo) = if f is
//│ ╙──       	                      ^
//│ fun test: (f: Foo[in anything out nothing]) -> (Int | Str)

// FIXME
[test(Bar), test(Baz)]
//│ [Int | Str, Int | Str]


:e
class Foo[type A]
class Bar[type A] extends Foo[A]
//│ class Foo[A] {
//│   constructor()
//│ }
//│ class Bar[A] extends Foo {
//│   constructor()
//│ }

class Foo[type A]
//│ class Foo[A] {
//│   constructor()
//│ }

:e
class Bar[type A] extends Foo[A -> A]
//│ class Bar[A] extends Foo {
//│   constructor()
//│ }

:e
class Bar[type A] extends Foo[Int]
//│ class Bar[A] extends Foo {
//│   constructor()
//│ }




class Foo[A]
//│ class Foo[A] {
//│   constructor()
//│ }

// FIXME
// Would be nice:
fun foo(x: Foo['a], y) = y : x.A  // interpreted as `y : x.Foo#A`
//│ fun foo: forall 'a. (x: Foo['a], 'a) -> 'a

// FIXME
fun foo(x, y) = y : x.A
//│ ╔══[ERROR] Member A not found in ?a
//│ ║  l.250: 	fun foo(x, y) = y : x.A
//│ ╙──       	                    ^
//│ fun foo: (anything, error) -> error

// FIXME
fun bar(f: Foo['a], y) = foo(f, y)
//│ fun bar: forall 'a. (f: Foo['a], error) -> error

class Bar(val A: Int)
//│ class Bar(A: Int)

class C[type A]: C1 | C2
class C1(val s: Bool) extends C[Bool]
class C2(val i: Int) extends C[Int]
//│ class C[A]: C1 | C2 {
//│   constructor()
//│ }
//│ class C1(s: Bool) extends C
//│ class C2(i: Int) extends C

let c1 = C1(true)
let c2 = C2(1)
//│ let c1: C1
//│ let c2: C2


