:NewDefs

:AllowParseErrors // TODO rm
:AllowTypeErrors // TODO rm


// * To support:
// *  - type parameter members
// *  - accessing type members in variables (for now, no need for path dependence)
// *  - Interpret absence of type parameters as some fresh type variables: `Foo` means `Foo['a]`

// * For the future:
// *  - Type refinement syntax, as in `Foo { A = Int }`
// *  - Support wildcard type argument syntax: `Foo[?]` (for what we currently write `Foo`)
// *  - `as` syntax for upcasting

class Foo[A](val a: A)
//│ class Foo[A](a: A)

:e
fun foo(f: Foo[Int]): f.A = f.a
//│ ╔══[ERROR] Type `Foo[Int]` does not contain member `A`
//│ ║  l.21: 	fun foo(f: Foo[Int]): f.A = f.a
//│ ╙──      	                       ^^
//│ fun foo: (f: Foo[Int]) -> error

class Foo[type A] {
  fun f: A -> Int
  fun f(x) = 1
}
//│ class Foo[A] {
//│   constructor()
//│   fun f: A -> Int
//│ }


fun foo(f: Foo[Int], g: Foo[f.A], x: f.A) = g.f(f.f(x))
//│ fun foo: (f: Foo[Int], g: Foo[Int], x: Int) -> Int

class Bar(val f: Foo[Int])
//│ class Bar(f: Foo[Int])

:e
fun foo(b: Bar): b.f.A = 1
//│ ╔══[ERROR] Type mismatch in type selection:
//│ ║  l.44: 	fun foo(b: Bar): b.f.A = 1
//│ ║        	                  ^^
//│ ╙── type `Foo[Int]` cannot be reassigned
//│ fun foo: (b: Bar) -> Int

fun bar(b: Bar) = b.f.f(1)
//│ fun bar: (b: Bar) -> Int

fun foo(b: Bar) =
  let f = id(b).f
  let g = x => f.f(x + 1)
  g(1) : f.A
//│ fun foo: (b: Bar) -> Int

// FIXME
fun foo(f: Foo, x: f.A) = f.f(x)
//│ ╔══[ERROR] Type error in application
//│ ║  l.61: 	fun foo(f: Foo, x: f.A) = f.f(x)
//│ ║        	                          ^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.61: 	fun foo(f: Foo, x: f.A) = f.f(x)
//│ ║        	                    ^^
//│ ╟── back into type variable `A`
//│ ║  l.27: 	class Foo[type A] {
//│ ╙──      	               ^
//│ fun foo: (f: Foo[nothing], x: ??A) -> (Int | error)

fun foo(p, q, f: (p,q) -> Int) = f(p,q)
//│ fun foo: forall 'a 'b. ('a, 'b, f: ('a, 'b) -> Int) -> Int

foo(1, 0, (x, y) => x + y)
//│ Int

class Foo[type A](val a: A)
//│ class Foo[A](a: A)

fun foo(f: Foo[Int]): Int = f.a : f.A
//│ fun foo: (f: Foo[Int]) -> Int

fun foo[T](f: Foo[T]): T = f.a : f.A
//│ fun foo: forall 'T. (f: Foo['T]) -> 'T

// raw type example
// TODO support
fun foo(f: Foo): Int = f.a : f.A
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.90: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                       ^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.90: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                       ^^^
//│ ╟── back into type variable `A`
//│ ║  l.90: 	fun foo(f: Foo): Int = f.a : f.A
//│ ╙──      	                              ^^
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.90: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                       ^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.90: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                              ^^
//│ ╟── into type `Int`
//│ ║  l.90: 	fun foo(f: Foo): Int = f.a : f.A
//│ ╙──      	                 ^^^
//│ fun foo: (f: Foo[anything]) -> Int

// FIXME
fun foo(f: Foo) = f.a : f.A
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.112: 	fun foo(f: Foo) = f.a : f.A
//│ ║         	                  ^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.112: 	fun foo(f: Foo) = f.a : f.A
//│ ║         	                  ^^^
//│ ╟── back into type variable `A`
//│ ║  l.112: 	fun foo(f: Foo) = f.a : f.A
//│ ╙──       	                         ^^
//│ fun foo: (f: Foo[anything]) -> ??A

fun foo(f: Foo['a]): Int = f.a : f.A
//│ fun foo: forall 'a. (f: Foo['a]) -> Int
//│   where
//│     'a <: Int

// TODO reject for now
fun foo(f: Foo[?]): Int = f.a : f.A
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.130: 	fun foo(f: Foo[?]): Int = f.a : f.A
//│ ║         	                          ^^^
//│ ╟── field selection of type `anything` does not match type `nothing`
//│ ╟── Note: constraint arises from type selection:
//│ ║  l.130: 	fun foo(f: Foo[?]): Int = f.a : f.A
//│ ╙──       	                                 ^^
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.130: 	fun foo(f: Foo[?]): Int = f.a : f.A
//│ ║         	                          ^^^
//│ ╟── type `anything` is not an instance of type `Int`
//│ ║  l.130: 	fun foo(f: Foo[?]): Int = f.a : f.A
//│ ║         	                                 ^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.130: 	fun foo(f: Foo[?]): Int = f.a : f.A
//│ ╙──       	                    ^^^
//│ fun foo: (f: Foo[anything]) -> Int

fun foo(f) = f.a : f.A
//│ fun foo: forall 'A 'A0. {A :> 'A <: 'A0, a: 'A} -> 'A0

fun foo(f): Int = f.a : f.A
//│ fun foo: forall 'A. {A :> 'A <: Int, a: 'A} -> Int

foo(Foo(1))
//│ Int

:e
foo(Foo(true))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.159: 	foo(Foo(true))
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── reference of type `true` is not an instance of `Int`
//│ ║  l.159: 	foo(Foo(true))
//│ ║         	        ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.152: 	fun foo(f): Int = f.a : f.A
//│ ║         	            ^^^
//│ ╟── from type selection:
//│ ║  l.152: 	fun foo(f): Int = f.a : f.A
//│ ╙──       	                         ^^
//│ Int | error

class Foo[type A]: Bar | Baz
module Bar extends Foo[Int]
module Baz extends Foo[Str]
//│ ╔══[WARNING] Self-type annotations have no effects on non-abstract class definitions
//│ ║  l.174: 	class Foo[type A]: Bar | Baz
//│ ║         	                   ^^^^^^^^^
//│ ╙── Did you mean to use `extends` and inherit from a parent class?
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.174: 	class Foo[type A]: Bar | Baz
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── expression of type `#Foo & {A = A}` does not match type `Bar | Baz`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.174: 	class Foo[type A]: Bar | Baz
//│ ╙──       	                   ^^^^^^^^^
//│ class Foo[A]: Bar | Baz {
//│   constructor()
//│ }
//│ module Bar extends Foo
//│ module Baz extends Foo

123 : Bar.A
//│ Int

:e
"bad": Bar.A
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.198: 	"bad": Bar.A
//│ ║         	^^^^^
//│ ╟── string literal of type `"bad"` is not an instance of type `Int`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.175: 	module Bar extends Foo[Int]
//│ ║         	                       ^^^
//│ ╟── from type selection:
//│ ║  l.198: 	"bad": Bar.A
//│ ╙──       	          ^^
//│ Int

fun foo(f, x) = x : f.A
//│ fun foo: forall 'A 'A0. ({A :> 'A <: 'A0}, 'A) -> 'A0

foo(Bar, 123)
//│ Int

fun test(f) = if f is
  Bar then 123 : f.A
//│ fun test: Bar -> Int

fun test(f) = if f is
  Bar then 123 : f.A
  Baz then "hello" : f.A
//│ fun test: (Bar | Baz) -> (Int | Str)

[test(Bar), test(Baz)]
//│ [Int | Str, Int | Str]

fun test(f: Foo['a]) = if f is Bar then 123 : f.A else error
//│ fun test: forall 'a. (f: Foo['a]) -> (Int & 'a)

fun test(f: Foo[Int]) = if f is Bar then 123 : f.A else error
//│ fun test: (f: Foo[Int]) -> Int

fun test(f: Foo) = if f is Bar then 123 : f.A else error
//│ fun test: (f: Foo[?]) -> Int

fun test(f: Foo[?]) = if f is Bar then 123 : f.A else error
//│ fun test: (f: Foo[?]) -> Int

// FIXME
fun test(f: Foo) = if f is
  Bar then 123 : f.A
  Baz then "hello" : f.A
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.242: 	fun test(f: Foo) = if f is
//│ ║         	                      ^^^^
//│ ║  l.243: 	  Bar then 123 : f.A
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.244: 	  Baz then "hello" : f.A
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── type `Foo[?]` does not match type `Bar | Baz`
//│ ║  l.242: 	fun test(f: Foo) = if f is
//│ ║         	            ^^^
//│ ╟── but it flows into reference with expected type `Bar | Baz`
//│ ║  l.242: 	fun test(f: Foo) = if f is
//│ ╙──       	                      ^
//│ fun test: (f: Foo[?]) -> (Int | Str)

[test(Bar), test(Baz)]
//│ [Int | Str, Int | Str]

fun test(f: Foo[?]) = if f is
  Bar then 123 : f.A
  Baz then "hello" : f.A
//│ fun test: (f: Foo[?]) -> (Int | Str)

fun test[T](f: Foo[T]): T = if f is
  Bar then 123 : f.A
  Baz then "hello" : f.A
//│ fun test: forall 'T. (f: Foo['T]) -> 'T

:e
class Foo[type A]
class Bar[type A] extends Foo[A]
//│ ╔══[ERROR] Inherited parameter named `A` is not virtual and cannot be overridden
//│ ║  l.275: 	class Bar[type A] extends Foo[A]
//│ ║         	               ^
//│ ╟── Originally declared here:
//│ ║  l.274: 	class Foo[type A]
//│ ╙──       	               ^
//│ class Foo[A] {
//│   constructor()
//│ }
//│ class Bar[A] extends Foo {
//│   constructor()
//│ }

class Foo[type A]
//│ class Foo[A] {
//│   constructor()
//│ }

:e
class Bar[type A] extends Foo[A -> A]
//│ ╔══[ERROR] Inherited parameter named `A` is not virtual and cannot be overridden
//│ ║  l.295: 	class Bar[type A] extends Foo[A -> A]
//│ ║         	               ^
//│ ╟── Originally declared here:
//│ ║  l.289: 	class Foo[type A]
//│ ╙──       	               ^
//│ class Bar[A] extends Foo {
//│   constructor()
//│ }

:e
class Bar[type A] extends Foo[Int]
//│ ╔══[ERROR] Inherited parameter named `A` is not virtual and cannot be overridden
//│ ║  l.307: 	class Bar[type A] extends Foo[Int]
//│ ║         	               ^
//│ ╟── Originally declared here:
//│ ║  l.289: 	class Foo[type A]
//│ ╙──       	               ^
//│ class Bar[A] extends Foo {
//│   constructor()
//│ }




class Foo[A]
//│ class Foo[A] {
//│   constructor()
//│ }

// FIXME
// Would be nice:
fun foo(x: Foo['a], y) = y : x.A  // interpreted as `y : x.Foo#A`
//│ ╔══[ERROR] Type `Foo['a]` does not contain member `A`
//│ ║  l.328: 	fun foo(x: Foo['a], y) = y : x.A  // interpreted as `y : x.Foo#A`
//│ ╙──       	                              ^^
//│ fun foo: forall 'a. (x: Foo['a], error) -> error

fun foo(x, y) = y : x.A
//│ fun foo: forall 'A 'A0. ({A :> 'A <: 'A0}, 'A) -> 'A0

// FIXME
fun bar(f: Foo['a], y) = foo(f, y)
//│ ╔══[ERROR] Type `Foo['a]` does not contain member `A`
//│ ║  l.334: 	fun foo(x, y) = y : x.A
//│ ╙──       	                     ^^
//│ fun bar: forall 'a. (f: Foo['a], error) -> error

class Bar(val A: Int)
//│ class Bar(A: Int)

class C[type A]: C1 | C2
class C1(val s: Bool) extends C[Bool]
class C2(val i: Int) extends C[Int]
//│ ╔══[WARNING] Self-type annotations have no effects on non-abstract class definitions
//│ ║  l.347: 	class C[type A]: C1 | C2
//│ ║         	                 ^^^^^^^
//│ ╙── Did you mean to use `extends` and inherit from a parent class?
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.347: 	class C[type A]: C1 | C2
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── expression of type `#C & {A = A}` does not match type `C1 | C2`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.347: 	class C[type A]: C1 | C2
//│ ╙──       	                 ^^^^^^^
//│ class C[A]: C1 | C2 {
//│   constructor()
//│ }
//│ class C1(s: Bool) extends C
//│ class C2(i: Int) extends C

let f = (t, x: t.A) => x + t.i
//│ let f: forall 'A. ({A :> 'A <: Int, i: Int}, x: 'A) -> Int

f(C2(1), 2)
//│ Int

let g = (t, x: t) => t && x
//│ let g: (Bool, x: Bool) -> Bool

class Foo(val x: C1) {
  fun foo(y: x.A) = y || y
}
//│ class Foo(x: C1) {
//│   fun foo: (y: Bool) -> Bool
//│ }

Foo(C1(false)).foo(true)
//│ Bool

:pe
class Foo[in type]
//│ ╔══[PARSE ERROR] dangling variance information
//│ ║  l.387: 	class Foo[in type]
//│ ╙──       	          ^^
//│ ╔══[PARSE ERROR] Unexpected 'type' keyword here
//│ ║  l.387: 	class Foo[in type]
//│ ╙──       	             ^^^^
//│ class Foo {
//│   constructor()
//│ }

:pe
class Foo[type]
//│ ╔══[PARSE ERROR] dangling visible type member
//│ ║  l.399: 	class Foo[type]
//│ ╙──       	          ^^^^
//│ class Foo {
//│   constructor()
//│ }

:pe
class Foo[type in]
//│ ╔══[PARSE ERROR] dangling type member and variance information
//│ ║  l.408: 	class Foo[type in]
//│ ╙──       	          ^^^^^^^
//│ class Foo {
//│   constructor()
//│ }

// FIXME
:pe
fun foo[type](x)
//│ ╔══[PARSE ERROR] Unexpected 'type' keyword in expression position
//│ ║  l.418: 	fun foo[type](x)
//│ ╙──       	        ^^^^
//│ ╔══[PARSE ERROR] Unexpected end of square bracket section; an expression was expected here
//│ ║  l.418: 	fun foo[type](x)
//│ ╙──       	            ^
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing

