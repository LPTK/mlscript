:NewDefs

abstract class R[type A]: RI | RB | RC
class RI(x: Int) extends R[Int]
class RB(x: Bool) extends R[Bool]
class RC(x: Str) extends R[Str]
//│ abstract class R[A]: RB | RC | RI
//│ class RI(x: Int) extends R
//│ class RB(x: Bool) extends R
//│ class RC(x: Str) extends R

fun req[A](x: R[A], y: R[A]): Bool = if x is RI(a) and y is RI(b) then a == b else false
//│ fun req: forall 'A. (x: R['A], y: R['A]) -> Bool

fun f1[A](e: R[A]) = [ if e is RI(i) then i as e.A else error , if e is RB(i) then i as e.A else error , if e is RC(i) then i as e.A else error ]
//│ fun f1: forall 'A. (e: R['A]) -> [Int & 'A | Str | false | true]

fun h1[A](x: R[A], y: A) = (if x is
    RI(_) then RI as (x.A => R[x.A])
    RB(_) then RB as (x.A => R[x.A])
    else error
  ) (y as x.A)
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: Program reached and unexpected state.
//│ 	at: mlscript.utils.package$.lastWords(package.scala:209)
//│ 	at: mlscript.utils.package$.die(package.scala:208)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:772)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:760)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$108(TypeSimplifier.scala:449)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:32)
//│ 	at: mlscript.TypeSimplifier.go$1(TypeSimplifier.scala:453)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$11(TypeSimplifier.scala:222)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.$anonfun$mapTargs2$3(TyperHelpers.scala:1255)
//│ 	at: scala.collection.LazyZip2$$anon$1$$anon$2.next(LazyZipOps.scala:42)

h1(RI(1), 1)
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: Program reached and unexpected state.
//│ 	at: mlscript.utils.package$.lastWords(package.scala:209)
//│ 	at: mlscript.utils.package$.die(package.scala:208)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:772)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:760)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$108(TypeSimplifier.scala:449)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:32)
//│ 	at: mlscript.TypeSimplifier.go$1(TypeSimplifier.scala:453)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$11(TypeSimplifier.scala:222)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.$anonfun$mapTargs2$3(TyperHelpers.scala:1255)
//│ 	at: scala.collection.LazyZip2$$anon$1$$anon$2.next(LazyZipOps.scala:42)

:e
h1(RC("hi"), true)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.49: 	h1(RC("hi"), true)
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `true` is not an instance of `Str`
//│ ║  l.49: 	h1(RC("hi"), true)
//│ ║        	             ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.6: 	class RC(x: Str) extends R[Str]
//│ ║       	                           ^^^
//│ ╟── Note: method type parameter A is defined at:
//│ ║  l.18: 	fun h1[A](x: R[A], y: A) = (if x is
//│ ╙──      	       ^
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: Program reached and unexpected state.
//│ 	at: mlscript.utils.package$.lastWords(package.scala:209)
//│ 	at: mlscript.utils.package$.die(package.scala:208)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:772)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:760)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$108(TypeSimplifier.scala:449)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:32)
//│ 	at: mlscript.TypeSimplifier.go$1(TypeSimplifier.scala:453)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$11(TypeSimplifier.scala:222)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.$anonfun$mapTargs2$3(TyperHelpers.scala:1255)
//│ 	at: scala.collection.LazyZip2$$anon$1$$anon$2.next(LazyZipOps.scala:42)

fun h2[A](x: R[A], y: R[A]) = (if x is
    RI(_) then RI as (x.A => R[x.A])
    RB(_) then RB as (x.A => R[x.A])
    else error
  ) (if y is
    RI(a) then (a as y.A) as x.A
    RB(a) then (a as y.A) as x.A
    else error
  )
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: Program reached and unexpected state.
//│ 	at: mlscript.utils.package$.lastWords(package.scala:209)
//│ 	at: mlscript.utils.package$.die(package.scala:208)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:772)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:760)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$108(TypeSimplifier.scala:449)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:32)
//│ 	at: mlscript.TypeSimplifier.go$1(TypeSimplifier.scala:453)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$11(TypeSimplifier.scala:222)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.$anonfun$mapTargs2$3(TyperHelpers.scala:1255)
//│ 	at: scala.collection.LazyZip2$$anon$1$$anon$2.next(LazyZipOps.scala:42)

h2(RI(1), RI(2))
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: Program reached and unexpected state.
//│ 	at: mlscript.utils.package$.lastWords(package.scala:209)
//│ 	at: mlscript.utils.package$.die(package.scala:208)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:772)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:760)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$108(TypeSimplifier.scala:449)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:32)
//│ 	at: mlscript.TypeSimplifier.go$1(TypeSimplifier.scala:453)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$11(TypeSimplifier.scala:222)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.$anonfun$mapTargs2$3(TyperHelpers.scala:1255)
//│ 	at: scala.collection.LazyZip2$$anon$1$$anon$2.next(LazyZipOps.scala:42)

:e
h2(RB(true), RI(0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.109: 	h2(RB(true), RI(0))
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Int` is not an instance of type `Bool`
//│ ║  l.4: 	class RI(x: Int) extends R[Int]
//│ ║       	                           ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.5: 	class RB(x: Bool) extends R[Bool]
//│ ║       	                            ^^^^
//│ ╟── Note: method type parameter A is defined at:
//│ ║  l.74: 	fun h2[A](x: R[A], y: R[A]) = (if x is
//│ ╙──      	       ^
//│ error
//│ Code generation encountered an error:
//│   unresolved symbol h2

abstract class Eq[type A, type B]: Refl[A]
class Refl[A]() extends Eq[A, A]
//│ abstract class Eq[A, B]: Refl[A]
//│ class Refl[A]() extends Eq

fun e1[A, B](e: Eq[A, B], x: A): B = if e is Refl() then (x as e.A) as e.B
//│ fun e1: forall 'A 'B. (e: Eq['A, 'B], x: 'A) -> 'B

e1(Refl(), 1)
//│ 1
//│ res
//│     = 1

:e
Refl() : Eq[Int, Bool]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.140: 	Refl() : Eq[Int, Bool]
//│ ║         	^^^^^^
//│ ╙── expression of type `Int` does not match type `Bool`
//│ Eq[Int, Bool]
//│ res
//│     = Refl {}

fun e2[A, B, C](e1: Eq[A, B], e2: Eq[B, C], x: A): C =
  if e1 is Refl() and e2 is Refl() then
    (((x as e1.A) as e1.B) as e2.A) as e2.B
//│ fun e2: forall 'A 'B 'C. (e1: Eq['A, 'B], e2: Eq['B, 'C], x: 'A) -> 'C

e2(Refl(), Refl(), true)
//│ true
//│ res
//│     = true

