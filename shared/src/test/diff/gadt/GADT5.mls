:NewDefs

abstract class Option[out T]: None | Some[T]
class None extends Option[nothing]
class Some[A](get: A) extends Option[A]
//│ abstract class Option[T]: None | Some[T]
//│ class None extends Option {
//│   constructor()
//│ }
//│ class Some[A](get: A) extends Option

abstract class U[type A]: MkU
module MkU extends U[()]
//│ abstract class U[A]: MkU
//│ module MkU extends U

fun v1(u: U['a], a: ()) = if u is MkU then a
//│ fun v1: forall 'a. (u: U['a], a: ()) -> ()

fun v2(a, u: U['a]) = if u is MkU then if a is () then () as u.A
//│ fun v2: forall 'a. ((), u: U['a]) -> (() & 'a)

abstract class F[type A, type B]: MkF[A, B]
class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Z` is not an instance of type `Option`
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ║        	          ^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ║        	                                ^^^^^^^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.23: 	abstract class F[type A, type B]: MkF[A, B]
//│ ╙──      	                      ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Z` does not match type `None | Some[?T]`
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ║        	          ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.3: 	abstract class Option[out T]: None | Some[T]
//│ ║       	                              ^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ║        	                                ^^^^^^^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.23: 	abstract class F[type A, type B]: MkF[A, B]
//│ ╙──      	                      ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] Type `Z` does not contain member `Some#A`
//│ ║  l.5: 	class Some[A](get: A) extends Option[A]
//│ ╙──     	           ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Z` does not match type `None | Some[?T]`
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ║        	          ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.3: 	abstract class Option[out T]: None | Some[T]
//│ ║       	                              ^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ║        	                                ^^^^^^^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.23: 	abstract class F[type A, type B]: MkF[A, B]
//│ ╙──      	                      ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] Type `Z` does not contain member `Option#T`
//│ ║  l.3: 	abstract class Option[out T]: None | Some[T]
//│ ╙──     	                          ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `None & {Option#T <: Z} | Some[?T] & {Option#T <: Z}` does not match type `Z`
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ║        	                                ^^^^^^^^^
//│ ╟── Note: constraint arises from type parameter:
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ╙──      	          ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `None & {Option#T <: Z} | Some[?T] & {Option#T <: Z}` does not match type `Z`
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ║        	                                ^^^^^^^^^
//│ ╟── Note: constraint arises from type parameter:
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ╙──      	          ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ abstract class F[A, B]: MkF[A, B]
//│ class MkF[Z, Y](y: Y) extends F

let t = MkF(true)
t : F[Option[nothing], Bool]
//│ let t: forall 'Z. MkF['Z, Bool]
//│ F[Option[nothing], Bool]
//│ t
//│   = MkF {}
//│ res
//│     = MkF {}

let x: F[Option[nothing], Option[nothing]] = MkF(new None)
//│ let x: F[Option[nothing], Option[nothing]]
//│ x
//│   = MkF {}

:e
MkF(x) : F[Option[Int], Option[Int]]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.116: 	MkF(x) : F[Option[Int], Option[Int]]
//│ ║         	^^^^^^
//│ ╟── type `MkF[?A, ?B] & {B = Option[nothing], A = Option[nothing]}` is not an instance of type `Option`
//│ ║  l.110: 	let x: F[Option[nothing], Option[nothing]] = MkF(new None)
//│ ║         	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Option[anything]`
//│ ║  l.116: 	MkF(x) : F[Option[Int], Option[Int]]
//│ ║         	    ^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.116: 	MkF(x) : F[Option[Int], Option[Int]]
//│ ║         	                        ^^^^^^^^^^^
//│ ╟── Note: type parameter B is defined at:
//│ ║  l.23: 	abstract class F[type A, type B]: MkF[A, B]
//│ ╙──      	                              ^
//│ F[Option[Int], Option[Int]]
//│ res
//│     = MkF {}

fun g: forall 'T: F['T, 'T] -> 'T
fun g[T](x: F[T, T]): T = if x is
    MkF(m) then m : x.B
//│ fun g: forall 'T. (x: F['T, 'T]) -> 'T
//│ fun g: forall 'T0. F['T0, 'T0] -> 'T0

g(MkF(new None))
//│ None | Option[nothing]
//│ res
//│     = None {}

g(MkF(Some(1)))
//│ Option['Z] | Some['Z]
//│   where
//│     'Z :> 1
//│ res
//│     = Some {}

:e
g(MkF(1))
g(t)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.155: 	g(MkF(1))
//│ ║         	^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `Option`
//│ ║  l.155: 	g(MkF(1))
//│ ║         	      ^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ║        	                                ^^^^^^^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.23: 	abstract class F[type A, type B]: MkF[A, B]
//│ ╙──      	                      ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.156: 	g(t)
//│ ║         	^^^^
//│ ╟── type `None & {Option#T <: ?Z} | Some[?Z] & {Option#T <: ?Z}` does not match type `Bool`
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ║        	                                ^^^^^^^^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.136: 	fun g: forall 'T: F['T, 'T] -> 'T
//│ ║         	                        ^^
//│ ╟── from type variable:
//│ ║  l.136: 	fun g: forall 'T: F['T, 'T] -> 'T
//│ ╙──       	                    ^^
//│ error
//│ res
//│     = 1
//│ res
//│     = true

fun g[T](x: MkF[T, Option[T]]): Option[T] = if x is
    MkF(None) then new None : x.B
    else error
//│ fun g: forall 'T. (x: MkF['T, Option['T]]) -> Option['T]

g(MkF(new None))
//│ Option[nothing]
//│ res
//│     = None {}

// * nested pattern matching causes recursion depth limit ?

// FIXME
fun g[T](x: F[Option[T], Option[T]]): Option[T] = if x is
    MkF(None) then new None : x.B
    else error
//│ ╔══[ERROR] Subtyping constraint of the form `?B <: ?a` exceeded recursion depth limit (250)
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ fun g: forall 'T. (x: F[Option['T], Option['T]]) -> Option['T]

// FIXME
fun g: forall 'T: F['T, 'T] -> 'T
fun g[T](x: F[T, T]): T = if x is
    MkF(None) then new None : x.B
    else error
//│ ╔══[ERROR] Subtyping constraint of the form `?B <: ?a` exceeded recursion depth limit (250)
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.209: 	fun g[T](x: F[T, T]): T = if x is
//│ ║         	                             ^^^^
//│ ║  l.210: 	    MkF(None) then new None : x.B
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.211: 	    else error
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `T` does not match type `Object | ~(T & ??Y)`
//│ ║  l.209: 	fun g[T](x: F[T, T]): T = if x is
//│ ║         	      ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.210: 	    MkF(None) then new None : x.B
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.211: 	    else error
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── from field selection:
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ║        	                ^
//│ ╟── Note: type parameter Y is defined at:
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ╙──      	             ^
//│ fun g: forall 'T. (x: F['T, 'T]) -> 'T
//│ fun g: forall 'T0. F['T0, 'T0] -> 'T0

// FIXME
fun g: forall 'T: F['T, 'T] -> 'T
fun g[T](x: F[T, T]): T = if x is
    MkF(m) then if m is
        None then (new None) as x.B
        else error
//│ ╔══[ERROR] Subtyping constraint of the form `?B <: ?a` exceeded recursion depth limit (250)
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.240: 	fun g[T](x: F[T, T]): T = if x is
//│ ║         	                             ^^^^
//│ ║  l.241: 	    MkF(m) then if m is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.242: 	        None then (new None) as x.B
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.243: 	        else error
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── type `T` does not match type `Object | ~(T & ??Y)`
//│ ║  l.240: 	fun g[T](x: F[T, T]): T = if x is
//│ ║         	      ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.241: 	    MkF(m) then if m is
//│ ║         	                   ^^^^
//│ ║  l.242: 	        None then (new None) as x.B
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.243: 	        else error
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── from field selection:
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ║        	                ^
//│ ╟── Note: type parameter Y is defined at:
//│ ║  l.24: 	class MkF[Z, Y](y: Y) extends F[Option[Z], Y]
//│ ╙──      	             ^
//│ fun g: forall 'T. (x: F['T, 'T]) -> 'T
//│ fun g: forall 'T0. F['T0, 'T0] -> 'T0

abstract class Foo[type A, type B]: Bar
class Bar(val a: Option[Int]) extends Foo[Option[Int], Option[Int]]
//│ abstract class Foo[A, B]: Bar
//│ class Bar(a: Option[Int]) extends Foo

fun foo[T](x: Foo[T, T]): T = if x is
    Bar(Some(a)) then Some(a) as x.A
    Bar(None)    then (new None) as x.A
//│ fun foo: forall 'T. (x: Foo['T, 'T]) -> 'T
