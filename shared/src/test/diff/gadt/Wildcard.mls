:NewDefs

class Foo[type T](val x: T)
//│ class Foo[T](x: T)

fun foo(f: Foo[?]) = f
//│ fun foo: (f: Foo[?]) -> Foo[?]

foo(Foo(0))
//│ Foo[?]
//│ res
//│     = Foo {}

fun foo(f: Foo[?]) = 0
//│ fun foo: (f: Foo[?]) -> 0

let f: Foo[?] = Foo(1)
//│ let f: Foo[?]
//│ f
//│   = Foo {}

foo(f)
foo(Foo(1))
//│ 0
//│ res
//│     = 0
//│ res
//│     = 0

:e
let y: Foo[Foo[Int]]
let f: Foo[Foo[?]] = y
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.32: 	let f: Foo[Foo[?]] = y
//│ ║        	                     ^
//│ ╙── expression of type `Int` does not match type `nothing`
//│ let f: Foo[Foo[?]]
//│ let y: Foo[Foo[Int]]
//│ y
//│   = <missing implementation>
//│ f
//│   = <no result>
//│     y is not implemented

fun foo(f: Foo[?]) = f.x
//│ fun foo: (f: Foo[?]) -> anything

foo(Foo(Foo(1)))
foo(Foo(1))
//│ anything
//│ res
//│     = Foo {}
//│ res
//│     = 1

// TODO
fun foo(f: Foo[?]) = f.x as f.T
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.57: 	fun foo(f: Foo[?]) = f.x as f.T
//│ ║        	                     ^^^
//│ ╟── field selection of type `anything` does not match type `nothing`
//│ ╟── Note: constraint arises from type selection:
//│ ║  l.57: 	fun foo(f: Foo[?]) = f.x as f.T
//│ ╙──      	                             ^^
//│ fun foo: (f: Foo[?]) -> anything

fun foo(f: Foo[?]) = if f is Foo(x) then x as f.T
//│ fun foo: (f: Foo[?]) -> ??T

foo(Foo(1))
//│ ??T
//│ res
//│     = 1

class Foo[out T](val x: T)
//│ class Foo[T](x: T)

let f: Foo[?] = Foo(1)
//│ let f: Foo[anything]
//│ f
//│   = Foo {}

let f: Foo[Foo[?]] = Foo(Foo(1))
//│ let f: Foo[Foo[anything]]
//│ f
//│   = Foo {}

class Foo[in T](val x: T)
//│ class Foo[T](x: T)

let f: Foo[?] = Foo(1)
//│ let f: Foo[nothing]
//│ f
//│   = Foo {}

:e
let y: Foo[Foo[Int]]
let f: Foo[Foo[?]] = y
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.98: 	let f: Foo[Foo[?]] = y
//│ ║        	                     ^
//│ ╙── expression of type `Int` does not match type `nothing`
//│ let f: Foo[Foo[anything]]
//│ let y: Foo[Foo[Int]]
//│ y
//│   = <missing implementation>
//│ f
//│   = <no result>
//│     y is not implemented

abstract class Bar[type A]: MkBarInt | MkBarBool | MkBarFoo[?]
class MkBarInt() extends Bar[Int]
class MkBarBool() extends Bar[Bool]
class MkBarFoo[A](ev: A) extends Bar[Foo[A]]
//│ abstract class Bar[A]: MkBarBool | MkBarFoo[?] | MkBarInt
//│ class MkBarInt() extends Bar
//│ class MkBarBool() extends Bar
//│ class MkBarFoo[A](ev: A) extends Bar

fun bar(b: Bar[?]) = if b is
    MkBarInt then 1
    MkBarBool then 2
    MkBarFoo then 3
//│ fun bar: (b: Bar[?]) -> (1 | 2 | 3)

bar(MkBarInt())
bar(MkBarBool() as Bar[?])
bar(MkBarFoo("hello"))
bar(MkBarFoo(Foo(1)))
//│ 1 | 2 | 3
//│ res
//│     = 1
//│ res
//│     = 2
//│ res
//│     = 3
//│ res
//│     = 3

let x: Bar[?] = MkBarInt()
//│ let x: Bar[?]
//│ x
//│   = MkBarInt {}

:e
x as Bar[Bool]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.146: 	x as Bar[Bool]
//│ ║         	^
//│ ╟── type `anything` is not an instance of type `Bool`
//│ ║  l.140: 	let x: Bar[?] = MkBarInt()
//│ ║         	           ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.146: 	x as Bar[Bool]
//│ ╙──       	         ^^^^
//│ Bar[Bool]
//│ res
//│     = MkBarInt {}

MkBarFoo(Foo(1)) as Bar[Foo[Foo[Int]]]
//│ Bar[Foo[Foo[Int]]]
//│ res
//│     = MkBarFoo {}

MkBarFoo(Foo(1)) as Bar[?]
//│ Bar[?]
//│ res
//│     = MkBarFoo {}

:e
MkBarFoo(Foo(1)) as Bar[Foo[?]]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.171: 	MkBarFoo(Foo(1)) as Bar[Foo[?]]
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╙── expression of type `anything` does not match type `nothing`
//│ Bar[Foo[?]]
//│ res
//│     = MkBarFoo {}

:e
let x: Bar[Foo[?]] = MkBarFoo(1)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.181: 	let x: Bar[Foo[?]] = MkBarFoo(1)
//│ ║         	                     ^^^^^^^^^^^
//│ ╙── expression of type `anything` does not match type `nothing`
//│ let x: Bar[Foo[?]]
//│ x
//│   = MkBarFoo {}

let x: Bar[Foo[?]]
//│ let x: Bar[Foo[?]]
//│ x
//│   = <missing implementation>

:e
x as Bar[Foo[Int]]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.196: 	x as Bar[Foo[Int]]
//│ ║         	^
//│ ╙── expression of type `anything` is not an instance of type `Int`
//│ Bar[Foo[Int]]
//│ res
//│     = <no result>
//│       x is not implemented

abstract class C[type A]: MkC
class MkC() extends C[Int]
//│ abstract class C[A]: MkC
//│ class MkC() extends C

fun fc(c: C[?]) = if c is MkC then 1 as c.A
//│ fun fc: (c: C[?]) -> Int

fc(MkC())
//│ Int
//│ res
//│     = 1

abstract class Baz[type A]: BI | BB
class BI() extends Baz[Int]
class BB() extends Baz[Bool]
//│ abstract class Baz[A]: BB | BI
//│ class BI() extends Baz
//│ class BB() extends Baz

fun baz[T](b: Baz[T]): T = if b is
    BI then 1 as b.A
    BB then true as b.A
//│ fun baz: forall 'T. (b: Baz['T]) -> 'T

fun baz(b: Baz['a]): b.A = if b is
    BI then 1 as b.A
    BB then true as b.A
//│ fun baz: forall 'a. (b: Baz['a]) -> ('a & (Int | false | true))

fun baz(b: Baz[?]) = if b is
    BI then 1 as b.A
    BB then true as b.A
//│ fun baz: (b: Baz[?]) -> (Int | false | true)

// * Note: this didn't work before we pushed ascriptions in,
// * as we don't yet have proper path-dependent type forms like b.A, which is basically ? here.
fun baz(b: Baz[?]): b.A = if b is
    BI then 1 as b.A
    BB then true as b.A
//│ fun baz: (b: Baz[?]) -> (Int | false | true)

class Foo[T](val x: T)
//│ class Foo[T](x: T)

fun e: Foo[?]
fun f: Foo[?] -> Foo[?]
//│ fun e: Foo[?]
//│ fun f: Foo[?] -> Foo[?]

f(e)
//│ Foo[?]
//│ res
//│     = <no result>
//│       f is not implemented

fun e: Foo[Int]
fun f: Foo[?] -> Foo[?]
//│ fun e: Foo[Int]
//│ fun f: Foo[?] -> Foo[?]

f(e)
//│ Foo[?]
//│ res
//│     = <no result>
//│       f is not implemented

fun e: Foo[?]
fun f: Foo[Int] -> Foo[?]
//│ fun e: Foo[?]
//│ fun f: Foo[Int] -> Foo[?]

:e
e as Foo[Int]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.279: 	e as Foo[Int]
//│ ║         	^
//│ ╙── expression of type `anything` is not an instance of type `Int`
//│ Foo[Int]
//│ res
//│     = <no result>
//│       e is not implemented

:e
f(e)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.290: 	f(e)
//│ ║         	^^^^
//│ ╙── expression of type `anything` is not an instance of type `Int`
//│ Foo[?] | error
//│ res
//│     = <no result>
//│       f is not implemented

// TODO
fun f(x: ?) = x
//│ fun f: (x: nothing) -> anything

:e
f(1)
//│ ╔══[ERROR] Wildcards can only be use in type arguments
//│ ║  l.301: 	fun f(x: ?) = x
//│ ╙──       	         ^
//│ error
//│ res
//│     = 1

:e
f(f)
//│ ╔══[ERROR] Wildcards can only be use in type arguments
//│ ║  l.301: 	fun f(x: ?) = x
//│ ╙──       	         ^
//│ error
//│ res
//│     = [Function: f5]

:e
fun f(x): ? = x
//│ ╔══[ERROR] Wildcards can only be use in type arguments
//│ ║  l.323: 	fun f(x): ? = x
//│ ╙──       	          ^
//│ fun f: anything -> anything

:e
fun f(x: Int): ? = x
//│ ╔══[ERROR] Wildcards can only be use in type arguments
//│ ║  l.330: 	fun f(x: Int): ? = x
//│ ╙──       	               ^
//│ fun f: (x: Int) -> anything

// TODO
fun f(x: ?): ? = x
//│ fun f: (x: nothing) -> anything

:e
f(1)
//│ ╔══[ERROR] Wildcards can only be use in type arguments
//│ ║  l.337: 	fun f(x: ?): ? = x
//│ ╙──       	         ^
//│ error
//│ res
//│     = 1

:e
let x: ? = 1
//│ ╔══[ERROR] Wildcards can only be use in type arguments
//│ ║  l.350: 	let x: ? = 1
//│ ╙──       	       ^
//│ ╔══[ERROR] Wildcards can only be use in type arguments
//│ ║  l.350: 	let x: ? = 1
//│ ╙──       	       ^
//│ let x: anything
//│ x
//│   = 1

:e
1 as ?
//│ ╔══[ERROR] Wildcards can only be use in type arguments
//│ ║  l.362: 	1 as ?
//│ ╙──       	     ^
//│ anything
//│ res
//│     = 1

// TODO
fun f: (? -> ?) -> ?
//│ fun f: (anything -> nothing) -> anything

// TODO
fun f: ? -> ?
//│ fun f: nothing -> anything

// TODO
fun f: ? -> Int
//│ fun f: nothing -> Int

// TODO
fun f: Int -> ?
//│ fun f: Int -> anything

// TODO
let x: ? -> ?
//│ let x: nothing -> anything
//│ x
//│   = <missing implementation>

:e
let x = ?
//│ ╔══[ERROR] Cannot use ? as expression
//│ ║  l.393: 	let x = ?
//│ ╙──       	        ^
//│ let x: error
//│ Code generation encountered an error:
//│   cannot generate code for term WildcardType()

:e
if x is ? then 1
//│ ╔══[ERROR] illegal pattern
//│ ║  l.402: 	if x is ? then 1
//│ ╙──       	        ^
//│ error
//│ Code generation encountered an error:
//│   if expression was not desugared

:e
let x: ?[?]
//│ ╔══[ERROR] Wrong number of type arguments – expected 0, found 1
//│ ║  l.411: 	let x: ?[?]
//│ ╙──       	       ^^^^
//│ let x: ?
//│ x
//│   = <missing implementation>

:e
class Bar extends ?
//│ ╔══[ERROR] Unsupported parent specification
//│ ║  l.420: 	class Bar extends ?
//│ ╙──       	                  ^
//│ class Bar {
//│   constructor()
//│ }
//│ Code generation encountered an error:
//│   unsupported parents.

// FIXME
:e
abstract class Bar: ?
//│ ╔══[ERROR] Wildcards can only be use in type arguments
//│ ║  l.432: 	abstract class Bar: ?
//│ ╙──       	                    ^
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: Program reached and unexpected state.

:e
class ?
//│ ╔══[ERROR] Type name '?' is reserved
//│ ║  l.439: 	class ?
//│ ╙──       	^^^^^^^
//│ class ? {
//│   constructor()
//│ }
//│ Syntax error:
//│   Invalid or unexpected token

// TODO should we allow this?
fun (?) wc: Int -> Bool
//│ fun (?) wc: Int -> Bool
