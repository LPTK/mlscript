:NewDefs

class Foo[type T](val x: T)
//│ class Foo[T](x: T)

fun foo(f: Foo[?]) = f
//│ fun foo: (f: Foo[?]) -> Foo[?]

foo(Foo(0))
//│ Foo[?]
//│ res
//│     = Foo {}

fun foo(f: Foo[?]) = 0
//│ fun foo: (f: Foo[?]) -> 0

let f: Foo[?] = Foo(1)
//│ let f: Foo[?]
//│ f
//│   = Foo {}

foo(f)
foo(Foo(1))
//│ 0
//│ res
//│     = 0
//│ res
//│     = 0

:e
let y: Foo[Foo[Int]]
let f: Foo[Foo[?]] = y
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.32: 	let f: Foo[Foo[?]] = y
//│ ║        	                     ^
//│ ╙── expression of type `Int` does not match type `nothing`
//│ let f: Foo[Foo[?]]
//│ let y: Foo[Foo[Int]]
//│ y
//│   = <missing implementation>
//│ f
//│   = <no result>
//│     y is not implemented

fun foo(f: Foo[?]) = f.x
//│ fun foo: (f: Foo[?]) -> anything

foo(Foo(Foo(1)))
foo(Foo(1))
//│ anything
//│ res
//│     = Foo {}
//│ res
//│     = 1

fun foo(f: Foo[?]) = f.x as f.T
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.56: 	fun foo(f: Foo[?]) = f.x as f.T
//│ ║        	                     ^^^
//│ ╟── field selection of type `anything` does not match type `nothing`
//│ ╟── Note: constraint arises from type selection:
//│ ║  l.56: 	fun foo(f: Foo[?]) = f.x as f.T
//│ ╙──      	                             ^^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ fun foo: (f: Foo[?]) -> anything

class Foo[out T](val x: T)
//│ class Foo[T](x: T)

let f: Foo[?] = Foo(1)
//│ let f: Foo[anything]
//│ f
//│   = Foo {}

let f: Foo[Foo[?]] = Foo(Foo(1))
//│ let f: Foo[Foo[anything]]
//│ f
//│   = Foo {}

class Foo[in T](val x: T)
//│ class Foo[T](x: T)

let f: Foo[?] = Foo(1)
//│ let f: Foo[nothing]
//│ f
//│   = Foo {}

:e
let y: Foo[Foo[Int]]
let f: Foo[Foo[?]] = y
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.90: 	let f: Foo[Foo[?]] = y
//│ ║        	                     ^
//│ ╙── expression of type `Int` does not match type `nothing`
//│ let f: Foo[Foo[anything]]
//│ let y: Foo[Foo[Int]]
//│ y
//│   = <missing implementation>
//│ f
//│   = <no result>
//│     y is not implemented

abstract class Bar[type A]: MkBarInt | MkBarBool | MkBarFoo[?]
class MkBarInt() extends Bar[Int]
class MkBarBool() extends Bar[Bool]
class MkBarFoo[A](ev: A) extends Bar[Foo[A]]
//│ abstract class Bar[A]: MkBarBool | MkBarFoo[?] | MkBarInt
//│ class MkBarInt() extends Bar
//│ class MkBarBool() extends Bar
//│ class MkBarFoo[A](ev: A) extends Bar

fun bar(b: Bar[?]) = if b is
    MkBarInt then 1
    MkBarBool then 2
    MkBarFoo then 3
//│ fun bar: (b: Bar[?]) -> (1 | 2 | 3)

bar(MkBarInt())
bar(MkBarBool() as Bar[?])
bar(MkBarFoo("hello"))
bar(MkBarFoo(Foo(1)))
//│ 1 | 2 | 3
//│ res
//│     = 1
//│ res
//│     = 2
//│ res
//│     = 3
//│ res
//│     = 3


let x: Bar[?] = MkBarInt()
//│ let x: Bar[?]
//│ x
//│   = MkBarInt {}

:e
x as Bar[Bool]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.139: 	x as Bar[Bool]
//│ ║         	^
//│ ╟── type `anything` is not an instance of type `Bool`
//│ ║  l.133: 	let x: Bar[?] = MkBarInt()
//│ ║         	           ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.139: 	x as Bar[Bool]
//│ ╙──       	         ^^^^
//│ Bar[Bool]
//│ res
//│     = MkBarInt {}

MkBarFoo(Foo(1)) as Bar[Foo[Foo[Int]]]
//│ Bar[Foo[Foo[Int]]]
//│ res
//│     = MkBarFoo {}

MkBarFoo(Foo(1)) as Bar[?]
//│ Bar[?]
//│ res
//│     = MkBarFoo {}

:e
MkBarFoo(Foo(1)) as Bar[Foo[?]]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.164: 	MkBarFoo(Foo(1)) as Bar[Foo[?]]
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╙── expression of type `anything` does not match type `nothing`
//│ Bar[Foo[?]]
//│ res
//│     = MkBarFoo {}

:e
let x: Bar[Foo[?]] = MkBarFoo(1)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.174: 	let x: Bar[Foo[?]] = MkBarFoo(1)
//│ ║         	                     ^^^^^^^^^^^
//│ ╙── expression of type `anything` does not match type `nothing`
//│ let x: Bar[Foo[?]]
//│ x
//│   = MkBarFoo {}

let x: Bar[Foo[?]]
//│ let x: Bar[Foo[?]]
//│ x
//│   = <missing implementation>

:e
x as Bar[Foo[Int]]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.189: 	x as Bar[Foo[Int]]
//│ ║         	^
//│ ╙── expression of type `anything` is not an instance of type `Int`
//│ Bar[Foo[Int]]
//│ res
//│     = <no result>
//│       x is not implemented

abstract class Baz[type A]: BI | BB
class BI() extends Baz[Int]
class BB() extends Baz[Bool]
//│ abstract class Baz[A]: BB | BI
//│ class BI() extends Baz
//│ class BB() extends Baz

fun baz[T](b: Baz[T]): T = if b is
    BI then 1 as b.A
    BB then true as b.A
//│ fun baz: forall 'T. (b: Baz['T]) -> 'T

fun baz(b: Baz['a]): b.A = if b is
    BI then 1 as b.A
    BB then true as b.A
//│ fun baz: forall 'a. (b: Baz['a]) -> ('a & (Int | false | true))

fun baz(b: Baz[?]): b.A = if b is
    BI then 1 as b.A
    BB then true as b.A
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.216: 	fun baz(b: Baz[?]): b.A = if b is
//│ ║         	                             ^^^^
//│ ║  l.217: 	    BI then 1 as b.A
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.218: 	    BB then true as b.A
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── type `Int` is not an instance of type `Bool`
//│ ║  l.200: 	class BI() extends Baz[Int]
//│ ║         	                       ^^^
//│ ╟── but it flows into type selection with expected type `Bool`
//│ ║  l.217: 	    BI then 1 as b.A
//│ ║         	                  ^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.201: 	class BB() extends Baz[Bool]
//│ ║         	                       ^^^^
//│ ╟── from type selection:
//│ ║  l.216: 	fun baz(b: Baz[?]): b.A = if b is
//│ ╙──       	                     ^^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ fun baz: (b: Baz[?]) -> (Int | false | true)

class Foo[T](val x: T)
//│ class Foo[T](x: T)

fun e: Foo[?]
fun f: Foo[?] -> Foo[?]
//│ fun e: Foo[?]
//│ fun f: Foo[?] -> Foo[?]

f(e)
//│ Foo[?]
//│ res
//│     = <no result>
//│       f is not implemented

fun e: Foo[Int]
fun f: Foo[?] -> Foo[?]
//│ fun e: Foo[Int]
//│ fun f: Foo[?] -> Foo[?]

f(e)
//│ Foo[?]
//│ res
//│     = <no result>
//│       f is not implemented

fun e: Foo[?]
fun f: Foo[Int] -> Foo[?]
//│ fun e: Foo[?]
//│ fun f: Foo[Int] -> Foo[?]

:e
e as Foo[Int]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.272: 	e as Foo[Int]
//│ ║         	^
//│ ╙── expression of type `anything` is not an instance of type `Int`
//│ Foo[Int]
//│ res
//│     = <no result>
//│       e is not implemented

:e
f(e)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.283: 	f(e)
//│ ║         	^^^^
//│ ╙── expression of type `anything` is not an instance of type `Int`
//│ Foo[?] | error
//│ res
//│     = <no result>
//│       f is not implemented

// TODO
fun f(x: ?) = x
//│ fun f: (x: nothing) -> anything

:e
f(1)
//│ ╔══[ERROR] Wildcards can only be use in type arguments
//│ ║  l.294: 	fun f(x: ?) = x
//│ ╙──       	         ^
//│ error
//│ res
//│     = 1

:e
f(f)
//│ ╔══[ERROR] Wildcards can only be use in type arguments
//│ ║  l.294: 	fun f(x: ?) = x
//│ ╙──       	         ^
//│ error
//│ res
//│     = [Function: f5]

:e
fun f(x): ? = x
//│ ╔══[ERROR] Wildcards can only be use in type arguments
//│ ║  l.316: 	fun f(x): ? = x
//│ ╙──       	          ^
//│ fun f: anything -> anything

:e
fun f(x: Int): ? = x
//│ ╔══[ERROR] Wildcards can only be use in type arguments
//│ ║  l.323: 	fun f(x: Int): ? = x
//│ ╙──       	               ^
//│ fun f: (x: Int) -> anything

// TODO
fun f(x: ?): ? = x
//│ fun f: (x: nothing) -> anything

:e
f(1)
//│ ╔══[ERROR] Wildcards can only be use in type arguments
//│ ║  l.330: 	fun f(x: ?): ? = x
//│ ╙──       	         ^
//│ error
//│ res
//│     = 1

:e
let x: ? = 1
//│ ╔══[ERROR] Wildcards can only be use in type arguments
//│ ║  l.343: 	let x: ? = 1
//│ ╙──       	       ^
//│ ╔══[ERROR] Wildcards can only be use in type arguments
//│ ║  l.343: 	let x: ? = 1
//│ ╙──       	       ^
//│ let x: anything
//│ x
//│   = 1

:e
1 as ?
//│ ╔══[ERROR] Wildcards can only be use in type arguments
//│ ║  l.355: 	1 as ?
//│ ╙──       	     ^
//│ anything
//│ res
//│     = 1

// TODO
fun f: (? -> ?) -> ?
//│ fun f: (anything -> nothing) -> anything

// TODO
fun f: ? -> ?
//│ fun f: nothing -> anything

// TODO
fun f: ? -> Int
//│ fun f: nothing -> Int

// TODO
fun f: Int -> ?
//│ fun f: Int -> anything

// TODO
let x: ? -> ?
//│ let x: nothing -> anything
//│ x
//│   = <missing implementation>

:e
let x = ?
//│ ╔══[ERROR] Cannot use ? as expression
//│ ║  l.386: 	let x = ?
//│ ╙──       	        ^
//│ let x: error
//│ Code generation encountered an error:
//│   cannot generate code for term WildcardType()

:e
if x is ? then 1
//│ ╔══[ERROR] illegal pattern
//│ ║  l.395: 	if x is ? then 1
//│ ╙──       	        ^
//│ error
//│ Code generation encountered an error:
//│   if expression was not desugared

:e
let x: ?[?]
//│ ╔══[ERROR] Wrong number of type arguments – expected 0, found 1
//│ ║  l.404: 	let x: ?[?]
//│ ╙──       	       ^^^^
//│ let x: ?
//│ x
//│   = <missing implementation>
