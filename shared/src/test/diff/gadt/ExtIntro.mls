:NewDefs
:DontDistributeForalls

class Z 
class S[type P]
//│ class Z {
//│   constructor()
//│ }
//│ class S[P] {
//│   constructor()
//│ }

abstract class K[type T]: KS[?]
class KS[A](ev: K[A]) extends K[S[A]]
//│ abstract class K[T]: KS[?]
//│ class KS[A](ev: K[A]) extends K

:d
fun fr: (K['L], K['L]) -> Int
fun fr[L](l: K[L], r: K[L]) =
  if l is KS(e1) and r is KS(e2) then fr(e1, e2) else 0
//│ 0. Typing TypingUnit(List(NuFunDef(None,Var(fr),None,List(),Right(PolyType(List(),Function(Tuple(List((None,Field(None,AppliedType(TypeName(K),List('L)))), (None,Field(None,AppliedType(TypeName(K),List('L)))))),TypeName(Int))))), NuFunDef(None,Var(fr),None,List(TypeName(L)),Left(Lam(Tup(List((Some(Var(l)),Fld(_,TyApp(Var(K),List(TypeName(L))))), (Some(Var(r)),Fld(_,TyApp(Var(K),List(TypeName(L))))))),Blk(List(If(IfThen(App(Var(and),Tup(List((None,Fld(_,App(Var(is),Tup(List((None,Fld(_,Var(l))), (None,Fld(_,App(Var(KS),Tup(List((None,Fld(_,Var(e1))))))))))))), (None,Fld(_,App(Var(is),Tup(List((None,Fld(_,Var(r))), (None,Fld(_,App(Var(KS),Tup(List((None,Fld(_,Var(e2)))))))))))))))),App(Var(fr),Tup(List((None,Fld(_,Var(e1))), (None,Fld(_,Var(e2))))))),Some(IntLit(0))))))))))
//│ | 0. Created lazy type info for NuFunDef(None,Var(fr),None,List(),Right(PolyType(List(),Function(Tuple(List((None,Field(None,AppliedType(TypeName(K),List('L)))), (None,Field(None,AppliedType(TypeName(K),List('L)))))),TypeName(Int)))))
//│ | 0. Created lazy type info for NuFunDef(None,Var(fr),None,List(TypeName(L)),Left(Lam(Tup(List((Some(Var(l)),Fld(_,TyApp(Var(K),List(TypeName(L))))), (Some(Var(r)),Fld(_,TyApp(Var(K),List(TypeName(L))))))),Blk(List(If(IfThen(App(Var(and),Tup(List((None,Fld(_,App(Var(is),Tup(List((None,Fld(_,Var(l))), (None,Fld(_,App(Var(KS),Tup(List((None,Fld(_,Var(e1))))))))))))), (None,Fld(_,App(Var(is),Tup(List((None,Fld(_,Var(r))), (None,Fld(_,App(Var(KS),Tup(List((None,Fld(_,Var(e2)))))))))))))))),App(Var(fr),Tup(List((None,Fld(_,Var(e1))), (None,Fld(_,Var(e2))))))),Some(IntLit(0))))))))
//│ | Completing fun fr: (K['L], K['L]) -> Int
//│ | | Type params 
//│ | | Params 
//│ | | Typing type Function(Tuple(List((None,Field(None,AppliedType(TypeName(K),List('L)))), (None,Field(None,AppliedType(TypeName(K),List('L)))))),TypeName(Int))
//│ | | | vars=Map() newDefsInfo=Map()
//│ | | | 1. type Function(Tuple(List((None,Field(None,AppliedType(TypeName(K),List('L)))), (None,Field(None,AppliedType(TypeName(K),List('L)))))),TypeName(Int))
//│ | | | | 1. type Tuple(List((None,Field(None,AppliedType(TypeName(K),List('L)))), (None,Field(None,AppliedType(TypeName(K),List('L))))))
//│ | | | | | 1. type AppliedType(TypeName(K),List('L))
//│ | | | | | | 1. type 'L
//│ | | | | | | => 'L52'
//│ | | | | | => K['L52']
//│ | | | | | 1. type AppliedType(TypeName(K),List('L))
//│ | | | | | | 1. type 'L
//│ | | | | | | => 'L52'
//│ | | | | | => K['L52']
//│ | | | | => (K['L52'], K['L52'],)
//│ | | | | 1. type TypeName(Int)
//│ | | | | => Int
//│ | | | => ((K['L52'], K['L52'],) -> Int)
//│ | | => ((K['L52'], K['L52'],) -> Int) ——— 'L52'
//│ | | Inferred poly constr: ((K['L52'], K['L52'],) -> Int)  —— where 
//│ | | Type fr polymorphically? true && (0 === 0 || false || false
//│ | | CONSTRAIN ‹∀ 0. ‹∀ 0. ((K['L52'], K['L52'],) -> Int)›› <! fr53'
//│ | |   where 
//│ | | 1. C ‹∀ 0. ‹∀ 0. ((K['L52'], K['L52'],) -> Int)›› <! fr53'    (0)
//│ | | | NEW fr53' LB (0)
//│ | Completed TypedNuFun(0,NuFunDef(None,Var(fr),None,List(),Right(PolyType(List(),Function(Tuple(List((None,Field(None,AppliedType(TypeName(K),List('L)))), (None,Field(None,AppliedType(TypeName(K),List('L)))))),TypeName(Int))))),‹∀ 0. ‹∀ 0. ((K['L52'], K['L52'],) -> Int)››) where 
//│ | Completing fun fr = (l: K‹L›, r: K‹L›,) => {if (and(is(l, KS(e1,),), is(r, KS(e2,),),)) then fr(e1, e2,) else 0}
//│ | | Type params (TypeName(L),L54',TypeParamInfo(None,false,None,None))
//│ | | Params 
//│ | | Type fr polymorphically? true && (0 === 0 || true || false
//│ | | 1. Typing term (l: K‹L›, r: K‹L›,) => {if (and(is(l, KS(e1,),), is(r, KS(e2,),),)) then fr(e1, e2,) else 0}
//│ | | | 1. Typing pattern [l: K‹L›, r: K‹L›,]
//│ | | | | 1. Typing pattern l : K[L]
//│ | | | | | Typing type AppliedType(TypeName(K),List(TypeName(L)))
//│ | | | | | | vars=Map(L -> ‘L54') newDefsInfo=Map()
//│ | | | | | | 1. type AppliedType(TypeName(K),List(TypeName(L)))
//│ | | | | | | | 1. type TypeName(L)
//│ | | | | | | | => ‘L54'
//│ | | | | | | => K[‘L54']
//│ | | | | | => K[‘L54'] ——— 
//│ | | | | 1. : K[‘L54']
//│ | | | | 1. Typing pattern r : K[L]
//│ | | | | | Typing type AppliedType(TypeName(K),List(TypeName(L)))
//│ | | | | | | vars=Map(L -> ‘L54') newDefsInfo=Map()
//│ | | | | | | 1. type AppliedType(TypeName(K),List(TypeName(L)))
//│ | | | | | | | 1. type TypeName(L)
//│ | | | | | | | => ‘L54'
//│ | | | | | | => K[‘L54']
//│ | | | | | => K[‘L54'] ——— 
//│ | | | | 1. : K[‘L54']
//│ | | | 1. : (l: K[‘L54'], r: K[‘L54'],)
//│ | | | 1. Typing term {if (and(is(l, KS(e1,),), is(r, KS(e2,),),)) then fr(e1, e2,) else 0}
//│ | | | | 1. Typing term if (and(is(l, KS(e1,),), is(r, KS(e2,),),)) then fr(e1, e2,) else 0
//│ | | | | | [Desugarer.destructPattern] scrutinee = Var(l); pattern = App(Var(KS),Tup(List((None,Fld(_,Var(e1))))))
//│ | | | | | [Desugarer.destructPattern] Result: «l is Var(KS)»
//│ | | | | | [Desugarer.destructPattern] scrutinee = Var(r); pattern = App(Var(KS),Tup(List((None,Fld(_,Var(e2))))))
//│ | | | | | [Desugarer.destructPattern] Result: «r is Var(KS)»
//│ | | | | | Desugared term: case l of { KS => (([e1,],) => case r of { KS => (([e2,],) => fr(e1, e2,))((KS).unapply(r,),); _ => 0 })((KS).unapply(l,),); _ => 0 }
//│ | | | | | 1. Typing term case l of { KS => (([e1,],) => case r of { KS => (([e2,],) => fr(e1, e2,))((KS).unapply(r,),); _ => 0 })((KS).unapply(l,),); _ => 0 }
//│ | | | | | | 1. Typing term l
//│ | | | | | | 1. : K[‘L54']
//│ | | | | | | CONSTRAIN K[‘L54'] <! Object
//│ | | | | | |   where 
//│ | | | | | | 1. C K[‘L54'] <! Object    (0)
//│ | | | | | | | Assigning T :: T36' := ‘L54' where 
//│ | | | | | | | Set T36_55' ~> T36'
//│ | | | | | | | Assigned Some(‘L54')
//│ | | | | | | | 1. C ((#K<Object> & KS[? :> ⊥ <: ⊤]) & {T: mut ‘L54'..‘L54'}) <! #Object<>    (2)
//│ | | | | | | | | Already a subtype by <:<
//│ | | | | | | Match arm KS: #KS<Object,K> & {KS#A: mut A39_56'..A39_57'} intl {KS#A: mut (A39_56' | ‘A58'')..(A39_57' & ‘A58'')}
//│ | | | | | | var rfn: l :: K[‘L54'] & #KS<Object,K> & {KS#A: mut (A39_56' | ‘A58'')..(A39_57' & ‘A58'')}
//│ | | | | | | 2. Typing term (([e1,],) => case r of { KS => (([e2,],) => fr(e1, e2,))((KS).unapply(r,),); _ => 0 })((KS).unapply(l,),)
//│ | | | | | | | 2. Typing term ([e1,],) => case r of { KS => (([e2,],) => fr(e1, e2,))((KS).unapply(r,),); _ => 0 }
//│ | | | | | | | | 2. Typing pattern [[e1,],]
//│ | | | | | | | | | 2. Typing pattern [e1,]
//│ | | | | | | | | | | 2. Typing pattern e1
//│ | | | | | | | | | | 2. : e160''
//│ | | | | | | | | | 2. : (e160'',)
//│ | | | | | | | | 2. : ((e160'',),)
//│ | | | | | | | | 2. Typing term case r of { KS => (([e2,],) => fr(e1, e2,))((KS).unapply(r,),); _ => 0 }
//│ | | | | | | | | | 2. Typing term r
//│ | | | | | | | | | 2. : K[‘L54']
//│ | | | | | | | | | CONSTRAIN K[‘L54'] <! Object
//│ | | | | | | | | |   where 
//│ | | | | | | | | | 2. C K[‘L54'] <! Object    (0)
//│ | | | | | | | | | | Assigning T :: T36' := ‘L54' where 
//│ | | | | | | | | | | Set T36_61' ~> T36'
//│ | | | | | | | | | | Assigned Some(‘L54')
//│ | | | | | | | | | | 2. C ((#K<Object> & KS[? :> ⊥ <: ⊤]) & {T: mut ‘L54'..‘L54'}) <! #Object<>    (2)
//│ | | | | | | | | | | | Already a subtype by <:<
//│ | | | | | | | | | Match arm KS: #KS<Object,K> & {KS#A: mut A39_62''..A39_63''} intl {KS#A: mut (A39_62'' | ‘A64''')..(A39_63'' & ‘A64''')}
//│ | | | | | | | | | var rfn: r :: K[‘L54'] & #KS<Object,K> & {KS#A: mut (A39_62'' | ‘A64''')..(A39_63'' & ‘A64''')}
//│ | | | | | | | | | 3. Typing term (([e2,],) => fr(e1, e2,))((KS).unapply(r,),)
//│ | | | | | | | | | | 3. Typing term ([e2,],) => fr(e1, e2,)
//│ | | | | | | | | | | | 3. Typing pattern [[e2,],]
//│ | | | | | | | | | | | | 3. Typing pattern [e2,]
//│ | | | | | | | | | | | | | 3. Typing pattern e2
//│ | | | | | | | | | | | | | 3. : e266'''
//│ | | | | | | | | | | | | 3. : (e266''',)
//│ | | | | | | | | | | | 3. : ((e266''',),)
//│ | | | | | | | | | | | 3. Typing term fr(e1, e2,)
//│ | | | | | | | | | | | | 3. Typing term fr
//│ | | | | | | | | | | | | 3. : ‹∀ 0. ‹∀ 0. ((K['L52'], K['L52'],) -> Int)››
//│ | | | | | | | | | | | | 3. Typing term e1
//│ | | | | | | | | | | | | 3. : e160''
//│ | | | | | | | | | | | | 3. Typing term e2
//│ | | | | | | | | | | | | 3. : e266'''
//│ | | | | | | | | | | | | CONSTRAIN ‹∀ 0. ‹∀ 0. ((K['L52'], K['L52'],) -> Int)›› <! ((e160'', e266''',) -> α67''')
//│ | | | | | | | | | | | |   where 
//│ | | | | | | | | | | | | 3. C ‹∀ 0. ‹∀ 0. ((K['L52'], K['L52'],) -> Int)›› <! ((e160'', e266''',) -> α67''')    (0)
//│ | | | | | | | | | | | | | 3. C ‹∀ 0. ((K['L52'], K['L52'],) -> Int)› <! ((e160'', e266''',) -> α67''')    (2)
//│ | | | | | | | | | | | | | | INST [0]   ‹∀ 0. ((K['L52'], K['L52'],) -> Int)›
//│ | | | | | | | | | | | | | |   where  
//│ | | | | | | | | | | | | | | TO [3] ~>  ((K['L52_68'''], K['L52_68'''],) -> Int)
//│ | | | | | | | | | | | | | |   where  
//│ | | | | | | | | | | | | | | 3. C ((K['L52_68'''], K['L52_68'''],) -> Int) <! ((e160'', e266''',) -> α67''')    (4)
//│ | | | | | | | | | | | | | | | 3. C (e160'', e266''',) <! (K['L52_68'''], K['L52_68'''],)    (3)
//│ | | | | | | | | | | | | | | | | 3. C e160'' <! K['L52_68''']    (4)
//│ | | | | | | | | | | | | | | | | | wrong level: 3
//│ | | | | | | | | | | | | | | | | | EXTR[-] K['L52_68'''] || 2 .. 1024  3 false
//│ | | | | | | | | | | | | | | | | | | EXTR[+] 'L52_68''' || 2 .. 1024  3 false
//│ | | | | | | | | | | | | | | | | | | => 'L52_69''
//│ | | | | | | | | | | | | | | | | | | EXTR[-] 'L52_68''' || 2 .. 1024  3 false
//│ | | | | | | | | | | | | | | | | | | | EXTR[-] 'L52_69'' || 2 .. 1024  2 true
//│ | | | | | | | | | | | | | | | | | | | => 'L52_69''
//│ | | | | | | | | | | | | | | | | | | => 'L52_70''
//│ | | | | | | | | | | | | | | | | | => K[? :> 'L52_69'' <: 'L52_70'']
//│ | | | | | | | | | | | | | | | | | RECONSTRAINING TVs
//│ | | | | | | | | | | | | | | | | | | Reconstraining 'L52_69''
//│ | | | | | | | | | | | | | | | | | | Reconstraining 'L52_70''
//│ | | | | | | | | | | | | | | | | | EXTR RHS  ~>  K[? :> 'L52_69'' <: 'L52_70'']  to 2
//│ | | | | | | | | | | | | | | | | |  where 
//│ 		'L52_70'' <: 'L52_69''
//│ | | | | | | | | | | | | | | | | | 3. C e160'' <! K[? :> 'L52_69'' <: 'L52_70'']    (7)
//│ | | | | | | | | | | | | | | | | | | NEW e160'' UB (2)
//│ | | | | | | | | | | | | | | | | 3. C e266''' <! K['L52_68''']    (4)
//│ | | | | | | | | | | | | | | | | | NEW e266''' UB (3)
//│ | | | | | | | | | | | | | | | 3. C Int <! α67'''    (3)
//│ | | | | | | | | | | | | | | | | NEW α67''' LB (0)
//│ | | | | | | | | | | | 3. : α67'''
//│ | | | | | | | | | | 3. : ([e266''',] -> α67''')
//│ | | | | | | | | | | 3. Typing term (KS).unapply(r,)
//│ | | | | | | | | | | | 3. Typing term (KS).unapply
//│ | | | | | | | | | | | | 3. Typing term (x,) => let _ = x : KS in [(x).#ev,]
//│ | | | | | | | | | | | | | TYPING POLY LAM
//│ | | | | | | | | | | | | | 4. Typing pattern [x,]
//│ | | | | | | | | | | | | | | 4. Typing pattern x
//│ | | | | | | | | | | | | | | 4. : x71''''
//│ | | | | | | | | | | | | | 4. : (x71'''',)
//│ | | | | | | | | | | | | | 4. Typing term let _ = x : KS in [(x).#ev,]
//│ | | | | | | | | | | | | | | 4. Typing term x : KS
//│ | | | | | | | | | | | | | | | 4. Typing term x
//│ | | | | | | | | | | | | | | | 4. : x71''''
//│ | | | | | | | | | | | | | | | Typing type TypeName(KS)
//│ | | | | | | | | | | | | | | | | vars=Map(L -> ‘L54') newDefsInfo=Map()
//│ | | | | | | | | | | | | | | | | 4. type TypeName(KS)
//│ | | | | | | | | | | | | | | | | => #KS<Object,K>
//│ | | | | | | | | | | | | | | | => #KS<Object,K> ——— 
//│ | | | | | | | | | | | | | | | CONSTRAIN x71'''' <! #KS<Object,K>
//│ | | | | | | | | | | | | | | |   where 
//│ | | | | | | | | | | | | | | | 4. C x71'''' <! #KS<Object,K>    (0)
//│ | | | | | | | | | | | | | | | | NEW x71'''' UB (0)
//│ | | | | | | | | | | | | | | 4. : #KS<Object,K>
//│ | | | | | | | | | | | | | | 4. Typing term [(x).#ev,]
//│ | | | | | | | | | | | | | | | 4. Typing term (x).#ev
//│ | | | | | | | | | | | | | | | | 4. Typing term x
//│ | | | | | | | | | | | | | | | | 4. : x71''''
//│ | | | | | | | | | | | | | | | | CONSTRAIN x71'''' <! {#ev: #ev72''''}
//│ | | | | | | | | | | | | | | | |   where 
//│ 		x71'''' <: #KS<Object,K>
//│ | | | | | | | | | | | | | | | | 4. C x71'''' <! {#ev: #ev72''''}    (0)
//│ | | | | | | | | | | | | | | | | | NEW x71'''' UB (4)
//│ | | | | | | | | | | | | | | | 4. : #ev72''''
//│ | | | | | | | | | | | | | | 4. : (#ev72'''',)
//│ | | | | | | | | | | | | | 4. : (#ev72'''',)
//│ | | | | | | | | | | | | | Inferred poly constr: (x71'''' -> (#ev72'''',))  —— where 
//│ 		x71'''' <: {#ev: #ev72''''} & #KS<Object,K>
//│ | | | | | | | | | | | | 3. : ‹∀ 3. (x71'''' -> (#ev72'''',))›
//│ | | | | | | | | | | | 3. : ‹∀ 3. (x71'''' -> (#ev72'''',))›
//│ | | | | | | | | | | | 3. Typing term r
//│ | | | | | | | | | | | 3. : ((K[‘L54'] & #KS<Object,K>) & {KS#A: mut (A39_62'' | ‘A64''')..(A39_63'' & ‘A64''')})
//│ | | | | | | | | | | | CONSTRAIN ‹∀ 3. (x71'''' -> (#ev72'''',))› <! (((K[‘L54'] & #KS<Object,K>) & {KS#A: mut (A39_62'' | ‘A64''')..(A39_63'' & ‘A64''')}) -> α73''')
//│ | | | | | | | | | | |   where 
//│ 		A39_62'' <: A39_63''
//│ 		x71'''' <: {#ev: #ev72''''} & #KS<Object,K>
//│ | | | | | | | | | | | 3. C ‹∀ 3. (x71'''' -> (#ev72'''',))› <! (((K[‘L54'] & #KS<Object,K>) & {KS#A: mut (A39_62'' | ‘A64''')..(A39_63'' & ‘A64''')}) -> α73''')    (0)
//│ | | | | | | | | | | | | INST [3]   ‹∀ 3. (x71'''' -> (#ev72'''',))›
//│ | | | | | | | | | | | |   where  
//│ 		x71'''' <: {#ev: #ev72''''} & #KS<Object,K>
//│ | | | | | | | | | | | | TO [3] ~>  (x71_74''' -> (#ev72_75''',))
//│ | | | | | | | | | | | |   where  
//│ 		x71_74''' <: {#ev: #ev72_75'''} & #KS<Object,K>
//│ | | | | | | | | | | | | 3. C (x71_74''' -> (#ev72_75''',)) <! (((K[‘L54'] & #KS<Object,K>) & {KS#A: mut (A39_62'' | ‘A64''')..(A39_63'' & ‘A64''')}) -> α73''')    (2)
//│ | | | | | | | | | | | | | 3. C (((K[‘L54'] & #KS<Object,K>) & {KS#A: mut (A39_62'' | ‘A64''')..(A39_63'' & ‘A64''')}),) <! (x71_74''',)    (2)
//│ | | | | | | | | | | | | | | 3. C ((K[‘L54'] & #KS<Object,K>) & {KS#A: mut (A39_62'' | ‘A64''')..(A39_63'' & ‘A64''')}) <! x71_74'''    (3)
//│ | | | | | | | | | | | | | | | NEW x71_74''' LB (3)
//│ | | | | | | | | | | | | | | | 3. C ((K[‘L54'] & #KS<Object,K>) & {KS#A: mut (A39_62'' | ‘A64''')..(A39_63'' & ‘A64''')}) <! {#ev: #ev72_75'''}    (6)
//│ | | | | | | | | | | | | | | | | Assigning T :: T36' := ‘L54' where 
//│ | | | | | | | | | | | | | | | | Set T36_76' ~> T36'
//│ | | | | | | | | | | | | | | | | Assigned Some(‘L54')
//│ | | | | | | | | | | | | | | | | Assigning A :: A39' := ? :> ⊥ <: ⊤
//│ | | | | | | | | | | | | | | | | Set A39_77 ~> A39'
//│ | | | | | | | | | | | | | | | | Assigned Some(⊥..⊤)
//│ | | | | | | | | | | | | | | | | 3. ARGH  DNF(3, #KS<Object,K>{KS#A: mut (A39_62'' | ‘A64''')..(‘A64''' & A39_63''), T: mut ‘L54'..‘L54'})  <!  DNF(3, {#ev: #ev72_75'''})
//│ | | | | | | | | | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | | | | | | | | | Consider #KS<Object,K>{KS#A: mut (A39_62'' | ‘A64''')..(‘A64''' & A39_63''), T: mut ‘L54'..‘L54'} <: DNF(3, {#ev: #ev72_75'''})
//│ | | | | | | | | | | | | | | | | | Possible: List({#ev: #ev72_75'''})
//│ | | | | | | | | | | | | | | | | | 3. A  #KS<Object,K>{KS#A: mut (A39_62'' | ‘A64''')..(‘A64''' & A39_63''), T: mut ‘L54'..‘L54'}  %  List()  <!  List({#ev: #ev72_75'''})  %  ⊥
//│ | | | | | | | | | | | | | | | | | | 3. A  #KS<Object,K>{KS#A: mut (A39_62'' | ‘A64''')..(‘A64''' & A39_63''), T: mut ‘L54'..‘L54'}  %  List()  <!  List()  %  {#ev:#ev72_75'''}
//│ | | | | | | | | | | | | | | | | | | | 3. A  #KS<Object,K>{KS#A: mut (A39_62'' | ‘A64''')..(‘A64''' & A39_63''), T: mut ‘L54'..‘L54'}  %  List()  <!  List()  %  |{#ev:#ev72_75'''}
//│ | | | | | | | | | | | | | | | | | | | | Looking up field #ev in Some(KS) & TreeSet() & {...}
//│ | | | | | | | | | | | | | | | | | | | | | Lookup KS.ev : Some(K[‘A39']) where 
//│ | | | | | | | | | | | | | | | | | | | | | Lookup: Found mut (A39_62'' | ‘A64''')..(‘A64''' & A39_63'')
//│ | | | | | | | | | | | | | | | | | | | | | Fresh[0] KS.ev : Some(K[(A39_62'' | ‘A64''')..(‘A64''' & A39_63'')]) where Some(
//│ 		A39_62'' <: A39_63'')
//│ | | | | | | | | | | | | | | | | | | | | |   & None  (from refinement)
//│ | | | | | | | | | | | | | | | | | | | | 3. C K[(A39_62'' | ‘A64''')..(‘A64''' & A39_63'')] <! #ev72_75'''    (5)
//│ | | | | | | | | | | | | | | | | | | | | | NEW #ev72_75''' LB (3)
//│ | | | | | | | | | | | | | | | 3. C ((K[‘L54'] & #KS<Object,K>) & {KS#A: mut (A39_62'' | ‘A64''')..(A39_63'' & ‘A64''')}) <! #KS<Object,K>    (6)
//│ | | | | | | | | | | | | | | | | Already a subtype by <:<
//│ | | | | | | | | | | | | | 3. C (#ev72_75''',) <! α73'''    (2)
//│ | | | | | | | | | | | | | | NEW α73''' LB (3)
//│ | | | | | | | | | | 3. : α73'''
//│ | | | | | | | | | | CONSTRAIN ([e266''',] -> α67''') <! (α73''' -> α78''')
//│ | | | | | | | | | |   where 
//│ 		A39_62'' <: A39_63''
//│ 		e266''' <: K['L52_68''']
//│ 		α67''' :> Int
//│ 		'L52_68''' :> 'L52_70'' <: 'L52_69''
//│ 		'L52_70'' <: 'L52_69''
//│ 		α73''' :> (#ev72_75''',)
//│ 		#ev72_75''' :> K[(A39_62'' | ‘A64''')..(‘A64''' & A39_63'')]
//│ | | | | | | | | | | 3. C ([e266''',] -> α67''') <! (α73''' -> α78''')    (0)
//│ | | | | | | | | | | | 3. C (α73''',) <! ((e266''',),)    (1)
//│ | | | | | | | | | | | | 3. C α73''' <! (e266''',)    (2)
//│ | | | | | | | | | | | | | NEW α73''' UB (3)
//│ | | | | | | | | | | | | | 3. C (#ev72_75''',) <! (e266''',)    (4)
//│ | | | | | | | | | | | | | | 3. C #ev72_75''' <! e266'''    (4)
//│ | | | | | | | | | | | | | | | NEW #ev72_75''' UB (3)
//│ | | | | | | | | | | | | | | | 3. C K[(A39_62'' | ‘A64''')..(‘A64''' & A39_63'')] <! e266'''    (6)
//│ | | | | | | | | | | | | | | | | NEW e266''' LB (3)
//│ | | | | | | | | | | | | | | | | 3. C K[(A39_62'' | ‘A64''')..(‘A64''' & A39_63'')] <! K['L52_68''']    (8)
//│ | | | | | | | | | | | | | | | | | 3. C (A39_62'' | ‘A64''')..(‘A64''' & A39_63'') <! 'L52_68'''    (7)
//│ | | | | | | | | | | | | | | | | | | 3. C (‘A64''' & A39_63'') <! 'L52_68'''    (9)
//│ | | | | | | | | | | | | | | | | | | | NEW 'L52_68''' LB (3)
//│ | | | | | | | | | | | | | | | | | | | 3. C (‘A64''' & A39_63'') <! 'L52_69''    (11)
//│ | | | | | | | | | | | | | | | | | | | | wrong level: 3
//│ | | | | | | | | | | | | | | | | | | | | EXTR[+] (‘A64''' & A39_63'') || 2 .. 1024  3 false
//│ | | | | | | | | | | | | | | | | | | | | | EXTR[+] ‘A64''' || 2 .. 1024  3 false
//│ | | | | | | | | | | | | | | | | | | | | | => ⊤(‘A64''')
//│ | | | | | | | | | | | | | | | | | | | | | EXTR[+] A39_63'' || 2 .. 1024  2 true
//│ | | | | | | | | | | | | | | | | | | | | | => A39_63''
//│ | | | | | | | | | | | | | | | | | | | | => (⊤(‘A64''') & A39_63'')
//│ | | | | | | | | | | | | | | | | | | | | EXTR LHS  ~>  (⊤(‘A64''') & A39_63'')  to 2
//│ | | | | | | | | | | | | | | | | | | | |  where 
//│ | | | | | | | | | | | | | | | | | | | | 3. C (⊤(‘A64''') & A39_63'') <! 'L52_69''    (13)
//│ | | | | | | | | | | | | | | | | | | | | | NEW 'L52_69'' LB (2)
//│ | | | | | | | | | | | | | | | | | 3. C 'L52_68''' <! (A39_62'' | ‘A64''')..(‘A64''' & A39_63'')    (7)
//│ | | | | | | | | | | | | | | | | | | 3. C 'L52_68''' <! (A39_62'' | ‘A64''')    (9)
//│ | | | | | | | | | | | | | | | | | | | NEW 'L52_68''' UB (3)
//│ | | | | | | | | | | | | | | | | | | | 3. C (‘A64''' & A39_63'') <! (A39_62'' | ‘A64''')    (11)
//│ | | | | | | | | | | | | | | | | | | | | Already a subtype by <:<
//│ | | | | | | | | | | | | | | | | | | | 3. C 'L52_70'' <! (A39_62'' | ‘A64''')    (11)
//│ | | | | | | | | | | | | | | | | | | | | wrong level: 3
//│ | | | | | | | | | | | | | | | | | | | | EXTR[-] (A39_62'' | ‘A64''') || 2 .. 1024  3 false
//│ | | | | | | | | | | | | | | | | | | | | | EXTR[-] A39_62'' || 2 .. 1024  2 true
//│ | | | | | | | | | | | | | | | | | | | | | => A39_62''
//│ | | | | | | | | | | | | | | | | | | | | | EXTR[-] ‘A64''' || 2 .. 1024  3 false
//│ | | | | | | | | | | | | | | | | | | | | | => ⊥(‘A64''')
//│ | | | | | | | | | | | | | | | | | | | | => (A39_62'' | ⊥(‘A64'''))
//│ | | | | | | | | | | | | | | | | | | | | EXTR RHS  ~>  (A39_62'' | ⊥(‘A64'''))  to 2
//│ | | | | | | | | | | | | | | | | | | | |  where 
//│ 		A39_62'' <: A39_63''
//│ | | | | | | | | | | | | | | | | | | | | 3. C 'L52_70'' <! (A39_62'' | ⊥(‘A64'''))    (13)
//│ | | | | | | | | | | | | | | | | | | | | | NEW 'L52_70'' UB (2)
//│ | | | | | | | | | | | 3. C α67''' <! α78'''    (1)
//│ | | | | | | | | | | | | NEW α67''' UB (3)
//│ | | | | | | | | | | | | 3. C Int <! α78'''    (3)
//│ | | | | | | | | | | | | | NEW α78''' LB (0)
//│ | | | | | | | | | 3. : α78'''
//│ | | | | | | | | | CONSTRAIN α78''' <! α65''
//│ | | | | | | | | |   where 
//│ 		α78''' :> Int
//│ | | | | | | | | | 3. C α78''' <! α65''    (0)
//│ | | | | | | | | | | NEW α78''' UB (2)
//│ | | | | | | | | | | 3. C Int <! α65''    (2)
//│ | | | | | | | | | | | NEW α65'' LB (0)
//│ | | | | | | | | | 2. Typing term 0
//│ | | | | | | | | | 2. : #0<Int,Num,Object>
//│ | | | | | | | | | finishing branch: [(#KS<Object,K>,{KS#A: mut A39_62''..A39_63''})] + List((α79'',⊤)) and [α65''] | #0<Int,Num,Object>
//│ | | | | | | | | | finishing case K[‘L54'] <: ((#KS<Object,K> & {KS#A: mut A39_62''..A39_63''}) | (α79'' & ~(#KS<Object,K>)))
//│ | | | | | | | | | CONSTRAIN K[‘L54'] <! ((#KS<Object,K> & {KS#A: mut A39_62''..A39_63''}) | (α79'' & ~(#KS<Object,K>)))
//│ | | | | | | | | |   where 
//│ 		A39_62'' <: A39_63''
//│ | | | | | | | | | 2. C K[‘L54'] <! ((#KS<Object,K> & {KS#A: mut A39_62''..A39_63''}) | (α79'' & ~(#KS<Object,K>)))    (0)
//│ | | | | | | | | | | Assigning T :: T36' := ‘L54' where 
//│ | | | | | | | | | | Set T36_80' ~> T36'
//│ | | | | | | | | | | Assigned Some(‘L54')
//│ | | | | | | | | | | 2. C ((#K<Object> & KS[? :> ⊥ <: ⊤]) & {T: mut ‘L54'..‘L54'}) <! ((#KS<Object,K> & {KS#A: mut A39_62''..A39_63''}) | (α79'' & ~(#KS<Object,K>)))    (2)
//│ | | | | | | | | | | | Assigning A :: A39' := ? :> ⊥ <: ⊤
//│ | | | | | | | | | | | Set A39_81 ~> A39'
//│ | | | | | | | | | | | Assigned Some(⊥..⊤)
//│ | | | | | | | | | | | 2. ARGH  DNF(1, #KS<Object,K>{KS#A: mut ..⊤, T: mut ‘L54'..‘L54'})  <!  DNF(2, #KS<Object,K>{KS#A: mut A39_62''..A39_63''} | α79''∧~(#KS<Object,K>))
//│ | | | | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | | | | Consider #KS<Object,K>{KS#A: mut ..⊤, T: mut ‘L54'..‘L54'} <: DNF(2, #KS<Object,K>{KS#A: mut A39_62''..A39_63''} | α79''∧~(#KS<Object,K>))
//│ | | | | | | | | | | | | Possible: List(#KS<Object,K>{KS#A: mut A39_62''..A39_63''})
//│ | | | | | | | | | | | | 2. A  #KS<Object,K>{KS#A: mut ..⊤, T: mut ‘L54'..‘L54'}  %  List()  <!  List((#KS<Object,K> & {KS#A: mut A39_62''..A39_63''}))  %  ⊥
//│ | | | | | | | | | | | | | Case.1
//│ | | | | | | | | | | | | | 2. A  #KS<Object,K>{KS#A: mut ..⊤, T: mut ‘L54'..‘L54'}  %  List()  <!  List(#KS<Object,K>)  %  ⊥
//│ | | | | | | | | | | | | | | 2. A  #KS<Object,K>{KS#A: mut ..⊤, T: mut ‘L54'..‘L54'}  %  List()  <!  List()  %  #KS<Object,K>
//│ | | | | | | | | | | | | | | | class checking #KS<Object,K> List(#KS<Object,K>)
//│ | | | | | | | | | | | | | | | OK  #KS<Object,K>  <:  #KS<Object,K>
//│ | | | | | | | | | | | | | Case.2
//│ | | | | | | | | | | | | | 2. A  #KS<Object,K>{KS#A: mut ..⊤, T: mut ‘L54'..‘L54'}  %  List()  <!  List({KS#A: mut A39_62''..A39_63''})  %  ⊥
//│ | | | | | | | | | | | | | | 2. A  #KS<Object,K>{KS#A: mut ..⊤, T: mut ‘L54'..‘L54'}  %  List()  <!  List()  %  {KS#A:mut A39_62''..A39_63''}
//│ | | | | | | | | | | | | | | | 2. A  #KS<Object,K>{KS#A: mut ..⊤, T: mut ‘L54'..‘L54'}  %  List()  <!  List()  %  |{KS#A:mut A39_62''..A39_63''}
//│ | | | | | | | | | | | | | | | | Looking up field KS#A in Some(KS) & TreeSet() & {...}
//│ | | | | | | | | | | | | | | | | | Lookup KS.KS#A : Some(mut A39'..A39') where 
//│ | | | | | | | | | | | | | | | | | Lookup: Found mut ..⊤
//│ | | | | | | | | | | | | | | | | | Fresh[0] KS.KS#A : Some(mut ⊥..⊤..⊥..⊤) where Some()
//│ | | | | | | | | | | | | | | | | |   & Some(mut ..⊤)  (from refinement)
//│ | | | | | | | | | | | | | | | | 2. C ⊥..⊤ <! A39_63''    (2)
//│ | | | | | | | | | | | | | | | | | 2. C ⊤ <! A39_63''    (4)
//│ | | | | | | | | | | | | | | | | | | NEW A39_63'' LB (0)
//│ | | | | | | | | | | | | | | | | 2. C A39_62'' <! ⊥..⊤    (2)
//│ | | | | | | | | | | | | | | | | | 2. C A39_62'' <! ⊥    (4)
//│ | | | | | | | | | | | | | | | | | | NEW A39_62'' UB (0)
//│ | | | | | | | | 2. : (α65'' | #0<Int,Num,Object>)
//│ | | | | | | | 2. : ([e160'',] -> (α65'' | #0<Int,Num,Object>))
//│ | | | | | | | 2. Typing term (KS).unapply(l,)
//│ | | | | | | | | 2. Typing term (KS).unapply
//│ | | | | | | | | | 2. Typing term (x::2,) => let _ = x : KS in [(x).#ev,]
//│ | | | | | | | | | | TYPING POLY LAM
//│ | | | | | | | | | | 3. Typing pattern [x::2,]
//│ | | | | | | | | | | | 3. Typing pattern x::2
//│ | | | | | | | | | | | 3. : x82'''
//│ | | | | | | | | | | 3. : (x82''',)
//│ | | | | | | | | | | 3. Typing term let _ = x : KS in [(x).#ev,]
//│ | | | | | | | | | | | 3. Typing term x : KS
//│ | | | | | | | | | | | | 3. Typing term x
//│ | | | | | | | | | | | | 3. : x82'''
//│ | | | | | | | | | | | | Typing type TypeName(KS)
//│ | | | | | | | | | | | | | vars=Map(L -> ‘L54') newDefsInfo=Map()
//│ | | | | | | | | | | | | | 3. type TypeName(KS)
//│ | | | | | | | | | | | | | => #KS<Object,K>
//│ | | | | | | | | | | | | => #KS<Object,K> ——— 
//│ | | | | | | | | | | | | CONSTRAIN x82''' <! #KS<Object,K>
//│ | | | | | | | | | | | |   where 
//│ | | | | | | | | | | | | 3. C x82''' <! #KS<Object,K>    (0)
//│ | | | | | | | | | | | | | NEW x82''' UB (0)
//│ | | | | | | | | | | | 3. : #KS<Object,K>
//│ | | | | | | | | | | | 3. Typing term [(x).#ev,]
//│ | | | | | | | | | | | | 3. Typing term (x).#ev
//│ | | | | | | | | | | | | | 3. Typing term x
//│ | | | | | | | | | | | | | 3. : x82'''
//│ | | | | | | | | | | | | | CONSTRAIN x82''' <! {#ev: #ev83'''}
//│ | | | | | | | | | | | | |   where 
//│ 		x82''' <: #KS<Object,K>
//│ | | | | | | | | | | | | | 3. C x82''' <! {#ev: #ev83'''}    (0)
//│ | | | | | | | | | | | | | | NEW x82''' UB (3)
//│ | | | | | | | | | | | | 3. : #ev83'''
//│ | | | | | | | | | | | 3. : (#ev83''',)
//│ | | | | | | | | | | 3. : (#ev83''',)
//│ | | | | | | | | | | Inferred poly constr: (x82''' -> (#ev83''',))  —— where 
//│ 		x82''' <: {#ev: #ev83'''} & #KS<Object,K>
//│ | | | | | | | | | 2. : ‹∀ 2. (x82''' -> (#ev83''',))›
//│ | | | | | | | | 2. : ‹∀ 2. (x82''' -> (#ev83''',))›
//│ | | | | | | | | 2. Typing term l
//│ | | | | | | | | 2. : ((K[‘L54'] & #KS<Object,K>) & {KS#A: mut (A39_56' | ‘A58'')..(A39_57' & ‘A58'')})
//│ | | | | | | | | CONSTRAIN ‹∀ 2. (x82''' -> (#ev83''',))› <! (((K[‘L54'] & #KS<Object,K>) & {KS#A: mut (A39_56' | ‘A58'')..(A39_57' & ‘A58'')}) -> α84'')
//│ | | | | | | | |   where 
//│ 		A39_56' <: A39_57'
//│ 		x82''' <: {#ev: #ev83'''} & #KS<Object,K>
//│ | | | | | | | | 2. C ‹∀ 2. (x82''' -> (#ev83''',))› <! (((K[‘L54'] & #KS<Object,K>) & {KS#A: mut (A39_56' | ‘A58'')..(A39_57' & ‘A58'')}) -> α84'')    (0)
//│ | | | | | | | | | INST [2]   ‹∀ 2. (x82''' -> (#ev83''',))›
//│ | | | | | | | | |   where  
//│ 		x82''' <: {#ev: #ev83'''} & #KS<Object,K>
//│ | | | | | | | | | TO [2] ~>  (x82_85'' -> (#ev83_86'',))
//│ | | | | | | | | |   where  
//│ 		x82_85'' <: {#ev: #ev83_86''} & #KS<Object,K>
//│ | | | | | | | | | 2. C (x82_85'' -> (#ev83_86'',)) <! (((K[‘L54'] & #KS<Object,K>) & {KS#A: mut (A39_56' | ‘A58'')..(A39_57' & ‘A58'')}) -> α84'')    (2)
//│ | | | | | | | | | | 2. C (((K[‘L54'] & #KS<Object,K>) & {KS#A: mut (A39_56' | ‘A58'')..(A39_57' & ‘A58'')}),) <! (x82_85'',)    (2)
//│ | | | | | | | | | | | 2. C ((K[‘L54'] & #KS<Object,K>) & {KS#A: mut (A39_56' | ‘A58'')..(A39_57' & ‘A58'')}) <! x82_85''    (3)
//│ | | | | | | | | | | | | NEW x82_85'' LB (2)
//│ | | | | | | | | | | | | 2. C ((K[‘L54'] & #KS<Object,K>) & {KS#A: mut (A39_56' | ‘A58'')..(A39_57' & ‘A58'')}) <! {#ev: #ev83_86''}    (6)
//│ | | | | | | | | | | | | | Assigning T :: T36' := ‘L54' where 
//│ | | | | | | | | | | | | | Set T36_87' ~> T36'
//│ | | | | | | | | | | | | | Assigned Some(‘L54')
//│ | | | | | | | | | | | | | Assigning A :: A39' := ? :> ⊥ <: ⊤
//│ | | | | | | | | | | | | | Set A39_88 ~> A39'
//│ | | | | | | | | | | | | | Assigned Some(⊥..⊤)
//│ | | | | | | | | | | | | | 2. ARGH  DNF(2, #KS<Object,K>{KS#A: mut (A39_56' | ‘A58'')..(‘A58'' & A39_57'), T: mut ‘L54'..‘L54'})  <!  DNF(2, {#ev: #ev83_86''})
//│ | | | | | | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | | | | | | Consider #KS<Object,K>{KS#A: mut (A39_56' | ‘A58'')..(‘A58'' & A39_57'), T: mut ‘L54'..‘L54'} <: DNF(2, {#ev: #ev83_86''})
//│ | | | | | | | | | | | | | | Possible: List({#ev: #ev83_86''})
//│ | | | | | | | | | | | | | | 2. A  #KS<Object,K>{KS#A: mut (A39_56' | ‘A58'')..(‘A58'' & A39_57'), T: mut ‘L54'..‘L54'}  %  List()  <!  List({#ev: #ev83_86''})  %  ⊥
//│ | | | | | | | | | | | | | | | 2. A  #KS<Object,K>{KS#A: mut (A39_56' | ‘A58'')..(‘A58'' & A39_57'), T: mut ‘L54'..‘L54'}  %  List()  <!  List()  %  {#ev:#ev83_86''}
//│ | | | | | | | | | | | | | | | | 2. A  #KS<Object,K>{KS#A: mut (A39_56' | ‘A58'')..(‘A58'' & A39_57'), T: mut ‘L54'..‘L54'}  %  List()  <!  List()  %  |{#ev:#ev83_86''}
//│ | | | | | | | | | | | | | | | | | Looking up field #ev in Some(KS) & TreeSet() & {...}
//│ | | | | | | | | | | | | | | | | | | Lookup KS.ev : Some(K[‘A39']) where 
//│ | | | | | | | | | | | | | | | | | | Lookup: Found mut (A39_56' | ‘A58'')..(‘A58'' & A39_57')
//│ | | | | | | | | | | | | | | | | | | Fresh[0] KS.ev : Some(K[(A39_56' | ‘A58'')..(‘A58'' & A39_57')]) where Some(
//│ 		A39_56' <: A39_57')
//│ | | | | | | | | | | | | | | | | | |   & None  (from refinement)
//│ | | | | | | | | | | | | | | | | | 2. C K[(A39_56' | ‘A58'')..(‘A58'' & A39_57')] <! #ev83_86''    (5)
//│ | | | | | | | | | | | | | | | | | | NEW #ev83_86'' LB (2)
//│ | | | | | | | | | | | | 2. C ((K[‘L54'] & #KS<Object,K>) & {KS#A: mut (A39_56' | ‘A58'')..(A39_57' & ‘A58'')}) <! #KS<Object,K>    (6)
//│ | | | | | | | | | | | | | Already a subtype by <:<
//│ | | | | | | | | | | 2. C (#ev83_86'',) <! α84''    (2)
//│ | | | | | | | | | | | NEW α84'' LB (2)
//│ | | | | | | | 2. : α84''
//│ | | | | | | | CONSTRAIN ([e160'',] -> (α65'' | #0<Int,Num,Object>)) <! (α84'' -> α89'')
//│ | | | | | | |   where 
//│ 		A39_56' <: A39_57'
//│ 		e160'' <: K[? :> 'L52_69'' <: 'L52_70'']
//│ 		A39_62'' <: ⊥ & A39_63''
//│ 		A39_63'' :> ⊤
//│ 		α65'' :> Int
//│ 		'L52_69'' :> (⊤(‘A64''') & A39_63'')
//│ 		'L52_70'' <: (A39_62'' | ⊥(‘A64''')) & 'L52_69''
//│ 		α84'' :> (#ev83_86'',)
//│ 		#ev83_86'' :> K[(A39_56' | ‘A58'')..(‘A58'' & A39_57')]
//│ | | | | | | | 2. C ([e160'',] -> (α65'' | #0<Int,Num,Object>)) <! (α84'' -> α89'')    (0)
//│ | | | | | | | | 2. C (α84'',) <! ((e160'',),)    (1)
//│ | | | | | | | | | 2. C α84'' <! (e160'',)    (2)
//│ | | | | | | | | | | NEW α84'' UB (2)
//│ | | | | | | | | | | 2. C (#ev83_86'',) <! (e160'',)    (4)
//│ | | | | | | | | | | | 2. C #ev83_86'' <! e160''    (4)
//│ | | | | | | | | | | | | NEW #ev83_86'' UB (2)
//│ | | | | | | | | | | | | 2. C K[(A39_56' | ‘A58'')..(‘A58'' & A39_57')] <! e160''    (6)
//│ | | | | | | | | | | | | | NEW e160'' LB (2)
//│ | | | | | | | | | | | | | 2. C K[(A39_56' | ‘A58'')..(‘A58'' & A39_57')] <! K[? :> 'L52_69'' <: 'L52_70'']    (8)
//│ | | | | | | | | | | | | | | 2. C 'L52_69'' <! (A39_56' | ‘A58'')..(‘A58'' & A39_57')    (7)
//│ | | | | | | | | | | | | | | | 2. C 'L52_69'' <! (A39_56' | ‘A58'')    (9)
//│ | | | | | | | | | | | | | | | | NEW 'L52_69'' UB (2)
//│ | | | | | | | | | | | | | | | | 2. C (⊤(‘A64''') & A39_63'') <! (A39_56' | ‘A58'')    (11)
//│ | | | | | | | | | | | | | | | | | 2. ARGH  DNF(2, {}∧⊤(‘A64''')∧A39_63'')  <!  DNF(2, A39_56' | {}∧‘A58'')
//│ | | | | | | | | | | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | | | | | | | | | | 2. C A39_63'' <! ((A39_56' | ‘A58'') | ~(⊤(‘A64''')))    (13)
//│ | | | | | | | | | | | | | | | | | | | NEW A39_63'' UB (2)
//│ | | | | | | | | | | | | | | | | | | | 2. C ⊤ <! ((A39_56' | ‘A58'') | ~(⊤(‘A64''')))    (15)
//│ | | | | | | | | | | | | | | | | | | | | 2. ARGH  DNF(0, )  <!  DNF(2, A39_56' | {}∧‘A58'' | ~(⊤(‘A64''')))
//│ | | | | | | | | | | | | | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | | | | | | | | | | | | | Consider ⊤ <: DNF(2, A39_56' | {}∧‘A58'' | ~(⊤(‘A64''')))
//│ | | | | | | | | | | | | | | | | | | | | | Possible: List(A39_56', {}∧‘A58'', ~(⊤(‘A64''')))
//│ | | | | | | | | | | | | | | | | | | | | | 2. A  ⊤  %  List()  <!  List(A39_56', ‘A58'', ~(⊤(‘A64''')))  %  ⊥
//│ | | | | | | | | | | | | | | | | | | | | | | 2. A  ⊤  %  List()  <!  List(‘A58'', ~(⊤(‘A64''')))  %  ⊥
//│ | | | | | | | | | | | | | | | | | | | | | | | 2. A  ⊤  %  List()  <!  List(~(⊤(‘A64''')))  %  ‘A58''
//│ | | | | | | | | | | | | | | | | | | | | | | | | 2. A  ⊤  %  List(⊤(‘A64'''))  <!  List()  %  ‘A58''
//│ | | | | | | | | | | | | | | | | | | | | | | | | | 2. A  {}∧⊤(‘A64''')  %  List()  <!  List()  %  ‘A58''
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | 2. C (⊤(‘A64''') & ~(‘A58'')) <! A39_56'    (12)
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | wrong level: 2
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | EXTR[+] (⊤(‘A64''') & ~(‘A58'')) || 1 .. 1024  2 false
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | EXTR[+] ⊤(‘A64''') || 1 .. 1024  0 true
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | => ⊤(‘A64''')
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | EXTR[+] ~(‘A58'') || 1 .. 1024  2 false
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | | EXTR[-] ‘A58'' || 1 .. 1024  2 false
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | | => ⊥(‘A58'')
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | => ~(⊥(‘A58''))
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | => (⊤(‘A64''') & ~(⊥(‘A58'')))
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | EXTR LHS  ~>  (⊤(‘A64''') & ~(⊥(‘A58'')))  to 1
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | |  where 
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | 2. C (⊤(‘A64''') & ~(⊥(‘A58''))) <! A39_56'    (14)
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | NEW A39_56' LB (0)
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | 2. C (⊤(‘A64''') & ~(⊥(‘A58''))) <! A39_57'    (16)
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | | NEW A39_57' LB (0)
//│ | | | | | | | | | | | | | | 2. C (A39_56' | ‘A58'')..(‘A58'' & A39_57') <! 'L52_70''    (7)
//│ | | | | | | | | | | | | | | | 2. C (‘A58'' & A39_57') <! 'L52_70''    (9)
//│ | | | | | | | | | | | | | | | | NEW 'L52_70'' LB (2)
//│ | | | | | | | | | | | | | | | | 2. C (‘A58'' & A39_57') <! (A39_62'' | ⊥(‘A64'''))    (11)
//│ | | | | | | | | | | | | | | | | | 2. ARGH  DNF(2, {}∧‘A58''∧A39_57')  <!  DNF(2, A39_62'' | {}∧⊥(‘A64'''))
//│ | | | | | | | | | | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | | | | | | | | | | 2. C A39_57' <! ((A39_62'' | ⊥(‘A64''')) | ~(‘A58''))    (13)
//│ | | | | | | | | | | | | | | | | | | | wrong level: 2
//│ | | | | | | | | | | | | | | | | | | | EXTR[-] ((‘A58'' & A39_57') & ~(⊥(‘A64'''))) || 1 .. 1024  2 false
//│ | | | | | | | | | | | | | | | | | | | | EXTR[-] (‘A58'' & A39_57') || 1 .. 1024  2 false
//│ | | | | | | | | | | | | | | | | | | | | | EXTR[-] ‘A58'' || 1 .. 1024  2 false
//│ | | | | | | | | | | | | | | | | | | | | | => ⊥(‘A58'')
//│ | | | | | | | | | | | | | | | | | | | | | EXTR[-] A39_57' || 1 .. 1024  1 true
//│ | | | | | | | | | | | | | | | | | | | | | => A39_57'
//│ | | | | | | | | | | | | | | | | | | | | => (⊥(‘A58'') & A39_57')
//│ | | | | | | | | | | | | | | | | | | | | EXTR[-] ~(⊥(‘A64''')) || 1 .. 1024  0 true
//│ | | | | | | | | | | | | | | | | | | | | => ~(⊥(‘A64'''))
//│ | | | | | | | | | | | | | | | | | | | => ((⊥(‘A58'') & A39_57') & ~(⊥(‘A64''')))
//│ | | | | | | | | | | | | | | | | | | | EXTR RHS  ~>  ((⊥(‘A58'') & A39_57') & ~(⊥(‘A64''')))  to 1
//│ | | | | | | | | | | | | | | | | | | |  where 
//│ 		A39_57' :> (⊤(‘A64''') & ~(⊥(‘A58'')))
//│ | | | | | | | | | | | | | | | | | | | 2. C A39_57' <! ((⊥(‘A58'') & A39_57') & ~(⊥(‘A64''')))    (15)
//│ | | | | | | | | | | | | | | | | | | | | NEW A39_57' UB (1)
//│ | | | | | | | | | | | | | | | | | | | | 2. C (⊤(‘A64''') & ~(⊥(‘A58''))) <! ((⊥(‘A58'') & A39_57') & ~(⊥(‘A64''')))    (17)
//│ | | | | | | | | | | | | | | | | | | | | | 2. C (⊤(‘A64''') & ~(⊥(‘A58''))) <! (⊥(‘A58'') & A39_57')    (19)
//│ | | | | | | | | | | | | | | | | | | | | | | 2. C (⊤(‘A64''') & ~(⊥(‘A58''))) <! ⊥(‘A58'')    (21)
//│ | | | | | | | | | | | | | | | | | | | | | | | 2. ARGH  DNF(0, {}∧⊤(‘A64''')∧~(⊥(‘A58'')))  <!  DNF(0, {}∧⊥(‘A58''))
//│ | | | | | | | | | | | | | | | | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | | | | | | | | | | | | | | | | Consider {}∧⊤(‘A64''') <: DNF(0, {}∧⊥(‘A58''))
//│ | | | | | | | | | | | | | | | | | | | | | | | | Possible: List({}∧⊥(‘A58''))
//│ | | | | | | | | | | | | | | | | | | | | | | | | 2. A  {}∧⊤(‘A64''')  %  List()  <!  List(⊥(‘A58''))  %  ⊥
//│ | | | | | | | | | | | | | | | | | | | | | | | | | 2. A  {}∧⊤(‘A64''')  %  List()  <!  List()  %  ⊥(‘A58'')
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | Tag checking TreeSet(⊤(‘A64''')) List(⊥(‘A58''))
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | CONSTRAINT FAILURE: (⊤(‘A64''') & ~(⊥(‘A58''))) <: ⊥(‘A58'')
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | allVarPols: +A39_58''
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | normLike[+] ‘A58''
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | norm[+] ‘A58''
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | DNF: DNF(2, {}∧‘A58'')
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | ~> ‘A58''
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | CONSTRAIN #error<> <! α89''
//│ | | | | | | | | | | | | | | | | | | | | | | | | | |   where 
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | 2. C #error<> <! α89''    (0)
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | NEW α89'' LB (0)
//│ ╔══[ERROR] Type error in operator application
//│ ║  l.21: 	  if l is KS(e1) and r is KS(e2) then fr(e1, e2) else 0
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.14: 	class KS[A](ev: K[A]) extends K[S[A]]
//│ ╙──      	         ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ | | | | | | | | | | | | | | | | | | | | | | 2. C (⊤(‘A64''') & ~(⊥(‘A58''))) <! A39_57'    (21)
//│ | | | | | | | | | | | | | | | | | | | | | | | Cached!
//│ | | | | | | | | | | | | | | | | | | | | | 2. C (⊤(‘A64''') & ~(⊥(‘A58''))) <! ~(⊥(‘A64'''))    (19)
//│ | | | | | | | | | | | | | | | | | | | | | | 2. ARGH  DNF(0, {}∧⊤(‘A64''')∧~(⊥(‘A58'')))  <!  DNF(0, ~(⊥(‘A64''')))
//│ | | | | | | | | | | | | | | | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | | | | | | | | | | | | | | | Consider {}∧⊤(‘A64''') <: DNF(0, ~(⊥(‘A64''')) | {}∧⊥(‘A58''))
//│ | | | | | | | | | | | | | | | | | | | | | | | Possible: List(~(⊥(‘A64''')), {}∧⊥(‘A58''))
//│ | | | | | | | | | | | | | | | | | | | | | | | 2. A  {}∧⊤(‘A64''')  %  List()  <!  List(~(⊥(‘A64''')), ⊥(‘A58''))  %  ⊥
//│ | | | | | | | | | | | | | | | | | | | | | | | | 2. A  {}∧⊤(‘A64''')  %  List(⊥(‘A64'''))  <!  List(⊥(‘A58''))  %  ⊥
//│ | | | | | | | | | | | | | | | | | | | | | | | | | 2. A  {}∧⊤(‘A64''')  %  List()  <!  List(⊥(‘A58''))  %  ⊥
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | 2. A  {}∧⊤(‘A64''')  %  List()  <!  List()  %  ⊥(‘A58'')
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | Tag checking TreeSet(⊤(‘A64''')) List(⊥(‘A58''))
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | CONSTRAINT FAILURE: (⊤(‘A64''') & ~(⊥(‘A58''))) <: ~(⊥(‘A64'''))
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | allVarPols: 
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | normLike[-] ~(⊥(‘A64'''))
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | norm[-] ~(⊥(‘A64'''))
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | | DNF: DNF(0, ~(⊥(‘A64''')))
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | | norm[+] ⊥(‘A64''')
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | DNF: DNF(0, {}∧⊥(‘A64'''))
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ~> ⊥(‘A64''')
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | ~> ~(⊥(‘A64'''))
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | allVarPols: 
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | normLike[+] (⊤(‘A64''') & ~(⊥(‘A58'')))
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | norm[+] (⊤(‘A64''') & ~(⊥(‘A58'')))
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | | DNF: DNF(0, {}∧⊤(‘A64''')∧~(⊥(‘A58'')))
//│ | | | | | | | | | | | | | | | | | | | | | | | | | | | | ~> (⊤(‘A64''') & ~(⊥(‘A58'')))
//│ | | | | | | | | | | | | | | | | 2. C (‘A58'' & A39_57') <! 'L52_69''    (11)
//│ | | | | | | | | | | | | | | | | | NEW 'L52_69'' LB (2)
//│ | | | | | | | | | | | | | | | | | 2. C (‘A58'' & A39_57') <! (A39_56' | ‘A58'')    (13)
//│ | | | | | | | | | | | | | | | | | | Already a subtype by <:<
//│ | | | | | | | | 2. C (α65'' | #0<Int,Num,Object>) <! α89''    (1)
//│ | | | | | | | | | NEW α89'' LB (2)
//│ | | | | | | 2. : α89''
//│ | | | | | | CONSTRAIN α89'' <! α59'
//│ | | | | | |   where 
//│ 		α65'' :> Int
//│ 		α89'' :> (α65'' | #0<Int,Num,Object>) | #error<>
//│ | | | | | | 2. C α89'' <! α59'    (0)
//│ | | | | | | | NEW α89'' UB (1)
//│ | | | | | | | 2. C (α65'' | #0<Int,Num,Object>) <! α59'    (2)
//│ | | | | | | | | wrong level: 2
//│ | | | | | | | | EXTR[+] (α65'' | #0<Int,Num,Object>) || 1 .. 1024  2 false
//│ | | | | | | | | | EXTR[+] α65'' || 1 .. 1024  2 false
//│ | | | | | | | | | | EXTR[+] Int || 1 .. 1024  0 true
//│ | | | | | | | | | | => Int
//│ | | | | | | | | | => α65_94'
//│ | | | | | | | | | EXTR[+] #0<Int,Num,Object> || 1 .. 1024  0 true
//│ | | | | | | | | | => #0<Int,Num,Object>
//│ | | | | | | | | => (α65_94' | #0<Int,Num,Object>)
//│ | | | | | | | | RECONSTRAINING TVs
//│ | | | | | | | | | Reconstraining α65_94'
//│ | | | | | | | | EXTR LHS  ~>  (α65_94' | #0<Int,Num,Object>)  to 1
//│ | | | | | | | |  where 
//│ 		α65_94' :> Int
//│ | | | | | | | | 2. C (α65_94' | #0<Int,Num,Object>) <! α59'    (4)
//│ | | | | | | | | | NEW α59' LB (1)
//│ | | | | | | | 2. C #error<> <! α59'    (2)
//│ | | | | | | | | NEW α59' LB (0)
//│ | | | | | | 1. Typing term 0
//│ | | | | | | 1. : #0<Int,Num,Object>
//│ | | | | | | finishing branch: [(#KS<Object,K>,{KS#A: mut A39_56'..A39_57'})] + List((α95',⊤)) and [α59'] | #0<Int,Num,Object>
//│ | | | | | | finishing case K[‘L54'] <: ((#KS<Object,K> & {KS#A: mut A39_56'..A39_57'}) | (α95' & ~(#KS<Object,K>)))
//│ | | | | | | CONSTRAIN K[‘L54'] <! ((#KS<Object,K> & {KS#A: mut A39_56'..A39_57'}) | (α95' & ~(#KS<Object,K>)))
//│ | | | | | |   where 
//│ 		A39_56' :> (⊤(‘A64''') & ~(⊥(‘A58''))) <: A39_57'
//│ 		A39_57' :> (⊤(‘A64''') & ~(⊥(‘A58''))) <: ((⊥(‘A58'') & A39_57') & ~(⊥(‘A64''')))
//│ | | | | | | 1. C K[‘L54'] <! ((#KS<Object,K> & {KS#A: mut A39_56'..A39_57'}) | (α95' & ~(#KS<Object,K>)))    (0)
//│ | | | | | | | Assigning T :: T36' := ‘L54' where 
//│ | | | | | | | Set T36_96' ~> T36'
//│ | | | | | | | Assigned Some(‘L54')
//│ | | | | | | | 1. C ((#K<Object> & KS[? :> ⊥ <: ⊤]) & {T: mut ‘L54'..‘L54'}) <! ((#KS<Object,K> & {KS#A: mut A39_56'..A39_57'}) | (α95' & ~(#KS<Object,K>)))    (2)
//│ | | | | | | | | Assigning A :: A39' := ? :> ⊥ <: ⊤
//│ | | | | | | | | Set A39_97 ~> A39'
//│ | | | | | | | | Assigned Some(⊥..⊤)
//│ | | | | | | | | 1. ARGH  DNF(1, #KS<Object,K>{KS#A: mut ..⊤, T: mut ‘L54'..‘L54'})  <!  DNF(1, #KS<Object,K>{KS#A: mut A39_56'..A39_57'} | α95'∧~(#KS<Object,K>))
//│ | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | Consider #KS<Object,K>{KS#A: mut ..⊤, T: mut ‘L54'..‘L54'} <: DNF(1, #KS<Object,K>{KS#A: mut A39_56'..A39_57'} | α95'∧~(#KS<Object,K>))
//│ | | | | | | | | | Possible: List(#KS<Object,K>{KS#A: mut A39_56'..A39_57'})
//│ | | | | | | | | | 1. A  #KS<Object,K>{KS#A: mut ..⊤, T: mut ‘L54'..‘L54'}  %  List()  <!  List((#KS<Object,K> & {KS#A: mut A39_56'..A39_57'}))  %  ⊥
//│ | | | | | | | | | | Case.1
//│ | | | | | | | | | | 1. A  #KS<Object,K>{KS#A: mut ..⊤, T: mut ‘L54'..‘L54'}  %  List()  <!  List(#KS<Object,K>)  %  ⊥
//│ | | | | | | | | | | | 1. A  #KS<Object,K>{KS#A: mut ..⊤, T: mut ‘L54'..‘L54'}  %  List()  <!  List()  %  #KS<Object,K>
//│ | | | | | | | | | | | | class checking #KS<Object,K> List(#KS<Object,K>)
//│ | | | | | | | | | | | | OK  #KS<Object,K>  <:  #KS<Object,K>
//│ | | | | | | | | | | Case.2
//│ | | | | | | | | | | 1. A  #KS<Object,K>{KS#A: mut ..⊤, T: mut ‘L54'..‘L54'}  %  List()  <!  List({KS#A: mut A39_56'..A39_57'})  %  ⊥
//│ | | | | | | | | | | | 1. A  #KS<Object,K>{KS#A: mut ..⊤, T: mut ‘L54'..‘L54'}  %  List()  <!  List()  %  {KS#A:mut A39_56'..A39_57'}
//│ | | | | | | | | | | | | 1. A  #KS<Object,K>{KS#A: mut ..⊤, T: mut ‘L54'..‘L54'}  %  List()  <!  List()  %  |{KS#A:mut A39_56'..A39_57'}
//│ | | | | | | | | | | | | | Looking up field KS#A in Some(KS) & TreeSet() & {...}
//│ | | | | | | | | | | | | | | Lookup KS.KS#A : Some(mut A39'..A39') where 
//│ | | | | | | | | | | | | | | Lookup: Found mut ..⊤
//│ | | | | | | | | | | | | | | Fresh[0] KS.KS#A : Some(mut ⊥..⊤..⊥..⊤) where Some()
//│ | | | | | | | | | | | | | |   & Some(mut ..⊤)  (from refinement)
//│ | | | | | | | | | | | | | 1. C ⊥..⊤ <! A39_57'    (2)
//│ | | | | | | | | | | | | | | 1. C ⊤ <! A39_57'    (4)
//│ | | | | | | | | | | | | | | | NEW A39_57' LB (0)
//│ | | | | | | | | | | | | | | | 1. C ⊤ <! ((⊥(‘A58'') & A39_57') & ~(⊥(‘A64''')))    (6)
//│ | | | | | | | | | | | | | | | | 1. C ⊤ <! (⊥(‘A58'') & A39_57')    (8)
//│ | | | | | | | | | | | | | | | | | 1. C ⊤ <! ⊥(‘A58'')    (10)
//│ | | | | | | | | | | | | | | | | | | CONSTRAINT FAILURE: ⊤ <: ⊥(‘A58'')
//│ | | | | | | | | | | | | | | | | | | allVarPols: +A39_58''
//│ | | | | | | | | | | | | | | | | | | normLike[+] ‘A58''
//│ | | | | | | | | | | | | | | | | | | | norm[+] ‘A58''
//│ | | | | | | | | | | | | | | | | | | | | DNF: DNF(2, {}∧‘A58'')
//│ | | | | | | | | | | | | | | | | | | | ~> ‘A58''
//│ | | | | | | | | | | | | | | | | | | CONSTRAIN #error<> <! (α59' | #0<Int,Num,Object>)
//│ | | | | | | | | | | | | | | | | | |   where 
//│ 		α59' :> #error<> | (α65_94' | #0<Int,Num,Object>)
//│ 		α65_94' :> Int
//│ | | | | | | | | | | | | | | | | | | 1. C #error<> <! (α59' | #0<Int,Num,Object>)    (0)
//│ ╔══[ERROR] Type error in `case` expression
//│ ║  l.21: 	  if l is KS(e1) and r is KS(e2) then fr(e1, e2) else 0
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.14: 	class KS[A](ev: K[A]) extends K[S[A]]
//│ ╙──      	         ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ | | | | | | | | | | | | | | | | | 1. C ⊤ <! A39_57'    (10)
//│ | | | | | | | | | | | | | | | | | | Cached!
//│ | | | | | | | | | | | | | | | | 1. C ⊤ <! ~(⊥(‘A64'''))    (8)
//│ | | | | | | | | | | | | | | | | | 1. ARGH  DNF(0, )  <!  DNF(0, ~(⊥(‘A64''')))
//│ | | | | | | | | | | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | | | | | | | | | | Consider ⊤ <: DNF(0, ~(⊥(‘A64''')))
//│ | | | | | | | | | | | | | | | | | | Possible: List(~(⊥(‘A64''')))
//│ | | | | | | | | | | | | | | | | | | 1. A  ⊤  %  List()  <!  List(~(⊥(‘A64''')))  %  ⊥
//│ | | | | | | | | | | | | | | | | | | | 1. A  ⊤  %  List(⊥(‘A64'''))  <!  List()  %  ⊥
//│ | | | | | | | | | | | | | | | | | | | | 1. A  {}∧⊥(‘A64''')  %  List()  <!  List()  %  ⊥
//│ | | | | | | | | | | | | | | | | | | | | | CONSTRAINT FAILURE: ⊤ <: ~(⊥(‘A64'''))
//│ | | | | | | | | | | | | | | | | | | | | | allVarPols: 
//│ | | | | | | | | | | | | | | | | | | | | | normLike[-] ~(⊥(‘A64'''))
//│ | | | | | | | | | | | | | | | | | | | | | | norm[-] ~(⊥(‘A64'''))
//│ | | | | | | | | | | | | | | | | | | | | | | | DNF: DNF(0, ~(⊥(‘A64''')))
//│ | | | | | | | | | | | | | | | | | | | | | | | norm[+] ⊥(‘A64''')
//│ | | | | | | | | | | | | | | | | | | | | | | | | DNF: DNF(0, {}∧⊥(‘A64'''))
//│ | | | | | | | | | | | | | | | | | | | | | | | ~> ⊥(‘A64''')
//│ | | | | | | | | | | | | | | | | | | | | | | ~> ~(⊥(‘A64'''))
//│ | | | | | | | | | | | | | | | | | | | | | allVarPols: 
//│ | | | | | | | | | | | | | | | | | | | | | normLike[+] ⊤
//│ | | | | | | | | | | | | | | | | | | | | | | norm[+] ⊤
//│ | | | | | | | | | | | | | | | | | | | | | | | DNF: DNF(0, )
//│ | | | | | | | | | | | | | | | | | | | | | | ~> ⊤
//│ | | | | | | | | | | | | | 1. C A39_56' <! ⊥..⊤    (2)
//│ | | | | | | | | | | | | | | 1. C A39_56' <! ⊥    (4)
//│ | | | | | | | | | | | | | | | NEW A39_56' UB (0)
//│ | | | | | | | | | | | | | | | 1. C (⊤(‘A64''') & ~(⊥(‘A58''))) <! ⊥    (6)
//│ | | | | | | | | | | | | | | | | 1. ARGH  DNF(0, {}∧⊤(‘A64''')∧~(⊥(‘A58'')))  <!  DNF(0, )
//│ | | | | | | | | | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | | | | | | | | | Consider {}∧⊤(‘A64''') <: DNF(0, {}∧⊥(‘A58''))
//│ | | | | | | | | | | | | | | | | | Possible: List({}∧⊥(‘A58''))
//│ | | | | | | | | | | | | | | | | | 1. A  {}∧⊤(‘A64''')  %  List()  <!  List(⊥(‘A58''))  %  ⊥
//│ | | | | | | | | | | | | | | | | | | 1. A  {}∧⊤(‘A64''')  %  List()  <!  List()  %  ⊥(‘A58'')
//│ | | | | | | | | | | | | | | | | | | | Tag checking TreeSet(⊤(‘A64''')) List(⊥(‘A58''))
//│ | | | | | | | | | | | | | | | | | | | CONSTRAINT FAILURE: (⊤(‘A64''') & ~(⊥(‘A58''))) <: ⊥
//│ | | | | | | | | | | | | | | | | | | | allVarPols: 
//│ | | | | | | | | | | | | | | | | | | | normLike[-] ⊥
//│ | | | | | | | | | | | | | | | | | | | | norm[-] ⊥
//│ | | | | | | | | | | | | | | | | | | | | | DNF: DNF(0, )
//│ | | | | | | | | | | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | | | | | | | | | allVarPols: 
//│ | | | | | | | | | | | | | | | | | | | normLike[+] (⊤(‘A64''') & ~(⊥(‘A58'')))
//│ | | | | | | | | | | | | | | | | | | | | norm[+] (⊤(‘A64''') & ~(⊥(‘A58'')))
//│ | | | | | | | | | | | | | | | | | | | | | DNF: DNF(0, {}∧⊤(‘A64''')∧~(⊥(‘A58'')))
//│ | | | | | | | | | | | | | | | | | | | | ~> (⊤(‘A64''') & ~(⊥(‘A58'')))
//│ | | | | | 1. : (α59' | #0<Int,Num,Object>)
//│ | | | | 1. : (α59' | #0<Int,Num,Object>)
//│ | | | 1. : (α59' | #0<Int,Num,Object>)
//│ | | 1. : ((l: K[‘L54'], r: K[‘L54'],) -> (α59' | #0<Int,Num,Object>))
//│ | | CONSTRAIN ((l: K[‘L54'], r: K[‘L54'],) -> (α59' | #0<Int,Num,Object>)) <! fr98'
//│ | |   where 
//│ 		α59' :> #error<> | (α65_94' | #0<Int,Num,Object>)
//│ 		α65_94' :> Int
//│ | | 1. C ((l: K[‘L54'], r: K[‘L54'],) -> (α59' | #0<Int,Num,Object>)) <! fr98'    (0)
//│ | | | NEW fr98' LB (1)
//│ | Completed TypedNuFun(0,NuFunDef(None,Var(fr),None,List(TypeName(L)),Left(Lam(Tup(List((Some(Var(l)),Fld(_,TyApp(Var(K),List(TypeName(L))))), (Some(Var(r)),Fld(_,TyApp(Var(K),List(TypeName(L))))))),Blk(List(If(IfThen(App(Var(and),Tup(List((None,Fld(_,App(Var(is),Tup(List((None,Fld(_,Var(l))), (None,Fld(_,App(Var(KS),Tup(List((None,Fld(_,Var(e1))))))))))))), (None,Fld(_,App(Var(is),Tup(List((None,Fld(_,Var(r))), (None,Fld(_,App(Var(KS),Tup(List((None,Fld(_,Var(e2)))))))))))))))),App(Var(fr),Tup(List((None,Fld(_,Var(e1))), (None,Fld(_,Var(e2))))))),Some(IntLit(0)))))))),((l: K[‘L54'], r: K[‘L54'],) -> (α59' | #0<Int,Num,Object>))) where 
//│ 		α59' :> #error<> | (α65_94' | #0<Int,Num,Object>)
//│ 		α65_94' :> Int
//│ | CHECKING SUBSUMPTION...
//│ | CONSTRAIN ‹∀ 0. ((l: K[‘L54'], r: K[‘L54'],) -> (α59' | #0<Int,Num,Object>))› <! ‹∀ 0. ‹∀ 0. ((K['L52'], K['L52'],) -> Int)››
//│ |   where 
//│ 		α59' :> #error<> | (α65_94' | #0<Int,Num,Object>)
//│ 		α65_94' :> Int
//│ | 0. C ‹∀ 0. ((l: K[‘L54'], r: K[‘L54'],) -> (α59' | #0<Int,Num,Object>))› <! ‹∀ 0. ‹∀ 0. ((K['L52'], K['L52'],) -> Int)››    (0)
//│ | | BUMP TO LEVEL 1  -->  ‹∀ 0. ((K['L52'], K['L52'],) -> Int)›
//│ | | where 
//│ | | 1. C ‹∀ 0. ((l: K[‘L54'], r: K[‘L54'],) -> (α59' | #0<Int,Num,Object>))› <! ‹∀ 0. ((K['L52'], K['L52'],) -> Int)›    (2)
//│ | | | New skolem: 'L52' ~> ‘L99''
//│ | | | BUMP TO LEVEL 2  -->  ((K[‘L99''], K[‘L99''],) -> Int)
//│ | | | where 
//│ | | | 2. C ‹∀ 0. ((l: K[‘L54'], r: K[‘L54'],) -> (α59' | #0<Int,Num,Object>))› <! ((K[‘L99''], K[‘L99''],) -> Int)    (4)
//│ | | | | INST [0]   ‹∀ 0. ((l: K[‘L54'], r: K[‘L54'],) -> (α59' | #0<Int,Num,Object>))›
//│ | | | |   where  
//│ 		α59' :> #error<> | (α65_94' | #0<Int,Num,Object>)
//│ 		α65_94' :> Int
//│ | | | | TO [2] ~>  ((l: K[L54_100''], r: K[L54_100''],) -> (α59_101'' | #0<Int,Num,Object>))
//│ | | | |   where  
//│ 		α59_101'' :> #error<> | (α65_102'' | #0<Int,Num,Object>)
//│ 		α65_102'' :> Int
//│ | | | | 2. C ((l: K[L54_100''], r: K[L54_100''],) -> (α59_101'' | #0<Int,Num,Object>)) <! ((K[‘L99''], K[‘L99''],) -> Int)    (6)
//│ | | | | | 2. C (K[‘L99''], K[‘L99''],) <! (l: K[L54_100''], r: K[L54_100''],)    (4)
//│ | | | | | | 2. C K[‘L99''] <! K[L54_100'']    (5)
//│ | | | | | | | 2. C ‘L99'' <! L54_100''    (6)
//│ | | | | | | | | NEW L54_100'' LB (2)
//│ | | | | | | | 2. C L54_100'' <! ‘L99''    (6)
//│ | | | | | | | | NEW L54_100'' UB (2)
//│ | | | | | | | | 2. C ‘L99'' <! ‘L99''    (9)
//│ | | | | | | | | | Already a subtype by <:<
//│ | | | | | | 2. C K[‘L99''] <! K[L54_100'']    (5)
//│ | | | | | | | Cached!
//│ | | | | | 2. C (α59_101'' | #0<Int,Num,Object>) <! Int    (4)
//│ | | | | | | 2. C α59_101'' <! Int    (7)
//│ | | | | | | | NEW α59_101'' UB (0)
//│ | | | | | | | 2. C #error<> <! Int    (10)
//│ | | | | | | | 2. C (α65_102'' | #0<Int,Num,Object>) <! Int    (10)
//│ | | | | | | | | 2. C α65_102'' <! Int    (13)
//│ | | | | | | | | | NEW α65_102'' UB (0)
//│ | | | | | | | | | 2. C Int <! Int    (16)
//│ | | | | | | | | | | Already a subtype by <:<
//│ | | | | | | | | 2. C #0<Int,Num,Object> <! Int    (13)
//│ | | | | | | | | | Already a subtype by <:<
//│ | | | | | | 2. C #0<Int,Num,Object> <! Int    (7)
//│ | | | | | | | Already a subtype by <:<
//│ | | | UNSTASHING...
//│ | | UNSTASHING...
//│ | CHECKING SUBSUMPTION...
//│ | CONSTRAIN ‹∀ 0. ‹∀ 0. ((K['L52'], K['L52'],) -> Int)›› <! ‹∀ 0. ‹∀ 0. ((K['L52'], K['L52'],) -> Int)››
//│ |   where 
//│ | 0. C ‹∀ 0. ‹∀ 0. ((K['L52'], K['L52'],) -> Int)›› <! ‹∀ 0. ‹∀ 0. ((K['L52'], K['L52'],) -> Int)››    (0)
//│ | | Already a subtype by <:<
//│ | Typing unit statements
//│ | : None
//│ ======== TYPED ========
//│ fun fr: ‹∀ 0. ((l: K[‘L54'], r: K[‘L54'],) -> (α59' | #0<Int,Num,Object>))› where 
//│ |		α59' :> #error<> | (α65_94' | #0<Int,Num,Object>)
//│ |		α65_94' :> Int
//│ fun fr: ‹∀ 0. ‹∀ 0. ((K['L52'], K['L52'],) -> Int)›› where 
//│ fun fr: forall 'L. (l: K['L], r: K['L]) -> (Int | error)
//│ fun fr: forall 'L0. (K['L0], K['L0]) -> Int

:e
fun fr: (K['L], K['L]) -> Int
fun fr[L](l: K[L], r: K[L]) =
  if l is KS(e1) and r is KS(e2) then fr(l, e2) else 0
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.760: 	  if l is KS(e1) and r is KS(e2) then fr(l, e2) else 0
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `anything` does not match type `S[in A & ?A out ?A0 | A] | L | ~??A`
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.758: 	fun fr: (K['L], K['L]) -> Int
//│ ║         	           ^^
//│ ╟── from type variable:
//│ ║  l.758: 	fun fr: (K['L], K['L]) -> Int
//│ ║         	                  ^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.14: 	class KS[A](ev: K[A]) extends K[S[A]]
//│ ╙──      	         ^
//│ fun fr: forall 'L. (l: K['L], r: K['L]) -> Int
//│ fun fr: forall 'L0. (K['L0], K['L0]) -> Int

// FIXME
:e
fun fr: (K['L], K['L]) -> Int
fun fr[L](l: K[L], r: K[L]) =
  if l is KS(e1) and r is KS(e2) then fr(e1, r) else 0
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.781: 	  if l is KS(e1) and r is KS(e2) then fr(e1, r) else 0
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `S[in ??A out ??A0 & ?A] & L & ~??A1` does not match type `~(L & ??A2)`
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.779: 	fun fr: (K['L], K['L]) -> Int
//│ ║         	                  ^^
//│ ╟── from type variable:
//│ ║  l.779: 	fun fr: (K['L], K['L]) -> Int
//│ ╙──       	           ^^
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.781: 	  if l is KS(e1) and r is KS(e2) then fr(e1, r) else 0
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `anything` does not match type `~(L & ??A)`
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.779: 	fun fr: (K['L], K['L]) -> Int
//│ ║         	                  ^^
//│ ╟── from type variable:
//│ ║  l.779: 	fun fr: (K['L], K['L]) -> Int
//│ ║         	           ^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.14: 	class KS[A](ev: K[A]) extends K[S[A]]
//│ ╙──      	         ^
//│ fun fr: forall 'L. (l: K['L], r: K['L]) -> (Int | error)
//│ fun fr: forall 'L0. (K['L0], K['L0]) -> Int

fun fk: (K['L], K['L]) -> Int
fun fk[L](l: K[L], r: K[L]) =
  if l is KS(e1) and r is KS(e2) then fk((e1 : K[e1.T]), (e2 : K[e2.T])) else 0
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.797: 	  if l is KS(e1) and r is KS(e2) then fk((e1 : K[e1.T]), (e2 : K[e2.T])) else 0
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── expression of type `anything` does not match type `~(S[?] & ??A)`
//│ TEST CASE FAILURE: There was an unexpected type error
//│ fun fk: forall 'L. (l: K['L], r: K['L]) -> Int
//│ fun fk: forall 'L0. (K['L0], K['L0]) -> Int

fun fz[L](l: K[L], r: K[L]) =
  if l is KS(ea) and r is KS(eb) then 
    let xw: K[eb.T] = ea : K[ea.T]; 0
  else 0
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.802: 	  if l is KS(ea) and r is KS(eb) then 
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.803: 	    let xw: K[eb.T] = ea : K[ea.T]; 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.804: 	  else 0
//│ ║         	^^^^^^^^
//│ ╙── expression of type `anything` does not match type `~(S[?] & ??A)`
//│ TEST CASE FAILURE: There was an unexpected type error
//│ fun fz: forall 'L. (l: K['L], r: K['L]) -> 0

:re
fk((error : K[S[S[nothing]]]), (error : K[S[S[nothing]]]))
//│ Int
//│ res
//│ Runtime error:
//│   Error: an error was thrown

:e
fk((error : K[S[S[nothing]]]), (error : K[S[nothing]]))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.815: 	fk((error : K[S[S[nothing]]]), (error : K[S[nothing]]))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `S[nothing]` does not match type `nothing`
//│ ║  l.815: 	fk((error : K[S[S[nothing]]]), (error : K[S[nothing]]))
//│ ║         	                ^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.815: 	fk((error : K[S[S[nothing]]]), (error : K[S[nothing]]))
//│ ╙──       	                                            ^^^^^^^
//│ Int | error
//│ res
//│ Runtime error:
//│   Error: an error was thrown

// * with alt

abstract class K[type T]: KZ | KS[?]
class KZ() extends K[Z]
class KS[type A](ev: K[A]) extends K[S[A]]
//│ abstract class K[T]: KS[?] | KZ
//│ class KZ() extends K
//│ class KS[A](ev: K[A]) extends K

fun get[A](x: K[S[A]]): K[A] = if x is KS(m) then m : K[x.T.P] else error
//│ fun get: forall 'A. (x: K[S['A]]) -> K['A]

fun fk: (K['L], K['L]) -> Int
fun fk[L](l: K[L], r: K[L]): Int =
  if l is KS(ep) and r is KS(eq) then 1 + fk(ep, eq) else 0
//│ ╔══[ERROR] Type error in operator application
//│ ║  l.844: 	  if l is KS(ep) and r is KS(eq) then 1 + fk(ep, eq) else 0
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.834: 	class KS[type A](ev: K[A]) extends K[S[A]]
//│ ║         	              ^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.842: 	fun fk: (K['L], K['L]) -> Int
//│ ╙──       	           ^^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] Type error in `case` expression
//│ ║  l.844: 	  if l is KS(ep) and r is KS(eq) then 1 + fk(ep, eq) else 0
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.834: 	class KS[type A](ev: K[A]) extends K[S[A]]
//│ ║         	              ^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.842: 	fun fk: (K['L], K['L]) -> Int
//│ ╙──       	           ^^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ fun fk: forall 'L. (l: K['L], r: K['L]) -> Int
//│ fun fk: forall 'L0. (K['L0], K['L0]) -> Int

fk(KS(KS(KZ())), KS(KS(KZ())))
//│ Int
//│ res
//│     = 2

:e
fk(KS(KS(KZ())), KS(KZ()))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.862: 	fk(KS(KS(KZ())), KS(KZ()))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Z` is not an instance of `S[?A]`
//│ ║  l.833: 	class KZ() extends K[Z]
//│ ║         	                     ^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.834: 	class KS[type A](ev: K[A]) extends K[S[A]]
//│ ║         	                                     ^^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.834: 	class KS[type A](ev: K[A]) extends K[S[A]]
//│ ╙──       	              ^
//│ Int | error
//│ res
//│     = 1

fun fi[L](x: K[L]): K[L] = if x is 
    KZ() then KZ() : K[x.T]
    KS(ea) then KS(ea) : K[x.T]
//│ fun fi: forall 'L. (x: K['L]) -> K['L]

fun fz[L](l: K[L], r: K[L]) =
  if l is KS(ea) and r is KS(eb) then
    let zt: K[ea.T] = ea ; 0
  else 0
//│ fun fz: forall 'L. (l: K['L], r: K['L]) -> 0

fun fz[L](l: KS[L], r: KS[L]) =
  if l is KS(ea) and r is KS(eb) then
    let zt: K[eb.T] = ea : K[ea.T] ; 0
  else 0
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.891: 	  if l is KS(ea) and r is KS(eb) then
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.892: 	    let zt: K[eb.T] = ea : K[ea.T] ; 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.893: 	  else 0
//│ ║         	^^^^^^^^
//│ ╟── type `L` does not match type `~(S[?] & L & ??A)`
//│ ║  l.890: 	fun fz[L](l: KS[L], r: KS[L]) =
//│ ║         	       ^
//│ ╟── Note: constraint arises from type selection:
//│ ║  l.892: 	    let zt: K[eb.T] = ea : K[ea.T] ; 0
//│ ║         	                ^^
//│ ╟── from type selection:
//│ ║  l.892: 	    let zt: K[eb.T] = ea : K[ea.T] ; 0
//│ ║         	                               ^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.834: 	class KS[type A](ev: K[A]) extends K[S[A]]
//│ ╙──       	              ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ fun fz: forall 'L. (l: KS['L], r: KS['L]) -> 0

fun fz[L](l: K[L], r: K[L]) =
  if l is KS(ea) and r is KS(eb) then
    let zt = ea : K[eb.T] ; 0
  else error
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.897: 	  if l is KS(ea) and r is KS(eb) then
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.898: 	    let zt = ea : K[eb.T] ; 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.899: 	  else error
//│ ║         	^^^^^^^^^^^^
//│ ╟── expression of type `Z & ??A & ~??A0` does not match type `~(??A1 & ??A)`
//│ ╟── Note: constraint arises from type selection:
//│ ║  l.898: 	    let zt = ea : K[eb.T] ; 0
//│ ╙──       	                      ^^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.897: 	  if l is KS(ea) and r is KS(eb) then
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.898: 	    let zt = ea : K[eb.T] ; 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.899: 	  else error
//│ ║         	^^^^^^^^^^^^
//│ ╟── expression of type `anything` does not match type `??A | ~(S[?] & ??A0 & ??A1)`
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.834: 	class KS[type A](ev: K[A]) extends K[S[A]]
//│ ╙──       	              ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ fun fz: forall 'L. (l: K['L], r: K['L]) -> error

fun fz[L](l: K[L], r: K[L]): K[L] =
  if l is KS(ea) and r is KS(eb) 
    then (KS(eb) : K[r.T]) : K[l.T]
    else error
//│ fun fz: forall 'L. (l: K['L], r: K['L]) -> K['L]

abstract class Eq[type A, type B]: Refl[A]
class Refl[A]() extends Eq[A, A]
//│ abstract class Eq[A, B]: Refl[A]
//│ class Refl[A]() extends Eq

fun conv[L, A](x: K[L], ev: Eq[L, S[A]]): K[S[A]] =
  if ev is Refl() then (x as K[ev.A]) as K[ev.B]
//│ fun conv: forall 'L 'A. (x: K['L], ev: Eq['L, S['A]]) -> K[S['A]]

conv(KS(KZ()), Refl())
//│ K[S[Z]]
//│ res
//│     = KS {}

:e
conv(KZ(), Refl())
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.935: 	conv(KZ(), Refl())
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── type `Z` is not an instance of `S[?A]`
//│ ║  l.833: 	class KZ() extends K[Z]
//│ ║         	                     ^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.925: 	fun conv[L, A](x: K[L], ev: Eq[L, S[A]]): K[S[A]] =
//│ ╙──       	                                  ^^^^
//│ K[S['A]] | error
//│ res
//│     = KZ {}

fun extr[L, H](x: K[L], ev: Eq[L, S[H]]): K[H] =
  let y: K[S[ev.B.P]] = x : K[ev.B]
  if y is KS(m) then m : K[y.T.P] else error
//│ fun extr: forall 'L 'H. (x: K['L], ev: Eq['L, S['H]]) -> K['H]

fun extr[L, H](x: K[L], ev: Eq[L, S[H]]): K[H] = get(x : K[ev.B])
//│ fun extr: forall 'L 'H. (x: K['L], ev: Eq['L, S['H]]) -> K['H]

extr(KS(KZ()), Refl())
//│ K[Z]
//│ res
//│     = KZ {}

:e
extr(KZ(), Refl())
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.963: 	extr(KZ(), Refl())
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── type `Z` is not an instance of `S[?H]`
//│ ║  l.833: 	class KZ() extends K[Z]
//│ ║         	                     ^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.954: 	fun extr[L, H](x: K[L], ev: Eq[L, S[H]]): K[H] = get(x : K[ev.B])
//│ ╙──       	                                  ^^^^
//│ K['H] | error
//│ res
//│ Runtime error:
//│   Error: an error was thrown

abstract class K[type T]: (KZ | KS[?]) {
  fun m: Eq[T, S['A]] -> Int
  fun m(ev) = if ev is Refl() then 0
  fun n: T -> T
  fun n(x) = x
}
class KZ() extends K[Z]
class KS[type A](ev: K[A]) extends K[S[A]]
//│ abstract class K[T]: KS[?] | KZ {
//│   fun m: forall 'A. Eq[T, S['A]] -> Int
//│   fun n: T -> T
//│ }
//│ class KZ() extends K {
//│   fun m: forall 'A0. Eq['T, S['A0]] -> Int
//│   fun n: 'T -> 'T
//│ }
//│ class KS[A](ev: K[A]) extends K {
//│   fun m: forall 'A1. Eq['T0, S['A1]] -> Int
//│   fun n: 'T0 -> 'T0
//│ }
//│ where
//│   'T0 := S[A]
//│   'T := Z

KS(KZ()).n(new S : S[Z])
KZ().n(new Z)
//│ Z
//│ res
//│     = S {}
//│ res
//│     = Z {}

:e
KS(KZ()).n(new Z)
KZ().n(new S : S[Z])
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1011: 	KS(KZ()).n(new Z)
//│ ║          	^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Z` is not an instance of `S[?A]`
//│ ║  l.1011: 	KS(KZ()).n(new Z)
//│ ║          	               ^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.985: 	class KS[type A](ev: K[A]) extends K[S[A]]
//│ ║         	                                     ^^^^
//│ ╟── Note: type parameter T is defined at:
//│ ║  l.978: 	abstract class K[type T]: (KZ | KS[?]) {
//│ ╙──       	                      ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1012: 	KZ().n(new S : S[Z])
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `S[Z]` is not an instance of `Z`
//│ ║  l.1012: 	KZ().n(new S : S[Z])
//│ ║          	               ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.984: 	class KZ() extends K[Z]
//│ ║         	                     ^
//│ ╟── Note: type parameter T is defined at:
//│ ║  l.978: 	abstract class K[type T]: (KZ | KS[?]) {
//│ ╙──       	                      ^
//│ Z | error
//│ res
//│     = Z {}
//│ res
//│     = S {}

KS(KZ()).m(Refl())
//│ Int
//│ res
//│     = 0

:e
KZ().m(Refl())
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1049: 	KZ().m(Refl())
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── type `Z` is not an instance of `S['A]`
//│ ║  l.984: 	class KZ() extends K[Z]
//│ ║         	                     ^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.979: 	  fun m: Eq[T, S['A]] -> Int
//│ ╙──       	               ^^^^^
//│ Int | error
//│ res
//│     = 0

class C[type A]()
//│ class C[A]()

fun test(k) =
  let f(x) = let c = C() in [k(c), c]
  f
//│ fun test: forall 'A 'A0 'a. (C[in 'A out 'A | 'A0] -> 'a) -> (forall 'A1. anything -> ['a, C['A1]])
//│   where
//│     'A1 :> 'A
//│         <: 'A0

class C[A, in B, out C]() { fun f: [A, B] -> [A, C] = f }
//│ class C[A, B, C]() {
//│   fun f: (A, B) -> [A, C]
//│ }

fun test(k) =
  let f(x) = let c = C() in [k(c), c]
  f
//│ fun test: forall 'A 'A0 'a. (C[in 'A out 'A | 'A0, anything, nothing] -> 'a) -> (forall 'A1. anything -> ['a, C['A1, anything, nothing]])
//│   where
//│     'A1 :> 'A
//│         <: 'A0


