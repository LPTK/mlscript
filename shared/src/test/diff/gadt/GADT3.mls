:NewDefs

abstract class Foo[type T]: Bar | Baz[?]
class Bar extends Foo[Int]
class Baz[T](val x: Foo[T]) extends Foo[[T]]
//│ abstract class Foo[T]: Bar | Baz[?]
//│ class Bar extends Foo {
//│   constructor()
//│ }
//│ class Baz[T](x: Foo[T]) extends Foo

fun foo: Foo['T] -> Int
fun foo[T](f: Foo[T]): Int = if f is
    Bar then 1
    Baz(x) then 1 + foo(x)
//│ fun foo: forall 'T. (f: Foo['T]) -> Int
//│ fun foo: forall 'T0. Foo['T0] -> Int

foo(Baz(Baz(new Bar)))
//│ Int
//│ res
//│     = 3

fun foo: Foo['a] -> Int
fun foo(f: Foo['a]) = if f is
    Bar then 1
    Baz(x) then 1 + foo(x as Foo[x.T])
//│ fun foo: forall 'a. (f: Foo['a]) -> Int
//│ fun foo: forall 'a0. Foo['a0] -> Int

fun foo: Foo['a] -> Int
fun foo(f) = if f is
    Bar then 1
    Baz(x) then 1 + foo(x)
//│ fun foo: (Bar | Baz[in anything out nothing]) -> Int
//│ fun foo: forall 'a. Foo['a] -> Int

// FIXME
fun foo: Foo[?] -> Int
fun foo(f: Foo[?]): Int = if f is
    Bar then 1
    Baz(x) then 1 + foo(x)
//│ ╔══[ERROR] Type error in operator application
//│ ║  l.40: 	fun foo(f: Foo[?]): Int = if f is
//│ ║        	                             ^^^^
//│ ║  l.41: 	    Bar then 1
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.42: 	    Baz(x) then 1 + foo(x)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `T` leaks out of its scope
//│ ║  l.5: 	class Baz[T](val x: Foo[T]) extends Foo[[T]]
//│ ║       	          ^
//│ ╟── back into type variable `T`
//│ ║  l.39: 	fun foo: Foo[?] -> Int
//│ ╙──      	             ^
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.40: 	fun foo(f: Foo[?]): Int = if f is
//│ ║        	                             ^^^^
//│ ║  l.41: 	    Bar then 1
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.42: 	    Baz(x) then 1 + foo(x)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `anything` does not match type `~??T`
//│ ╟── Note: constraint arises from wildcard:
//│ ║  l.39: 	fun foo: Foo[?] -> Int
//│ ║        	             ^
//│ ╟── Note: type parameter T is defined at:
//│ ║  l.5: 	class Baz[T](val x: Foo[T]) extends Foo[[T]]
//│ ╙──     	          ^
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.40: 	fun foo(f: Foo[?]): Int = if f is
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.41: 	    Bar then 1
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.42: 	    Baz(x) then 1 + foo(x)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.39: 	fun foo: Foo[?] -> Int
//│ ║        	             ^
//│ ╟── Note: constraint arises from wildcard:
//│ ║  l.40: 	fun foo(f: Foo[?]): Int = if f is
//│ ╙──      	               ^
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.39: 	fun foo: Foo[?] -> Int
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.39: 	fun foo: Foo[?] -> Int
//│ ╙──      	             ^
//│ fun foo: (f: Foo[?]) -> Int
//│ fun foo: Foo[?] -> Int

fun bar(f) = if f is 
    Bar then 0
    Baz(_) then 1
//│ fun bar: (Bar | Baz[in anything out nothing]) -> (0 | 1)

bar(Baz(new Bar))
//│ 0 | 1
//│ res
//│     = 1

abstract class C[type T]: D1 | D2
class D1 extends C[Int]
class D2[A, B](val a: C[A], val b: C[B]) extends C[[A, B]]
//│ abstract class C[T]: D1 | D2[?, ?]
//│ class D1 extends C {
//│   constructor()
//│ }
//│ class D2[A, B](a: C[A], b: C[B]) extends C

abstract class C[type T]: C1 | C2
class C1[type A](c: A) extends C[A]
class C2 extends C[Int]
//│ abstract class C[T]: C1[anything] | C2
//│ class C1[A](c: A) extends C
//│ class C2 extends C {
//│   constructor()
//│ }

:e // Needs type annot on parameter for GADT reasoning
fun foo: C['T] -> 'T
fun foo(x) = if x is
    C1(c) then c : x.T
    C2    then 0 : x.T
//│ ╔══[ERROR] Type error in definition
//│ ║  l.122: 	fun foo(x) = if x is
//│ ║         	    ^^^^^^^^^^^^^^^^
//│ ║  l.123: 	    C1(c) then c : x.T
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.124: 	    C2    then 0 : x.T
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.123: 	    C1(c) then c : x.T
//│ ║         	                    ^^
//│ ╟── into type `'T | ~??A`
//│ ║  l.121: 	fun foo: C['T] -> 'T
//│ ╙──       	                  ^^
//│ fun foo: forall 'A. (C1['A] | C2) -> (Int | ??A & 'A)
//│ fun foo: forall 'T. C['T] -> 'T

foo(C1(true))
//│ true
//│ res
//│     = true

foo(new C2)
//│ Int
//│ res
//│     = 0

fun foo(x: C['a]): x.T = if x is
    C1(c) then c : x.T
    C2    then 0 : x.T
//│ fun foo: forall 'a. (x: C['a]) -> ('a & (Int | ??A))

abstract class Option[type out T]: None | Some[T]
module None extends Option[nothing]
class Some[A](get: A) extends Option[A]
//│ abstract class Option[T]: None | Some[T]
//│ module None extends Option
//│ class Some[A](get: A) extends Option

fun getOr(x, d) = if x is
    None then d
    Some(g) then g
//│ fun getOr: forall 'A 'a. (None | Some['A], 'a) -> (??A & 'A | 'a)

fun getOr(x: Option['a], d) = if x is
    None then d
    Some(g) then g
//│ fun getOr: forall 'a 'b. (x: Option['a], 'b) -> (??A & 'a | 'b)

fun getOr[T](x: Option[T], d: T): T = if x is
    None then d
    Some(g) then g
//│ fun getOr: forall 'T. (x: Option['T], d: 'T) -> 'T

fun get(x) = if x is Some(r) then r else error
//│ fun get: forall 'A. (Object & ~#Some | Some['A]) -> (??A & 'A)

fun get(x: Option['a]): x.T = if x is Some(r) then r else error
//│ fun get: forall 'a. (x: Option[~??A & 'a]) -> 'a

None as Option[Int]
//│ Option[Int]
//│ res
//│     = None { class: [class None extends Option] }
