:NewDefs
:DontDistributeForalls

:NoJS



class Z 
class S[type P]
//│ class Z {
//│   constructor()
//│ }
//│ class S[P] {
//│   constructor()
//│ }



(x: S) => x as S[?]
//│ (x: S[?]) -> S[?]


class Foo[type A](val foo: Foo[A])
//│ class Foo[A](foo: Foo[A])


(x: Foo[?]) => x as Foo[?]
//│ (x: Foo[?]) -> Foo[?]

(x: Foo) => x as Foo[?]
//│ (x: Foo[?]) -> Foo[?]

(x: Foo[?]) => x as Foo
//│ (x: Foo[?]) -> Foo[?]

(x: Foo[?]) => x.foo as Foo[?]
//│ (x: Foo[?]) -> Foo[?]

(x: Foo) => x.foo as Foo[?]
//│ (x: Foo[?]) -> Foo[?]

:e
(x: Foo) => x.foo as x.A
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.43: 	(x: Foo) => x.foo as x.A
//│ ║        	            ^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.23: 	class Foo[type A](val foo: Foo[A])
//│ ╙──      	                           ^^^^^^
//│ (x: Foo[?]) -> ??A

:e
(x: Foo[?]) => x.foo as x.A
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.53: 	(x: Foo[?]) => x.foo as x.A
//│ ║        	               ^^^^^
//│ ╟── type `Foo[?]` does not match type `nothing`
//│ ║  l.23: 	class Foo[type A](val foo: Foo[A])
//│ ║        	                           ^^^^^^
//│ ╟── but it flows into field selection with expected type `nothing`
//│ ║  l.53: 	(x: Foo[?]) => x.foo as x.A
//│ ║        	               ^^^^^
//│ ╟── Note: constraint arises from type selection:
//│ ║  l.53: 	(x: Foo[?]) => x.foo as x.A
//│ ╙──      	                         ^^
//│ (x: Foo[?]) -> anything

:e
(x: Foo) => if x is
  Foo then
    x.foo as x.A
//│ ╔══[ERROR] Type error in `case` expression
//│ ║  l.69: 	(x: Foo) => if x is
//│ ║        	               ^^^^
//│ ║  l.70: 	  Foo then
//│ ║        	^^^^^^^^^^
//│ ║  l.71: 	    x.foo as x.A
//│ ║        	^^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.23: 	class Foo[type A](val foo: Foo[A])
//│ ╙──      	               ^
//│ (x: Foo[?]) -> (error | ??A & ??A0)

:e
(x: Foo[?]) => if x is
  Foo then
    x.foo as x.A
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.85: 	(x: Foo[?]) => if x is
//│ ║        	                  ^^^^
//│ ║  l.86: 	  Foo then
//│ ║        	^^^^^^^^^^
//│ ║  l.87: 	    x.foo as x.A
//│ ║        	^^^^^^^^^
//│ ╙── expression of type `Foo[in ??A out ??A0 & ?A] & ~??A` does not match type `nothing`
//│ (x: Foo[?]) -> ??A



fun fz(l) =
  if l is Foo(ea) and 0 is 0 then
    ea : Foo[ea.A]
//│ fun fz: forall 'A 'A0. Foo[in 'A out 'A0] -> Foo[in 'A & 'A0 | ??A out ??A0 & 'A0]




// abstract class K[type T]: KZ | KS[?]
abstract class K[type T]: KS[?]
// class KZ() extends K[Z]
class KS[type A](ev: K[A]) extends K[S[A]]
//│ abstract class K[T]: KS[?]
//│ class KS[A](ev: K[A]) extends K

:d

fun fz(l) =
  if l is KS(ea) then
    ea : K[ea.T]
//│ fun fz: forall 'A 'A0. KS[in 'A0 out 'A] -> K[in S[?] | 'A0 & 'A | ??A out ??A0 & 'A & S[?]]


// :d
fun fz(l) =
  if l is KS(ea) then
    () => ea : K[ea.T]
//│ fun fz: forall 'A 'A0. KS[in 'A out 'A0] -> () -> K[in S[in anything out nothing] | 'A & 'A0 | ??A out S[?] & ??A0 & 'A0]

// :d
fun fz(l) =
  if l is KS(ea) and 0 is 0 then
    ea : K[ea.T]
//│ fun fz: forall 'A 'A0. KS[in 'A out 'A0] -> K[in S[in anything out nothing] | 'A & 'A0 | ??A out S[?] & ??A0 & 'A0]



fun fz[L](l: K[L], r: K[L]) =
  if l is KS(ea) and r is KS(eb) then
    let zt: K[ea.T] = ea ; 0
  else 0
//│ fun fz: forall 'L. (l: K['L], r: K['L]) -> 0


// fun fr: (K['L], K['L]) -> Int
// :d
fun fr[L](l: K[L], r: K[L]) =
  if l is KS(e1) and r is KS(e2) then [e1, e2] : [K[L], K[L]] else 0
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.147: 	  if l is KS(e1) and r is KS(e2) then [e1, e2] : [K[L], K[L]] else 0
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `anything` does not match type `L | ~??A`
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.111: 	class KS[type A](ev: K[A]) extends K[S[A]]
//│ ╙──       	              ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.147: 	  if l is KS(e1) and r is KS(e2) then [e1, e2] : [K[L], K[L]] else 0
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `anything` does not match type `L | ~??A`
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.111: 	class KS[type A](ev: K[A]) extends K[S[A]]
//│ ╙──       	              ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ fun fr: forall 'L. (l: K['L], r: K['L]) -> (0 | [K['L], K['L]])







