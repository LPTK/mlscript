:NewDefs

abstract class Option[type out T]: None | Some[T]
class None extends Option[nothing]
class Some[A](val get: A) extends Option[A]
//│ abstract class Option[T]: None | Some[T]
//│ class None extends Option {
//│   constructor()
//│ }
//│ class Some[A](get: A) extends Option

class Box[type A](val get: A)
//│ class Box[A](get: A)

// * possibly the smallest loop case *

abstract class F[type A]: MkF
class MkF[T](t: T) extends F[Box[T]]
//│ abstract class F[A]: MkF[anything]
//│ class MkF[T](t: T) extends F

fun f[T](x: F[T]): T = if x is MkF(t) then Box(t) as x.A
//│ fun f: forall 'T. (x: F['T]) -> 'T

// * *

abstract class H[type A]: HI | HB | HG
module HI extends H[Option[Int]]
module HB extends H[Box[Bool]]
class HG[T](t: T) extends H[Option[Box[T]]]
//│ abstract class H[A]: HB | HG[anything] | HI
//│ module HI extends H
//│ module HB extends H
//│ class HG[T](t: T) extends H

fun h[A](x: H[A]): A = if x is
    HI then Some(1) as x.A
    HB then Box(false) as x.A
    HG(t) then Some(Box(t)) as x.A
//│ fun h: forall 'A. (x: H['A]) -> 'A

h(HG(1))
//│ Option[Box['T]]
//│   where
//│     'T :> 1
//│ res
//│     = Some {}

abstract class F[type A, type B]: MkF
class MkF[X](x: X) extends F[X, Some[Box[Int]]]
//│ abstract class F[A, B]: MkF[anything]
//│ class MkF[X](x: X) extends F

fun f[T](x: F[T, T]): Int = if x is
    MkF(m) then ((m as x.A) as x.B).get.get
//│ fun f: forall 'T. (x: F['T, 'T]) -> Int

f(MkF(Some(Box(1))))
//│ Int
//│ res
//│     = 1

abstract class F[type A, type B]: MkF
class MkF[type X](x: X) extends F[Some[X], Some[Box[Int]]]
//│ abstract class F[A, B]: MkF[anything]
//│ class MkF[X](x: X) extends F

fun f[T](x: F[T, T]): Int = if x is
    MkF(m) then ((Some(m) as x.A) as x.B).get.get
//│ fun f: forall 'T. (x: F['T, 'T]) -> Int

f(MkF(Box(1)))
//│ Int
//│ res
//│     = 1

:e
f(MkU(1))
//│ ╔══[ERROR] identifier not found: MkU
//│ ║  l.78: 	f(MkU(1))
//│ ╙──      	  ^^^
//│ Int
//│ Code generation encountered an error:
//│   unresolved symbol MkU

abstract class U[type A, type B, type C]: MkU
class MkU[S, T](s: S, t: T) extends U[S, T, Int]
//│ abstract class U[A, B, C]: MkU[anything, anything]
//│ class MkU[S, T](s: S, t: T) extends U

fun u[A](x: U[A, A, A]): A = if x is
    MkU(s, t) then (((s as x.A) as x.C) + ((t as x.B) as x.C)) as x.C
//│ fun u: forall 'A. (x: U['A, 'A, 'A]) -> 'A

u(MkU(1, 2))
//│ Int
//│ res
//│     = 3

:e
u(MkU(1, true))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.101: 	u(MkU(1, true))
//│ ║         	^^^^^^^^^^^^^^^
//│ ╟── reference of type `true` is not an instance of `Int`
//│ ║  l.101: 	u(MkU(1, true))
//│ ║         	         ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.87: 	class MkU[S, T](s: S, t: T) extends U[S, T, Int]
//│ ║        	                                            ^^^
//│ ╟── Note: type parameter C is defined at:
//│ ║  l.86: 	abstract class U[type A, type B, type C]: MkU
//│ ╙──      	                                      ^
//│ Int | error | true
//│ res
//│     = 2
