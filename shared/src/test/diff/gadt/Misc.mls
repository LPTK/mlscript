:NewDefs

class Ty[type T]
//│ class Ty[T] {
//│   constructor()
//│ }

abstract class Foo[type A](val a: A): Bar | Baz
module Bar extends Foo[Int](1)
module Baz extends Foo[Bool](true)
//│ abstract class Foo[A](a: A): Bar | Baz
//│ module Bar extends Foo
//│ module Baz extends Foo

fun foo(t)(x: Foo[t.T]): t.T = if x is 
    Bar then x.a
    Baz then x.a
//│ fun foo: forall 'T 'T0. {T :> 1 | true | 'T <: 'T0} -> (x: Foo[in 'T out 'T0]) -> 'T0

foo(new Ty)(Bar)
//│ 1 | true
//│ res
//│     = 1

abstract class S[type T]: A | B
module A extends S[Int]
module B extends S[Bool]
//│ abstract class S[T]: A | B
//│ module A extends S
//│ module B extends S

fun f(x: S['a]) = if x is
    A then 1 : x.T
    B then 2 : x.T
//│ fun f: forall 'a. (x: S['a]) -> ('a & (Int | false | true))
//│   where
//│     'a :> 2

f(A)
//│ Int
//│ res
//│     = 1

:e
f(B)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.45: 	f(B)
//│ ║        	^^^^
//│ ╟── integer literal of type `2` is not an instance of type `Bool`
//│ ║  l.34: 	    B then 2 : x.T
//│ ║        	           ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.27: 	module B extends S[Bool]
//│ ║        	                   ^^^^
//│ ╟── Note: type parameter T is defined at:
//│ ║  l.25: 	abstract class S[type T]: A | B
//│ ╙──      	                      ^
//│ 2 | error | false | true
//│ res
//│     = 2

:e
fun f(x: S): x.T = if x is A then 1 else 0
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.63: 	fun f(x: S): x.T = if x is A then 1 else 0
//│ ║        	                      ^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `T` leaks out of its scope
//│ ║  l.63: 	fun f(x: S): x.T = if x is A then 1 else 0
//│ ╙──      	                                  ^
//│ fun f: (x: S[in anything out nothing]) -> ??T

// TODO
fun f(x: S[?]): x.T = if x is 
    A then 1 : x.T
    B then true : x.T
    _ then error
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.73: 	fun f(x: S[?]): x.T = if x is 
//│ ║        	                         ^^^^^
//│ ║  l.74: 	    A then 1 : x.T
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.75: 	    B then true : x.T
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.76: 	    _ then error
//│ ║        	^^^^^^^^^^^^^^^^
//│ ╟── type `Int` is not an instance of type `Bool`
//│ ║  l.26: 	module A extends S[Int]
//│ ║        	                   ^^^
//│ ╟── but it flows into type selection with expected type `Bool`
//│ ║  l.74: 	    A then 1 : x.T
//│ ║        	                ^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.27: 	module B extends S[Bool]
//│ ║        	                   ^^^^
//│ ╟── from type selection:
//│ ║  l.73: 	fun f(x: S[?]): x.T = if x is 
//│ ╙──      	                 ^^
//│ fun f: (x: S[?]) -> (Int | false | true)

f(A)
//│ Int | false | true
//│ res
//│     = 1

abstract class C[type S, type T]: R[?] | I[?]
class R[A] extends C[A, A]
class I[A](val f: A => Int) extends C[A, Int]
//│ abstract class C[S, T]: I[?] | R[?]
//│ class R[A] extends C {
//│   constructor()
//│ }
//│ class I[A](f: A -> Int) extends C

fun foo[A, B](x: A, ev: C[A, B]): B = if ev is 
    R then (x : ev.S) : ev.T
    I(f) then ev.f(x : ev.S) : ev.T
//│ fun foo: forall 'A 'B. (x: 'A, ev: C['A, 'B]) -> 'B

foo(true, new R)
//│ true
//│ res
//│     = true

foo(1, I(x => x + 1))
//│ Int
//│ res
//│     = 2

module Foo { val a = 1 }
//│ module Foo {
//│   val a: 1
//│ }

Foo.a
//│ 1
//│ res
//│     = 1

abstract class Option[type out T]: None | Some[T]
module None extends Option[nothing]
class Some[A](get: A) extends Option[A]
//│ abstract class Option[T]: None | Some[T]
//│ module None extends Option
//│ class Some[A](get: A) extends Option

fun optToInt(w: Option[?]) = if w is Some then 1 else 0
//│ fun optToInt: (w: Option[nothing]) -> (0 | 1)

optToInt(Some(1))
//│ 0 | 1
//│ res
//│     = 1

optToInt(Some(1) as Option[Int])
//│ 0 | 1
//│ res
//│     = 1

optToInt(None)
//│ 0 | 1
//│ res
//│     = 0

optToInt(None as Option[nothing])
//│ 0 | 1
//│ res
//│     = 0

let x = Some(Some(1))
let y = Some(None)
//│ let x: Some['A]
//│ let y: Some['A0]
//│ where
//│   'A0 :> None
//│   'A :> Some['A1]
//│   'A1 :> 1
//│ x
//│   = Some {}
//│ y
//│   = Some {}

x : Option[Option[Int]]
//│ Option[Option[Int]]
//│ res
//│     = Some {}

y : Option[Option[nothing]]
//│ Option[Option[nothing]]
//│ res
//│     = Some {}

abstract class W[type T]: MkW[?]
class MkW[A](val w: A) extends W[Ty[A]]
//│ abstract class W[T]: MkW[?]
//│ class MkW[A](w: A) extends W

fun test(w: W[Ty[Int]]) = if w is MkW(x) then x
//│ fun test: (w: W[Ty[Int]]) -> ??A

test(MkW(1))
//│ ??A
//│ res
//│     = 1

fun test(w: W[?]) = if w is MkW(x) then x
//│ fun test: (w: W[?]) -> ??A

test(MkW(1))
//│ ??A
//│ res
//│     = 1

:e
fun test(a: Some[Int]) = true as a.T
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.214: 	fun test(a: Some[Int]) = true as a.T
//│ ║         	                         ^^^^
//│ ╟── reference of type `true` is not an instance of type `Int`
//│ ╟── Note: constraint arises from type selection:
//│ ║  l.214: 	fun test(a: Some[Int]) = true as a.T
//│ ╙──       	                                  ^^
//│ fun test: (a: Some[Int]) -> Int

// TODO
:e
fun test() = 
    let a = Some(1)
    true as a.T
//│ ╔══[ERROR] Cannot select from let binding or function
//│ ║  l.228: 	    true as a.T
//│ ╙──       	            ^
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: Can't find member `error`

// * maybe we should only allow type member access for function arguments
