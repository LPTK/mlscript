:NewDefs

fun fst([x, y]) = x
fun snd([x, y]) = y 
fun (++) stringConcat(a, b) = concat(a)(b)
//│ fun fst: forall 'a. (['a, anything]) -> 'a
//│ fun snd: forall 'b. ([anything, 'b]) -> 'b
//│ fun (++) stringConcat: (Str, Str) -> Str

// statically typed format //

abstract class Format[type F]: D[F] | B[F] | L[F] | E
class D[F](fmt: Format[F]) extends Format[Int -> F]
class B[F](fmt: Format[F]) extends Format[Bool -> F]
class L[F](s: Str, fmt: Format[F]) extends Format[F]
module E extends Format[Str]
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.13: 	class D[F](fmt: Format[F]) extends Format[Int -> F]
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `F` is not a function
//│ ║  l.13: 	class D[F](fmt: Format[F]) extends Format[Int -> F]
//│ ║        	        ^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.13: 	class D[F](fmt: Format[F]) extends Format[Int -> F]
//│ ║        	                                          ^^^^^^^^
//│ ╟── Note: type parameter F is defined at:
//│ ║  l.12: 	abstract class Format[type F]: D[F] | B[F] | L[F] | E
//│ ╙──      	                           ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.13: 	class D[F](fmt: Format[F]) extends Format[Int -> F]
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Int -> F` does not match type `F`
//│ ║  l.13: 	class D[F](fmt: Format[F]) extends Format[Int -> F]
//│ ║        	                                          ^^^^^^^^
//│ ╟── Note: constraint arises from type parameter:
//│ ║  l.13: 	class D[F](fmt: Format[F]) extends Format[Int -> F]
//│ ╙──      	        ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.14: 	class B[F](fmt: Format[F]) extends Format[Bool -> F]
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `F` is not a function
//│ ║  l.14: 	class B[F](fmt: Format[F]) extends Format[Bool -> F]
//│ ║        	        ^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.14: 	class B[F](fmt: Format[F]) extends Format[Bool -> F]
//│ ║        	                                          ^^^^^^^^^
//│ ╟── Note: type parameter F is defined at:
//│ ║  l.12: 	abstract class Format[type F]: D[F] | B[F] | L[F] | E
//│ ╙──      	                           ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.14: 	class B[F](fmt: Format[F]) extends Format[Bool -> F]
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Bool -> F` does not match type `F`
//│ ║  l.14: 	class B[F](fmt: Format[F]) extends Format[Bool -> F]
//│ ║        	                                          ^^^^^^^^^
//│ ╟── Note: constraint arises from type parameter:
//│ ║  l.14: 	class B[F](fmt: Format[F]) extends Format[Bool -> F]
//│ ╙──      	        ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ abstract class Format[F]: B[F] | D[F] | E | L[F]
//│ class D[F](fmt: Format[F]) extends Format
//│ class B[F](fmt: Format[F]) extends Format
//│ class L[F](s: Str, fmt: Format[F]) extends Format
//│ module E extends Format

fun fmtGo: (Str, Format['F]) -> 'F
fun fmtGo(acc, f:  Format['F]) = if f is
    D(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
    B(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
    L(s, fmt) then fmtGo(acc ++ s, fmt) : f.F
    E         then acc : f.F
//│ fun fmtGo: forall 'F. (Str & 'F | Str, f: Format['F]) -> ('F & (Str | nothing -> ('F & (??F & 'F | ??F0 & 'F)) | ??F1 & 'F))
//│ fun fmtGo: forall 'F0. (Str, Format['F0]) -> 'F0

fun fmt(f) = fmtGo("", f)
//│ fun fmt: forall 'F. Format['F] -> 'F

let test = L("int i = ", D(L(", bool b = ", B(E))))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.81: 	let test = L("int i = ", D(L(", bool b = ", B(E))))
//│ ║        	                           ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Bool -> ?F` is not an instance of type `Str`
//│ ║  l.14: 	class B[F](fmt: Format[F]) extends Format[Bool -> F]
//│ ║        	                                          ^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.16: 	module E extends Format[Str]
//│ ║        	                        ^^^
//│ ╟── Note: type parameter F is defined at:
//│ ║  l.15: 	class L[F](s: Str, fmt: Format[F]) extends Format[F]
//│ ╙──      	        ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.81: 	let test = L("int i = ", D(L(", bool b = ", B(E))))
//│ ║        	                         ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Str` is not a function
//│ ║  l.16: 	module E extends Format[Str]
//│ ║        	                        ^^^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.14: 	class B[F](fmt: Format[F]) extends Format[Bool -> F]
//│ ║        	                                          ^^^^^^^^^
//│ ╟── Note: type parameter F is defined at:
//│ ║  l.15: 	class L[F](s: Str, fmt: Format[F]) extends Format[F]
//│ ╙──      	        ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.81: 	let test = L("int i = ", D(L(", bool b = ", B(E))))
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Bool -> ?F` is not an instance of type `Str`
//│ ║  l.14: 	class B[F](fmt: Format[F]) extends Format[Bool -> F]
//│ ║        	                                          ^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.16: 	module E extends Format[Str]
//│ ║        	                        ^^^
//│ ╟── Note: type parameter F is defined at:
//│ ║  l.13: 	class D[F](fmt: Format[F]) extends Format[Int -> F]
//│ ╙──      	        ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ let test: error
//│ test
//│      = L {}

fmt(test)
//│ nothing
//│ res
//│     = [Function (anonymous)]

fmt(test)(114)(false)
//│ nothing
//│ res
//│     = 'int i = 114, bool b = false'

:e
fmt(test)("hello")("world")
//│ nothing
//│ res
//│     = 'int i = hello, bool b = world'
//│ TEST CASE FAILURE: There was an unexpected lack of type error

fun fmtGo[F](acc, f: Format[F]): F = if f is
    D(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
    B(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
    L(s, fmt) then fmtGo(acc ++ s, fmt) : f.F
    E         then acc : f.F
//│ fun fmtGo: forall 'F. (Str, f: Format['F]) -> 'F

fun fmt(f) = fmtGo("", f)
//│ fun fmt: forall 'F. Format['F] -> 'F


// typed ast //

abstract class Expr[type T]: Lit | Plus| Equals | If | Pair | Fst
class Lit(i: Int) extends Expr[Int]
class Plus(a: Expr[Int], b: Expr[Int]) extends Expr[Int]
class Equals(a: Expr[Int], b: Expr[Int]) extends Expr[Bool]
class If[A](p: Expr[Bool],a: Expr[A],b: Expr[A]) extends Expr[A]
class Pair[A, B](a: Expr[A], b: Expr[B]) extends Expr[[A, B]]
class Fst[A, B](p: Expr[[A, B]]) extends Expr[A]
//│ abstract class Expr[T]: Equals | Fst[?, ?] | If[?] | Lit | Pair[?, ?] | Plus
//│ class Lit(i: Int) extends Expr
//│ class Plus(a: Expr[Int], b: Expr[Int]) extends Expr
//│ class Equals(a: Expr[Int], b: Expr[Int]) extends Expr
//│ class If[A](p: Expr[Bool], a: Expr[A], b: Expr[A]) extends Expr
//│ class Pair[A, B](a: Expr[A], b: Expr[B]) extends Expr
//│ class Fst[A, B](p: Expr[[A, B]]) extends Expr

fun eval: Expr['T] -> 'T
fun eval(e: Expr['t]): e.T = if e is
    Lit(i) then i : e.T
    Plus(a, b) then eval(a) + eval(b) : e.T
    Equals(a, b) then (eval(a) == eval(b)) : e.T
    If(p, a, b) then if eval(p) then eval(a) : e.T else eval(b) : e.T
    Pair(a, b) then [eval(a), eval(b)] : e.T
    Fst(p) then fst(eval(p)) : e.T
//│ fun eval: forall 't. (e: Expr['t]) -> ('t & (Int | false | true | [??A, ??B] | ??A0 | ??A1))
//│ fun eval: forall 'T. Expr['T] -> 'T

eval(Plus(Lit(1), Lit(1)))
//│ Int
//│ res
//│     = 2

eval(If(Equals(Lit(3), Plus(Lit(1), Lit(1))), Fst(Pair(Lit(1), Lit(2))), Lit(3)))
//│ Int
//│ res
//│     = 3

:e
eval(Plus(Equals(Lit(1), Lit(2)), Lit(3)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.192: 	eval(Plus(Equals(Lit(1), Lit(2)), Lit(3)))
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Bool` is not an instance of type `Int`
//│ ║  l.158: 	class Equals(a: Expr[Int], b: Expr[Int]) extends Expr[Bool]
//│ ║         	                                                      ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.157: 	class Plus(a: Expr[Int], b: Expr[Int]) extends Expr[Int]
//│ ╙──       	                   ^^^
//│ nothing
//│ res
//│     = 3
