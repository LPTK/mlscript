:NewDefs

fun fst([x, y]) = x
fun snd([x, y]) = y 
fun (++) stringConcat(a, b) = concat(a)(b)
//│ fun fst: forall 'a. (['a, anything]) -> 'a
//│ fun snd: forall 'b. ([anything, 'b]) -> 'b
//│ fun (++) stringConcat: (Str, Str) -> Str

// statically typed format //

abstract class Format[type F]: D[?] | B[?] | L[?] | E
class D[F](fmt: Format[F]) extends Format[Int -> F]
class B[F](fmt: Format[F]) extends Format[Bool -> F]
class L[F](s: Str, fmt: Format[F]) extends Format[F]
module E extends Format[Str]
//│ abstract class Format[F]: B[?] | D[?] | E | L[?]
//│ class D[F](fmt: Format[F]) extends Format
//│ class B[F](fmt: Format[F]) extends Format
//│ class L[F](s: Str, fmt: Format[F]) extends Format
//│ module E extends Format

fun fmtGo: (Str, Format['F]) -> 'F
fun fmtGo(acc, f:  Format['F]) = if f is
    D(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
    B(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
    L(s, fmt) then fmtGo(acc ++ s, fmt) : f.F
    E         then acc : f.F
//│ fun fmtGo: forall 'F. (Str & 'F | Str, f: Format['F]) -> ('F & (Str | nothing -> (??F | ??F0) | ??F1))
//│ fun fmtGo: forall 'F0. (Str, Format['F0]) -> 'F0

fun fmt(f) = fmtGo("", f)
//│ fun fmt: forall 'F. Format['F] -> 'F

let test = L("int i = ", D(L(", bool b = ", B(E))))
//│ let test: L[Int -> Bool -> Str]
//│ test
//│      = L {}

fmt(test)
//│ Int -> Bool -> Str
//│ res
//│     = [Function (anonymous)]

fmt(test)(114)(false)
//│ Str
//│ res
//│     = 'int i = 114, bool b = false'

:e
fmt(test)("hello")("world")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.51: 	fmt(test)("hello")("world")
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"hello"` is not an instance of type `Int`
//│ ║  l.51: 	fmt(test)("hello")("world")
//│ ║        	          ^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.13: 	class D[F](fmt: Format[F]) extends Format[Int -> F]
//│ ╙──      	                                          ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.51: 	fmt(test)("hello")("world")
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"world"` is not an instance of type `Bool`
//│ ║  l.51: 	fmt(test)("hello")("world")
//│ ║        	                   ^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.14: 	class B[F](fmt: Format[F]) extends Format[Bool -> F]
//│ ╙──      	                                          ^^^^
//│ Str | error
//│ res
//│     = 'int i = hello, bool b = world'

// TODO
fun fmtGo[F](acc, f: Format[F]): F = if f is
    D(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
    B(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
    L(s, fmt) then fmtGo(acc ++ s, fmt) : f.F
    E         then acc : f.F
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.75: 	fun fmtGo[F](acc, f: Format[F]): F = if f is
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.76: 	    D(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.77: 	    B(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.78: 	    L(s, fmt) then fmtGo(acc ++ s, fmt) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.79: 	    E         then acc : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `anything` does not match type `F | ~??F`
//│ ╟── Note: method type parameter F is defined at:
//│ ║  l.75: 	fun fmtGo[F](acc, f: Format[F]): F = if f is
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.75: 	fun fmtGo[F](acc, f: Format[F]): F = if f is
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.76: 	    D(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.77: 	    B(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.78: 	    L(s, fmt) then fmtGo(acc ++ s, fmt) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.79: 	    E         then acc : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `F & ~??F` does not match type `nothing`
//│ ╟── Note: type parameter F is defined at:
//│ ║  l.15: 	class L[F](s: Str, fmt: Format[F]) extends Format[F]
//│ ╙──      	        ^
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.75: 	fun fmtGo[F](acc, f: Format[F]): F = if f is
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.76: 	    D(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.77: 	    B(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.78: 	    L(s, fmt) then fmtGo(acc ++ s, fmt) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.79: 	    E         then acc : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `anything` does not match type `F | ~??F`
//│ ╟── Note: method type parameter F is defined at:
//│ ║  l.75: 	fun fmtGo[F](acc, f: Format[F]): F = if f is
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.75: 	fun fmtGo[F](acc, f: Format[F]): F = if f is
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.76: 	    D(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.77: 	    B(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.78: 	    L(s, fmt) then fmtGo(acc ++ s, fmt) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.79: 	    E         then acc : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `F & ~??F` does not match type `nothing`
//│ ╟── Note: type parameter F is defined at:
//│ ║  l.14: 	class B[F](fmt: Format[F]) extends Format[Bool -> F]
//│ ╙──      	        ^
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.75: 	fun fmtGo[F](acc, f: Format[F]): F = if f is
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.76: 	    D(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.77: 	    B(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.78: 	    L(s, fmt) then fmtGo(acc ++ s, fmt) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.79: 	    E         then acc : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `anything` does not match type `F | ~??F`
//│ ╟── Note: method type parameter F is defined at:
//│ ║  l.75: 	fun fmtGo[F](acc, f: Format[F]): F = if f is
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.75: 	fun fmtGo[F](acc, f: Format[F]): F = if f is
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.76: 	    D(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.77: 	    B(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.78: 	    L(s, fmt) then fmtGo(acc ++ s, fmt) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.79: 	    E         then acc : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `F & ~??F` does not match type `nothing`
//│ ╟── Note: type parameter F is defined at:
//│ ║  l.13: 	class D[F](fmt: Format[F]) extends Format[Int -> F]
//│ ╙──      	        ^
//│ fun fmtGo: forall 'F. (Str, f: Format['F]) -> 'F

fun fmt(f) = fmtGo("", f)
//│ fun fmt: forall 'F. Format['F] -> 'F


// typed ast //

abstract class Expr[type T]: Lit | Plus| Equals | If[?] | Pair[?,?] | Fst[?,?]
class Lit(i: Int) extends Expr[Int]
class Plus(a: Expr[Int], b: Expr[Int]) extends Expr[Int]
class Equals(a: Expr[Int], b: Expr[Int]) extends Expr[Bool]
class If[A](p: Expr[Bool],a: Expr[A],b: Expr[A]) extends Expr[A]
class Pair[A, B](a: Expr[A], b: Expr[B]) extends Expr[[A, B]]
class Fst[A, B](p: Expr[[A, B]]) extends Expr[A]
//│ abstract class Expr[T]: Equals | Fst[?, ?] | If[?] | Lit | Pair[?, ?] | Plus
//│ class Lit(i: Int) extends Expr
//│ class Plus(a: Expr[Int], b: Expr[Int]) extends Expr
//│ class Equals(a: Expr[Int], b: Expr[Int]) extends Expr
//│ class If[A](p: Expr[Bool], a: Expr[A], b: Expr[A]) extends Expr
//│ class Pair[A, B](a: Expr[A], b: Expr[B]) extends Expr
//│ class Fst[A, B](p: Expr[[A, B]]) extends Expr

fun eval: Expr['T] -> 'T
fun eval(e: Expr['t]): e.T = if e is
    Lit(i) then i : e.T
    Plus(a, b) then eval(a) + eval(b) : e.T
    Equals(a, b) then (eval(a) == eval(b)) : e.T
    If(p, a, b) then if eval(p) then eval(a) : e.T else eval(b) : e.T
    Pair(a, b) then [eval(a), eval(b)] : e.T
    Fst(p) then fst(eval(p)) : e.T
//│ fun eval: forall 't. (e: Expr['t]) -> 't
//│ fun eval: forall 'T. Expr['T] -> 'T

eval(Plus(Lit(1), Lit(1)))
//│ Int
//│ res
//│     = 2

eval(If(Equals(Lit(3), Plus(Lit(1), Lit(1))), Fst(Pair(Lit(1), Lit(2))), Lit(3)))
//│ Int
//│ res
//│     = 3

:e
eval(Plus(Equals(Lit(1), Lit(2)), Lit(3)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.215: 	eval(Plus(Equals(Lit(1), Lit(2)), Lit(3)))
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Bool` is not an instance of type `Int`
//│ ║  l.181: 	class Equals(a: Expr[Int], b: Expr[Int]) extends Expr[Bool]
//│ ║         	                                                      ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.180: 	class Plus(a: Expr[Int], b: Expr[Int]) extends Expr[Int]
//│ ╙──       	                   ^^^
//│ nothing
//│ res
//│     = 3
