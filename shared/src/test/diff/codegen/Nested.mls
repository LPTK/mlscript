:NewParser
:NewDefs

:js
module A {
  let a = 42
  class B(x: int) {
    fun b = x + 1
  }
}
//│ module A() {
//│   class B(x: int) {
//│     fun b: int
//│   }
//│   let a: 42
//│ }
//│ // Prelude
//│ let res;
//│ let typing_unit = {
//│   cache: {},
//│   get A() {
//│     const outter1 = this;
//│     const cache = this.cache;
//│     if (this.cache.A === undefined) {
//│       class A {
//│         #a;
//│         get a() { return this.#a; }
//│         constructor() {
//│           this.#a = 42;
//│           const a = this.#a;
//│         }
//│         cache = {};
//│         get B() {
//│           const outter = this;
//│           const cache = this.cache;
//│           if (this.cache.B === undefined) {
//│             class B {
//│               #x;
//│               get x() { return this.#x; }
//│               constructor(x) {
//│                 this.#x = x;
//│               }
//│               get b() {
//│                 const B = cache.B;
//│                 const x = this.#x;
//│                 return x + 1;
//│               }
//│             };
//│             this.cache.B = ((x) => new B(x));
//│             this.cache.B["class"] = B;
//│           }
//│           return this.cache.B;
//│         }
//│       }
//│       this.cache.A = new A();
//│       this.cache.A["class"] = A;
//│     }
//│     return this.cache.A;
//│   }
//│ };
//│ globalThis.A = typing_unit.A;
//│ // End of generated code

:e
:js
let bb = A.B(A.a)
bb.b
//│ ╔══[ERROR] access to class member not yet supported
//│ ║  l.66: 	let bb = A.B(A.a)
//│ ╙──      	          ^^
//│ let bb: error
//│ error
//│ // Prelude
//│ let typing_unit1 = { cache: {} };
//│ // Query 1
//│ globalThis.bb = A.B(A.a);
//│ // Query 2
//│ res = bb.b;
//│ // End of generated code
//│ bb
//│    = B {}
//│ res
//│     = 43

:js
class B(x: int) {
  let cache = 42
  class C(y: int) {
  }
}
//│ class B(x: int) {
//│   class C(y: int)
//│   let cache: 42
//│ }
//│ // Prelude
//│ let typing_unit2 = {
//│   cache: {},
//│   get B() {
//│     const outter1 = this;
//│     const cache = this.cache;
//│     if (this.cache.B === undefined) {
//│       class B {
//│         #x;
//│         #cache;
//│         get x() { return this.#x; }
//│         get cache() { return this.#cache; }
//│         constructor(x) {
//│           this.#x = x;
//│           this.#cache = 42;
//│           const cache = this.#cache;
//│         }
//│         cache1 = {};
//│         get C() {
//│           const outter = this;
//│           const cache = this.cache1;
//│           if (this.cache1.C === undefined) {
//│             class C {
//│               #y;
//│               get y() { return this.#y; }
//│               constructor(y) {
//│                 this.#y = y;
//│               }
//│             };
//│             this.cache1.C = ((y) => new C(y));
//│             this.cache1.C["class"] = C;
//│           }
//│           return this.cache1.C;
//│         }
//│       };
//│       this.cache.B = ((x) => new B(x));
//│       this.cache.B["class"] = B;
//│     }
//│     return this.cache.B;
//│   }
//│ };
//│ globalThis.B = typing_unit2.B;
//│ // End of generated code

:js
mixin C() {
  mixin D() {
    mixin E() {}
  }
}
//│ mixin C() {
//│   mixin D() {
//│     mixin E()
//│   }
//│ }
//│ // Prelude
//│ let typing_unit3 = {
//│   cache: {},
//│   C(base) {
//│     const outter1 = this;
//│     return (class C extends base {
//│       constructor(...rest) {
//│         super(...rest);
//│       }
//│       cache = {};
//│       D(base) {
//│         const outter = this;
//│         return (class D extends base {
//│           constructor(...rest) {
//│             super(...rest);
//│           }
//│           cache = {};
//│           E(base) {
//│             const outter1 = this;
//│             return (class E extends base {
//│               constructor(...rest) {
//│                 super(...rest);
//│               }
//│             });
//│           }
//│         });
//│       }
//│     });
//│   }
//│ };
//│ globalThis.C = typing_unit3.C;
//│ // End of generated code

:js
module D {
  class E(x: int) {}
  fun createE(x: int) = E(x + 1)
}
//│ module D() {
//│   class E(x: int)
//│   fun createE: (x: int,) -> E
//│ }
//│ // Prelude
//│ let typing_unit4 = {
//│   cache: {},
//│   get D() {
//│     const outter1 = this;
//│     const cache = this.cache;
//│     if (this.cache.D === undefined) {
//│       class D {
//│         constructor() {
//│         }
//│         createE(x) {
//│           const self = this;
//│           return self.E(x + 1);
//│         }
//│         cache = {};
//│         get E() {
//│           const outter = this;
//│           const cache = this.cache;
//│           if (this.cache.E === undefined) {
//│             class E {
//│               #x;
//│               get x() { return this.#x; }
//│               constructor(x) {
//│                 this.#x = x;
//│               }
//│             };
//│             this.cache.E = ((x) => new E(x));
//│             this.cache.E["class"] = E;
//│           }
//│           return this.cache.E;
//│         }
//│       }
//│       this.cache.D = new D();
//│       this.cache.D["class"] = D;
//│     }
//│     return this.cache.D;
//│   }
//│ };
//│ globalThis.D = typing_unit4.D;
//│ // End of generated code

:js
let ee = D.createE(42)
ee.x
//│ let ee: E
//│ int
//│ // Prelude
//│ let typing_unit5 = { cache: {} };
//│ // Query 1
//│ globalThis.ee = D.createE(42);
//│ // Query 2
//│ res = ee.x;
//│ // End of generated code
//│ ee
//│    = E {}
//│ res
//│     = 43

:js
class E(x: int) {
  class F(y: int) {
    fun sum = x + y
    class G(z: int) {
      fun sum = x + y + z
    }
  }
}
//│ class E(x: int) {
//│   class F(y: int) {
//│     class G(z: int) {
//│       fun sum: int
//│     }
//│     fun sum: int
//│   }
//│ }
//│ // Prelude
//│ let typing_unit6 = {
//│   cache: {},
//│   get E() {
//│     const outter1 = this;
//│     const cache = this.cache;
//│     if (this.cache.E === undefined) {
//│       class E {
//│         #x;
//│         get x() { return this.#x; }
//│         constructor(x) {
//│           this.#x = x;
//│         }
//│         cache = {};
//│         get F() {
//│           const outter = this;
//│           const cache = this.cache;
//│           if (this.cache.F === undefined) {
//│             class F {
//│               #y;
//│               get y() { return this.#y; }
//│               constructor(y) {
//│                 this.#y = y;
//│               }
//│               get sum() {
//│                 const F = cache.F;
//│                 const x = outter.x;
//│                 const y = this.#y;
//│                 return x + y;
//│               }
//│               cache = {};
//│               get G() {
//│                 const outter1 = this;
//│                 const x = outter.x;
//│                 const cache = this.cache;
//│                 if (this.cache.G === undefined) {
//│                   class G {
//│                     #z;
//│                     get z() { return this.#z; }
//│                     constructor(z) {
//│                       this.#z = z;
//│                     }
//│                     get sum() {
//│                       const G = cache.G;
//│                       const y = outter1.y;
//│                       const z = this.#z;
//│                       return x + y + z;
//│                     }
//│                   };
//│                   this.cache.G = ((z) => new G(z));
//│                   this.cache.G["class"] = G;
//│                 }
//│                 return this.cache.G;
//│               }
//│             };
//│             this.cache.F = ((y) => new F(y));
//│             this.cache.F["class"] = F;
//│           }
//│           return this.cache.F;
//│         }
//│       };
//│       this.cache.E = ((x) => new E(x));
//│       this.cache.E["class"] = E;
//│     }
//│     return this.cache.E;
//│   }
//│ };
//│ globalThis.E = typing_unit6.E;
//│ // End of generated code

:e
:js
let es = E(1)
let fff = es.F(2)
let gg = fff.G(3)
gg.sum
//│ ╔══[ERROR] access to class member not yet supported
//│ ║  l.340: 	let fff = es.F(2)
//│ ╙──       	            ^^
//│ let es: E
//│ let fff: error
//│ let gg: error
//│ error
//│ // Prelude
//│ let typing_unit7 = { cache: {} };
//│ // Query 1
//│ globalThis.es = E(1);
//│ // Query 2
//│ globalThis.fff = es.F(2);
//│ // Query 3
//│ globalThis.gg = fff.G(3);
//│ // Query 4
//│ res = gg.sum;
//│ // End of generated code
//│ es
//│    = E { cache: {} }
//│ fff
//│     = F { cache: {} }
//│ gg
//│    = G {}
//│ res
//│     = 6

:js
class F() {
  let x = 42
  class G() {
    let x1 = x + 1
  }
}
//│ class F() {
//│   class G() {
//│     let x1: int
//│   }
//│   let x: 42
//│ }
//│ // Prelude
//│ let typing_unit8 = {
//│   cache: {},
//│   get F() {
//│     const outter1 = this;
//│     const cache = this.cache;
//│     if (this.cache.F === undefined) {
//│       class F {
//│         #x;
//│         get x() { return this.#x; }
//│         constructor() {
//│           this.#x = 42;
//│           const x = this.#x;
//│         }
//│         cache = {};
//│         get G() {
//│           const outter = this;
//│           const cache = this.cache;
//│           if (this.cache.G === undefined) {
//│             class G {
//│               #x1;
//│               get x1() { return this.#x1; }
//│               constructor() {
//│                 const x = outter.x;
//│                 this.#x1 = x + 1;
//│                 const x1 = this.#x1;
//│               }
//│             };
//│             this.cache.G = (() => new G());
//│             this.cache.G["class"] = G;
//│           }
//│           return this.cache.G;
//│         }
//│       };
//│       this.cache.F = (() => new F());
//│       this.cache.F["class"] = F;
//│     }
//│     return this.cache.F;
//│   }
//│ };
//│ globalThis.F = typing_unit8.F;
//│ // End of generated code


:js
module G {
  class I(x: int) {}
  module H {
    fun i1(x: int) = I(x + 1)
    class J(x: int) {
      fun ii(a: int) = I(x + a)
    }
  }
}
//│ module G() {
//│   module H() {
//│     class J(x: int) {
//│       fun ii: (a: int,) -> I
//│     }
//│     fun i1: (x: int,) -> I
//│   }
//│   class I(x: int)
//│ }
//│ // Prelude
//│ let typing_unit9 = {
//│   cache: {},
//│   get G() {
//│     const outter1 = this;
//│     const cache = this.cache;
//│     if (this.cache.G === undefined) {
//│       class G {
//│         constructor() {
//│         }
//│         cache = {};
//│         get H() {
//│           const outter = this;
//│           const cache = this.cache;
//│           if (this.cache.H === undefined) {
//│             class H {
//│               constructor() {
//│               }
//│               i1(x) {
//│                 const I = outter.I;
//│                 return I(x + 1);
//│               }
//│               cache = {};
//│               get J() {
//│                 const outter1 = this;
//│                 const I = outter.I;
//│                 const cache = this.cache;
//│                 if (this.cache.J === undefined) {
//│                   class J {
//│                     #x;
//│                     get x() { return this.#x; }
//│                     constructor(x) {
//│                       this.#x = x;
//│                     }
//│                     ii(a) {
//│                       const J = cache.J;
//│                       const x = this.#x;
//│                       return I(x + a);
//│                     }
//│                   };
//│                   this.cache.J = ((x) => new J(x));
//│                   this.cache.J["class"] = J;
//│                 }
//│                 return this.cache.J;
//│               }
//│             }
//│             this.cache.H = new H();
//│             this.cache.H["class"] = H;
//│           }
//│           return this.cache.H;
//│         }
//│         get I() {
//│           const outter = this;
//│           const cache = this.cache;
//│           if (this.cache.I === undefined) {
//│             class I {
//│               #x;
//│               get x() { return this.#x; }
//│               constructor(x) {
//│                 this.#x = x;
//│               }
//│             };
//│             this.cache.I = ((x) => new I(x));
//│             this.cache.I["class"] = I;
//│           }
//│           return this.cache.I;
//│         }
//│       }
//│       this.cache.G = new G();
//│       this.cache.G["class"] = G;
//│     }
//│     return this.cache.G;
//│   }
//│ };
//│ globalThis.G = typing_unit9.G;
//│ // End of generated code


:e
:js
let jj = G.H.J(42)
let i = jj.ii(2)
i.x
//│ ╔══[ERROR] access to module member not yet supported
//│ ║  l.526: 	let jj = G.H.J(42)
//│ ╙──       	          ^^
//│ let jj: error
//│ let i: error
//│ error
//│ // Prelude
//│ let typing_unit10 = { cache: {} };
//│ // Query 1
//│ globalThis.jj = G.H.J(42);
//│ // Query 2
//│ globalThis.i = jj.ii(2);
//│ // Query 3
//│ res = i.x;
//│ // End of generated code
//│ jj
//│    = J {}
//│ i
//│   = I {}
//│ res
//│     = 44

:js
module H {
  class I(x: int)
  class J(x: int) {
    let i = I(x + 1)
  }
}
//│ module H() {
//│   class I(x: int)
//│   class J(x: int) {
//│     let i: I
//│   }
//│ }
//│ // Prelude
//│ let typing_unit11 = {
//│   cache: {},
//│   get H() {
//│     const outter1 = this;
//│     const cache = this.cache;
//│     if (this.cache.H === undefined) {
//│       class H {
//│         constructor() {
//│         }
//│         cache = {};
//│         get I() {
//│           const outter = this;
//│           const cache = this.cache;
//│           if (this.cache.I === undefined) {
//│             class I {
//│               #x;
//│               get x() { return this.#x; }
//│               constructor(x) {
//│                 this.#x = x;
//│               }
//│             };
//│             this.cache.I = ((x) => new I(x));
//│             this.cache.I["class"] = I;
//│           }
//│           return this.cache.I;
//│         }
//│         get J() {
//│           const outter = this;
//│           const cache = this.cache;
//│           if (this.cache.J === undefined) {
//│             class J {
//│               #x;
//│               #i;
//│               get x() { return this.#x; }
//│               get i() { return this.#i; }
//│               constructor(x) {
//│                 this.#x = x;
//│                 const I = outter.I;
//│                 this.#i = I(x + 1);
//│                 const i = this.#i;
//│               }
//│             };
//│             this.cache.J = ((x) => new J(x));
//│             this.cache.J["class"] = J;
//│           }
//│           return this.cache.J;
//│         }
//│       }
//│       this.cache.H = new H();
//│       this.cache.H["class"] = H;
//│     }
//│     return this.cache.H;
//│   }
//│ };
//│ globalThis.H = typing_unit11.H;
//│ // End of generated code


:e
:js
let j = H.J(42)
j.i.x
//│ ╔══[ERROR] access to class member not yet supported
//│ ║  l.625: 	let j = H.J(42)
//│ ╙──       	         ^^
//│ let j: error
//│ error
//│ // Prelude
//│ let typing_unit12 = { cache: {} };
//│ // Query 1
//│ globalThis.j = H.J(42);
//│ // Query 2
//│ res = j.i.x;
//│ // End of generated code
//│ j
//│   = J {}
//│ res
//│     = 43

:js
class I(x: int) {
  let y = x + 1
  class J(x: int) {
    let y = x + 2
    fun incY = y + 1
  }
}
//│ class I(x: int) {
//│   class J(x: int) {
//│     fun incY: int
//│     let y: int
//│   }
//│   let y: int
//│ }
//│ // Prelude
//│ let typing_unit13 = {
//│   cache: {},
//│   get I() {
//│     const outter1 = this;
//│     const cache = this.cache;
//│     if (this.cache.I === undefined) {
//│       class I {
//│         #x;
//│         #y;
//│         get x() { return this.#x; }
//│         get y() { return this.#y; }
//│         constructor(x) {
//│           this.#x = x;
//│           this.#y = x + 1;
//│           const y = this.#y;
//│         }
//│         cache = {};
//│         get J() {
//│           const outter = this;
//│           const cache = this.cache;
//│           if (this.cache.J === undefined) {
//│             class J {
//│               #x;
//│               #y;
//│               get x() { return this.#x; }
//│               get y() { return this.#y; }
//│               constructor(x) {
//│                 this.#x = x;
//│                 this.#y = x + 2;
//│                 const y1 = this.#y;
//│               }
//│               get incY() {
//│                 const J = cache.J;
//│                 const y = outter.y;
//│                 const x1 = this.#x;
//│                 return y + 1;
//│               }
//│             };
//│             this.cache.J = ((x) => new J(x));
//│             this.cache.J["class"] = J;
//│           }
//│           return this.cache.J;
//│         }
//│       };
//│       this.cache.I = ((x) => new I(x));
//│       this.cache.I["class"] = I;
//│     }
//│     return this.cache.I;
//│   }
//│ };
//│ globalThis.I = typing_unit13.I;
//│ // End of generated code

:e
:js
let i = I(1)
let ij = i.J(0)
ij.incY
//│ ╔══[ERROR] access to class member not yet supported
//│ ║  l.716: 	let ij = i.J(0)
//│ ╙──       	          ^^
//│ let i: I
//│ let ij: error
//│ error
//│ // Prelude
//│ let typing_unit14 = { cache: {} };
//│ // Query 1
//│ globalThis.i1 = I(1);
//│ // Query 2
//│ globalThis.ij = i1.J(0);
//│ // Query 3
//│ res = ij.incY;
//│ // End of generated code
//│ i
//│   = I { cache: {} }
//│ ij
//│    = J {}
//│ res
//│     = 3

:e
:js
module J {
  class K(x: int) {}
  mixin L() {}
  class M() extends K(1) {}
  class N(x: int) extends L
}
//│ ╔══[ERROR] Class inheritance is not supported yet (use mixins)
//│ ║  l.745: 	  class M() extends K(1) {}
//│ ╙──       	                    ^^^^
//│ module J() {
//│   class K(x: int)
//│   mixin L()
//│   class M()
//│   class N(x: int)
//│ }
//│ // Prelude
//│ let typing_unit15 = {
//│   cache: {},
//│   get J() {
//│     const outter1 = this;
//│     const cache = this.cache;
//│     if (this.cache.J === undefined) {
//│       class J {
//│         constructor() {
//│         }
//│         cache = {};
//│         L(base) {
//│           const outter = this;
//│           return (class L extends base {
//│             constructor(...rest) {
//│               super(...rest);
//│             }
//│           });
//│         }
//│         get K() {
//│           const outter = this;
//│           const cache = this.cache;
//│           if (this.cache.K === undefined) {
//│             class K {
//│               #x;
//│               get x() { return this.#x; }
//│               constructor(x) {
//│                 this.#x = x;
//│               }
//│             };
//│             this.cache.K = ((x) => new K(x));
//│             this.cache.K["class"] = K;
//│           }
//│           return this.cache.K;
//│         }
//│         get M() {
//│           const outter = this;
//│           const cache = this.cache;
//│           if (this.cache.M === undefined) {
//│             class M extends outter.K["class"] {
//│               constructor() {
//│                 super(1);
//│                 const K = outter.K;
//│               }
//│             };
//│             this.cache.M = (() => new M());
//│             this.cache.M["class"] = M;
//│           }
//│           return this.cache.M;
//│         }
//│         get N() {
//│           const outter = this;
//│           const cache = this.cache;
//│           if (this.cache.N === undefined) {
//│             class N extends outter.L(Object) {
//│               #x;
//│               get x() { return this.#x; }
//│               constructor(x) {
//│                 super();
//│                 this.#x = x;
//│                 const L = outter.L;
//│               }
//│             };
//│             this.cache.N = ((x) => new N(x));
//│             this.cache.N["class"] = N;
//│           }
//│           return this.cache.N;
//│         }
//│       }
//│       this.cache.J = new J();
//│       this.cache.J["class"] = J;
//│     }
//│     return this.cache.J;
//│   }
//│ };
//│ globalThis.J = typing_unit15.J;
//│ // End of generated code

:e
:js
let m = J.M()
let n = J.N(2)
//│ ╔══[ERROR] access to class member not yet supported
//│ ║  l.837: 	let m = J.M()
//│ ╙──       	         ^^
//│ ╔══[ERROR] access to class member not yet supported
//│ ║  l.838: 	let n = J.N(2)
//│ ╙──       	         ^^
//│ let m: error
//│ let n: error
//│ // Prelude
//│ let typing_unit16 = { cache: {} };
//│ // Query 1
//│ globalThis.m = J.M();
//│ // Query 2
//│ globalThis.n = J.N(2);
//│ // End of generated code
//│ m
//│   = M {}
//│ n
//│   = N {}


module K {
  let x = 1
  module L {
    let x = 42
    class M() {
      fun f = x
    }
  }
}
//│ module K() {
//│   module L() {
//│     class M() {
//│       fun f: 42
//│     }
//│     let x: 42
//│   }
//│   let x: 1
//│ }

:e
let m = K.L.M()
m.f
//│ ╔══[ERROR] access to module member not yet supported
//│ ║  l.880: 	let m = K.L.M()
//│ ╙──       	         ^^
//│ let m: error
//│ error
//│ m
//│   = M {}
//│ res
//│     = 42

:e
module L {
  class M(x: int) {}
  module N {
    module O {
      class P(y: int) extends M(y + 1) {}
    }
  }
}
//│ ╔══[ERROR] Class inheritance is not supported yet (use mixins)
//│ ║  l.897: 	      class P(y: int) extends M(y + 1) {}
//│ ╙──       	                              ^^^^^^^^
//│ module L() {
//│   class M(x: int)
//│   module N() {
//│     module O() {
//│       class P(y: int)
//│     }
//│   }
//│ }

:e
let op = L.N.O.P(0)
op.x
//│ ╔══[ERROR] access to module member not yet supported
//│ ║  l.914: 	let op = L.N.O.P(0)
//│ ╙──       	          ^^
//│ let op: error
//│ error
//│ op
//│    = P {}
//│ res
//│     = 1
