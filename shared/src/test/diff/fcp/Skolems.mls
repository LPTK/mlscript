:GeneralizeCurriedFunctions
:NoRecursiveTypes
// :ArgGen


def auto_ : (forall 'a. 'a -> 'a) -> 'b -> 'b
def auto_ x = x x
//│ auto_: (forall 'a. 'a -> 'a) -> 'b -> 'b
//│      = <missing implementation>
//│ ('a -> 'b & 'a) -> 'b
//│   <:  auto_:
//│ (forall 'a. 'a -> 'a) -> 'b -> 'b
//│      = [Function: auto_]

fun (x: (forall 'a. 'a -> 'a)) -> auto_ x
//│ res: (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)
//│    = [Function: res]

// * Compares an extruded higher-level skolem; rightly rejected
:e
fun (x: ('a -> 'a)) -> auto_ x
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.21: 	fun (x: ('a -> 'a)) -> auto_ x
//│ ║        	                       ^^^^^^^
//│ ╟── type `‘a_67_68` is not an instance of type `'a_67_69`
//│ ║  l.6: 	def auto_ : (forall 'a. 'a -> 'a) -> 'b -> 'b
//│ ║       	                    ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.6: 	def auto_ : (forall 'a. 'a -> 'a) -> 'b -> 'b
//│ ╙──     	                    ^^
//│ res: (('a | ‘a_67_68) -> (‘a_67_69 & 'a)) -> error
//│    = [Function: res]

foo(x: ('a -> 'b)) = auto_ x
//│ foo: (('a | ‘a_79_80) -> (‘a_79_81 & 'b)) -> (forall 'b0, 'c. 'b0 -> 'b0 | 'c)
//│    = [Function: foo]

:e
foo (fun x -> x)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.39: 	foo (fun x -> x)
//│ ║        	^^^^^^^^^^^^^^^^
//│ ╟── type `‘a_79_80` is not an instance of type `'a_79_81`
//│ ║  l.6: 	def auto_ : (forall 'a. 'a -> 'a) -> 'b -> 'b
//│ ║       	                    ^^
//│ ╟── but it flows into reference with expected type `‘a_79_81`
//│ ║  l.39: 	foo (fun x -> x)
//│ ║        	              ^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.6: 	def auto_ : (forall 'a. 'a -> 'a) -> 'b -> 'b
//│ ║       	                    ^^
//│ ╟── from type variable:
//│ ║  l.34: 	foo(x: ('a -> 'b)) = auto_ x
//│ ╙──      	              ^^
//│ res: error
//│    = [Function (anonymous)]

:e
foo (fun x -> 0)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.59: 	foo (fun x -> 0)
//│ ║        	^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `'a_79_81`
//│ ║  l.59: 	foo (fun x -> 0)
//│ ║        	              ^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.6: 	def auto_ : (forall 'a. 'a -> 'a) -> 'b -> 'b
//│ ║       	                    ^^
//│ ╟── from type variable:
//│ ║  l.34: 	foo(x: ('a -> 'b)) = auto_ x
//│ ╙──      	              ^^
//│ res: error
//│    = 0

:e
foo (fun x -> foo (fun y -> y) x)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.76: 	foo (fun x -> foo (fun y -> y) x)
//│ ║        	              ^^^^^^^^^^^^^^^^
//│ ╟── type `‘a_79_80` is not an instance of type `'a_79_81`
//│ ║  l.6: 	def auto_ : (forall 'a. 'a -> 'a) -> 'b -> 'b
//│ ║       	                    ^^
//│ ╟── but it flows into reference with expected type `‘a_79_81`
//│ ║  l.76: 	foo (fun x -> foo (fun y -> y) x)
//│ ║        	                            ^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.6: 	def auto_ : (forall 'a. 'a -> 'a) -> 'b -> 'b
//│ ║       	                    ^^
//│ ╟── from type variable:
//│ ║  l.34: 	foo(x: ('a -> 'b)) = auto_ x
//│ ╙──      	              ^^
//│ res: 'b -> 'b | 'a
//│    = [Function (anonymous)]

// * This would be unsound; `fun y -> x` does not have type `forall 'a. 'a -> 'a` but it is eventually passed to auto_
:e
foo (fun x -> foo (fun y -> x) x)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.97: 	foo (fun x -> foo (fun y -> x) x)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a_79_80` is not an instance of type `'a_79_81`
//│ ║  l.6: 	def auto_ : (forall 'a. 'a -> 'a) -> 'b -> 'b
//│ ║       	                    ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.6: 	def auto_ : (forall 'a. 'a -> 'a) -> 'b -> 'b
//│ ║       	                    ^^
//│ ╟── from reference:
//│ ║  l.97: 	foo (fun x -> foo (fun y -> x) x)
//│ ╙──      	                            ^
//│ res: error
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded


// * Producing an actual crash from this:

def oops (i: forall 'a. 'a -> 'a) =
  let _ = (i id) "hello"
  in i
//│ oops: (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)
//│     = [Function: oops]

// If we were not careful this would lead to unsound skolem extrusion:
def extrude (f: 'a -> 'b) = oops f
//│ extrude: (('a | ‘a_174_175) -> (‘a_174_176 & 'b)) -> (forall 'a0. 'a0 -> 'a0 | 'c)
//│        = [Function: extrude]

:e
f = extrude (fun x -> extrude (fun y -> x) x)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.129: 	f = extrude (fun x -> extrude (fun y -> x) x)
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a_174_175` is not an instance of type `'a_174_176`
//│ ║  l.117: 	def oops (i: forall 'a. 'a -> 'a) =
//│ ║         	                    ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.117: 	def oops (i: forall 'a. 'a -> 'a) =
//│ ║         	                    ^^
//│ ╟── from reference:
//│ ║  l.129: 	f = extrude (fun x -> extrude (fun y -> x) x)
//│ ╙──       	                                        ^
//│ f: error
//│  = [Function (anonymous)]

:re
f 42 // Boom!
//│ res: error
//│ Runtime error:
//│   TypeError: i(...) is not a function



def swapWith: (forall 'x 'y. (('x, 'y),) -> ('y, 'x)) -> ('a, 'b) -> ('b, 'a)
//│ swapWith: (forall 'x, 'y. ('x, 'y,) -> ('y, 'x,)) -> ('a, 'b,) -> ('b, 'a,)
//│         = <missing implementation>

def swapWith f (a, b) = f ((a, b))
//│ 'a -> (forall 'a, 'b, 'c, 'd. (('b, 'c,) -> 'd
//│   where
//│     'a <: ('b, 'c,) -> 'd))
//│   <:  swapWith:
//│ (forall 'x, 'y. ('x, 'y,) -> ('y, 'x,)) -> ('a, 'b,) -> ('b, 'a,)
//│         = [Function: swapWith]


// * This is an error because it would force the swapped tuple to be the same 'a as the original
:e
fun (x: ('a -> 'a)) -> swapWith x
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.168: 	fun (x: ('a -> 'a)) -> swapWith x
//│ ║         	                       ^^^^^^^^^^
//│ ╟── type `‘x_287_289` is not an instance of type `'y_288_291`
//│ ║  l.153: 	def swapWith: (forall 'x 'y. (('x, 'y),) -> ('y, 'x)) -> ('a, 'b) -> ('b, 'a)
//│ ║         	                      ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.153: 	def swapWith: (forall 'x 'y. (('x, 'y),) -> ('y, 'x)) -> ('a, 'b) -> ('b, 'a)
//│ ╙──       	                         ^^
//│ res: (('a | (‘x_287_289, ‘y_288_290,)) -> ((‘y_288_291, ‘x_287_292,) & 'a)) -> error
//│    = [Function: res]

foo = fun (x: ('a -> 'b)) -> swapWith x
//│ foo: (('a | (‘x_302_304, ‘y_303_305,)) -> ((‘y_303_306, ‘x_302_307,) & 'b)) -> (forall 'a0, 'b0, 'c. ('a0, 'b0,) -> ('b0, 'a0,) | 'c)
//│    = [Function: foo1]

bar = fun f -> foo f (1, 2)
//│ bar: (('a | (‘x_302_304, ‘y_303_305,)) -> ((‘y_303_306, ‘x_302_307,) & 'b) & 'c) -> (('b0 | 2, 'a0 | 1,) | 'd)
//│    = [Function: bar]

:e
bar (fun ((u, v),) -> (v, u))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.190: 	bar (fun ((u, v),) -> (v, u))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘y_303_305` is not an instance of type `'y_303_306`
//│ ║  l.153: 	def swapWith: (forall 'x 'y. (('x, 'y),) -> ('y, 'x)) -> ('a, 'b) -> ('b, 'a)
//│ ║         	                         ^^
//│ ╟── but it flows into reference with expected type `‘y_303_306`
//│ ║  l.190: 	bar (fun ((u, v),) -> (v, u))
//│ ║         	                       ^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.153: 	def swapWith: (forall 'x 'y. (('x, 'y),) -> ('y, 'x)) -> ('a, 'b) -> ('b, 'a)
//│ ╙──       	                         ^^
//│ res: error
//│    = [ 2, 1 ]

:e
bar (fun ((u1, v1),) -> let tmp = bar (fun ((u2, v2),) -> (v2, u2)) in (v1, u1))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.207: 	bar (fun ((u1, v1),) -> let tmp = bar (fun ((u2, v2),) -> (v2, u2)) in (v1, u1))
//│ ║         	                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘y_303_305` is not an instance of type `'y_303_306`
//│ ║  l.153: 	def swapWith: (forall 'x 'y. (('x, 'y),) -> ('y, 'x)) -> ('a, 'b) -> ('b, 'a)
//│ ║         	                         ^^
//│ ╟── but it flows into reference with expected type `‘y_303_306`
//│ ║  l.207: 	bar (fun ((u1, v1),) -> let tmp = bar (fun ((u2, v2),) -> (v2, u2)) in (v1, u1))
//│ ║         	                                                           ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.153: 	def swapWith: (forall 'x 'y. (('x, 'y),) -> ('y, 'x)) -> ('a, 'b) -> ('b, 'a)
//│ ╙──       	                         ^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.207: 	bar (fun ((u1, v1),) -> let tmp = bar (fun ((u2, v2),) -> (v2, u2)) in (v1, u1))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘y_303_305` is not an instance of type `'y_303_306`
//│ ║  l.153: 	def swapWith: (forall 'x 'y. (('x, 'y),) -> ('y, 'x)) -> ('a, 'b) -> ('b, 'a)
//│ ║         	                         ^^
//│ ╟── but it flows into reference with expected type `‘y_303_306`
//│ ║  l.207: 	bar (fun ((u1, v1),) -> let tmp = bar (fun ((u2, v2),) -> (v2, u2)) in (v1, u1))
//│ ║         	                                                                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.153: 	def swapWith: (forall 'x 'y. (('x, 'y),) -> ('y, 'x)) -> ('a, 'b) -> ('b, 'a)
//│ ╙──       	                         ^^
//│ res: error
//│    = [ 2, 1 ]

:e // * Not sure why this one is rejected (but the `extrude` version above is accepted.)
bar (fun ((u1, v1),) -> let tmp = bar (fun ((u2, v2),) -> (v1, u1)) in (v1, u1))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.236: 	bar (fun ((u1, v1),) -> let tmp = bar (fun ((u2, v2),) -> (v1, u1)) in (v1, u1))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘x_302_304` is not an instance of type `'x_302_307_415`
//│ ║  l.153: 	def swapWith: (forall 'x 'y. (('x, 'y),) -> ('y, 'x)) -> ('a, 'b) -> ('b, 'a)
//│ ║         	                      ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.153: 	def swapWith: (forall 'x 'y. (('x, 'y),) -> ('y, 'x)) -> ('a, 'b) -> ('b, 'a)
//│ ╙──       	                      ^^
//│ res: error
//│    = [ 2, 1 ]


:e
fun (x: ((('a, 'b),) -> ('b, 'a))) -> swapWith x
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.251: 	fun (x: ((('a, 'b),) -> ('b, 'a))) -> swapWith x
//│ ║         	                                      ^^^^^^^^^^
//│ ╟── type `‘x_432_434` is not an instance of type `'x_432_435`
//│ ║  l.153: 	def swapWith: (forall 'x 'y. (('x, 'y),) -> ('y, 'x)) -> ('a, 'b) -> ('b, 'a)
//│ ║         	                      ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.153: 	def swapWith: (forall 'x 'y. (('x, 'y),) -> ('y, 'x)) -> ('a, 'b) -> ('b, 'a)
//│ ╙──       	                      ^^
//│ res: (('a | ‘x_432_434, 'b,) -> ('b, ‘x_432_435 & 'a,)) -> error
//│    = [Function: res]

fun (x: ((('a, 'b),) -> ('c, 'd))) -> swapWith x
//│ res: ((‘x_451_455, ‘y_452_456,) -> (‘y_452_453, ‘x_451_454,)) -> (forall 'a, 'b. ('a, 'b,) -> ('b, 'a,))
//│    = [Function: res]


