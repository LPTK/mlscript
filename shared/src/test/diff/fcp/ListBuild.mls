:NoRecursiveTypes
:GeneralizeCurriedFunctions


class Ls[A]
  method HeadTail: (A, Ls[A]) | undefined
//│ Defined class Ls[+A]
//│ Declared Ls.HeadTail: Ls['A] -> (('A, Ls['A],) | undefined)

// * Note that a more structural type such as this will raise cycle errors due to `:NoRecursiveTypes`
// class Ls[A]: { head: A | undefined; tail: Ls[A] | undefined }

class Nil: Ls[nothing]
  method HeadTail = undefined
//│ Defined class Nil
//│ Defined Nil.HeadTail: Nil -> undefined

class Cons[A]: Ls[A] & { head: A; tail: Ls[A] }
  method HeadTail = (this.head, this.tail)
//│ Defined class Cons[+A]
//│ Defined Cons.HeadTail: Cons['A] -> ('A, Ls['A],)

def nil: Ls['a]
def cons: ('a, Ls['a]) -> Ls['a]
def single: 'a -> Ls['a]
//│ nil: Ls[nothing]
//│    = <missing implementation>
//│ cons: ('a, Ls['a],) -> Ls['a]
//│     = <missing implementation>
//│ single: 'a -> Ls['a]
//│       = <missing implementation>

nil = Nil {}
cons (head, tail) = Cons { head; tail }
//│ Nil
//│   <:  nil:
//│ Ls[nothing]
//│    = Nil {}
//│ ('a & 'head & 'A, Ls['A] & 'b & 'tail,) -> ((Cons['A] with {head: 'head, tail: 'tail}) | 'c)
//│   <:  cons:
//│ ('a, Ls['a],) -> Ls['a]
//│     = [Function: cons]



// * Random minimized trials:


def build0 (g: forall 'b. ('a -> 'b) -> 'b) = g single
//│ build0: (forall 'b. (('a & 'a0) -> 'b) -> 'b) -> (Ls['a0] | 'c)
//│       = <no result>
//│         single is not implemented

build0 (fun s -> s 1)
//│ res: Ls[1] | 'a
//│    = <no result>
//│      build0 and single are not implemented

res: Ls[int]
//│ res: Ls[int]
//│    = undefined


def build0 (g: forall 'b. ('a -> 'b) -> 'b) = g (fun x -> single ((x, x)))
//│ build0: (forall 'b. (('a & 'c) -> 'b) -> 'b) -> (forall 'a0, 'd. Ls['a0 | ('c, 'c,)] | 'd | 'e)
//│       = <no result>
//│         single is not implemented

def build0 (g: forall 'b. ('a -> 'a -> 'b) -> 'b) = g (fun x -> fun y -> single ((x,y)))
//│ build0: (forall 'b. (('a & 'c & 'd) -> ('a & 'c & 'd) -> 'b) -> 'b) -> (forall 'a0, 'e. Ls['a0 | ('d, 'c,)] | 'e | 'f)
//│       = <no result>
//│         single is not implemented

def build0 (g: forall 'b. ('a -> 'b -> 'b) -> 'b) = g (fun x -> fun y -> single ((x,y)))
//│ build0: (forall 'b. (('a & 'c) -> 'b -> 'b) -> 'b) -> ('d | 'e)
//│   where
//│     'd :> forall 'f, 'a0. 'f
//│     'f :> Ls['a0]
//│     'a0 :> ('c, 'd,)
//│       = <no result>
//│         single is not implemented

def build0 (g: forall 'b. (('a, 'b) -> 'b) -> 'b) = g cons
//│ build0: (forall 'b. (('a & 'a0, 'b,) -> 'b) -> 'b) -> (Ls['a0] | 'c)
//│       = [Function: build01]

def build0 (g: forall 'b. (('a, 'b) -> 'b) -> 'b) = g (fun (x, xs) -> cons (x, xs))
//│ build0: (forall 'b. (('a & 'c & 'a0, 'b,) -> 'b) -> 'b) -> (forall 'd. Ls['a0] | 'd | 'e)
//│       = [Function: build02]

def g: forall 'b. (('a, 'b) -> 'b) -> 'b
//│ g: ((nothing, 'b,) -> 'b) -> 'b
//│  = <missing implementation>

g (fun (x, xs) -> cons (x, xs))
//│ res: Ls['a] | 'a
//│    = <no result>
//│      g is not implemented

def g: ((int, 'b) -> 'b) -> 'b
//│ g: ((int, 'b,) -> 'b) -> 'b
//│  = <missing implementation>

g (fun (x, xs) -> cons (x, xs))
//│ res: Ls[int] | 'a
//│    = <no result>
//│      g is not implemented

def cons2: ('a, {x:'a}) -> {x:'a}
// def cons2: ('a, 'a) -> 'a
//│ cons2: ('a, {x: 'a},) -> {x: 'a}
//│      = <missing implementation>

f (x, xs) = cons2 (x, xs)
//│ f: ('b & 'a, {x: 'a} & 'c,) -> ({x: 'a} | 'd)
//│  = <no result>
//│    cons2 is not implemented

g f
//│ res: {x: int} | 'a
//│    = <no result>
//│      g is not implemented


def build0 (g: forall 'b. ('a -> 'b -> 'b) -> 'b) = g (fun x -> fun xs -> cons (x, xs))
//│ build0: (forall 'b. (('a & 'c) -> 'b -> 'b) -> 'b) -> (forall 'd. Ls['a0 | 'c] | 'd | 'e)
//│       = [Function: build03]

:re
build0 (fun k -> k 1 error)
//│ res: Ls['a | 1] | 'b | 'c
//│ Runtime error:
//│   Error: unexpected runtime error



// * The Real Deal:


def build = fun (g: forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> g (fun x -> fun xs -> cons (x, xs)) nil
//│ build: (forall 'b. (('a & 'c) -> 'b -> 'b) -> 'b -> 'b) -> (forall 'd. Ls['a0 | 'c] | 'd | 'e)
//│      = [Function: build]

xs0 = build (fun c -> fun n -> n)
//│ xs0: Ls['a] | 'b | 'c
//│    = Nil {}

xs1 = build (fun c -> fun n -> c 1 n)
//│ xs1: Ls['a | 1] | 'b | 'c
//│    = Cons { head: 1, tail: Nil {} }

xs3 = build (fun c -> fun n -> c 1 (c 2 (c 3 n)))
//│ xs3: Ls['a | 1 | 2 | 3] | 'b | 'c
//│    = Cons {
//│        head: 1,
//│        tail: Cons { head: 2, tail: Cons { head: 3, tail: Nil {} } }
//│      }



build: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│ res: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│    = [Function: build]

def build_ty: forall 'a. (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│ build_ty: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│         = <missing implementation>

build_ty = build_ty
//│ (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│   <:  build_ty:
//│ (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│         = <no result>
//│           build_ty is not implemented

build: forall 'a. (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│ res: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│    = [Function: build]


// * This `build` type is _too_ general as it lets the continuation assume it will handle lists instead of some unknown 'b
:e
build: (('a -> Ls['a] -> Ls['a]) -> Ls['a] -> Ls['a]) -> Ls['a]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.183: 	build: (('a -> Ls['a] -> Ls['a]) -> Ls['a] -> Ls['a]) -> Ls['a]
//│ ║         	^^^^^
//│ ╟── type `Ls[?a]` is not an instance of type `'b_835`
//│ ║  l.183: 	build: (('a -> Ls['a] -> Ls['a]) -> Ls['a] -> Ls['a]) -> Ls['a]
//│ ║         	               ^^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.140: 	def build = fun (g: forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> g (fun x -> fun xs -> cons (x, xs)) nil
//│ ╙──       	                           ^^
//│ res: (('a -> Ls['a] -> Ls['a | error]) -> Ls['a | error] -> Ls['a]) -> Ls['a | error]
//│    = [Function: build]



// * It also Just Works without type annotations!


def build_ = fun g -> g (fun x -> fun xs -> cons (x, xs)) nil
//│ build_: ((forall 'b. 'b -> (forall 'a, 'c, 'd. (Ls['a] & 'c) -> (Ls['a | 'b] | 'd))) -> (Ls['d] -> 'e & 'f) & 'g) -> 'e
//│       = [Function: build_]

build_ (fun c -> fun n -> n)
//│ res: Ls[nothing]
//│    = Nil {}

build_ (fun c -> fun n -> c 1 n)
//│ res: Ls[1] | 'a
//│    = Cons { head: 1, tail: Nil {} }

build_ (fun c -> fun n -> c 1 (c 2 (c 3 n)))
//│ res: Ls[1 | 2 | 3] | 'a
//│    = Cons {
//│        head: 1,
//│        tail: Cons { head: 2, tail: Cons { head: 3, tail: Nil {} } }
//│      }



def g: forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b
//│ g: (nothing -> 'b -> 'b) -> 'b -> 'b
//│  = <missing implementation>

g : ('a -> Ls['a] -> Ls['a]) -> Ls['a] -> Ls['a]
//│ res: ('a -> Ls['a] -> Ls['a]) -> Ls['a] -> Ls['a]
//│    = <no result>
//│      g is not implemented


build_ : (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│ res: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│    = [Function: build_]


def b: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│ b: (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│  = <missing implementation>

b = build_
//│ ((forall 'b. 'b -> (forall 'a, 'c, 'd. (Ls['a] & 'c) -> (Ls['a | 'b] | 'd))) -> (Ls['d] -> 'e & 'f) & 'g) -> 'e
//│   <:  b:
//│ (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│  = [Function: build_]

b g = build_ g
//│ ((forall 'b. 'b -> (forall 'a, 'c, 'd. (Ls['a] & 'c) -> (Ls['a | 'b] | 'd))) -> (Ls['d] -> ('e & 'f) & 'g) & 'h & 'i) -> 'f
//│   <:  b:
//│ (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│  = [Function: b1]

b g = build_ (fun x -> g x)
//│ ((forall 'b. 'b -> (forall 'a, 'c, 'd. (Ls['a] & 'c) -> (Ls['a | 'b] | 'd)) | 'e) -> (Ls['d] -> ('f & 'g) & 'h & 'i) & 'j) -> 'g
//│   <:  b:
//│ (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│  = [Function: b2]

:e
b g x = build_ g x
//│ 'b -> (forall 'c, 'b, 'd, 'e, 'f, 'g. ('e -> 'f
//│   where
//│     'b <: (forall 'h. 'h -> (forall 'a, 'i, 'j. (Ls['a] & 'i) -> (Ls['a | 'h] | 'j))) -> (Ls['j] -> ('e -> 'f & 'g & 'c) & 'd)))
//│   <:  b:
//│ (forall 'b. ('a -> 'b -> 'b) -> 'b -> 'b) -> Ls['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.260: 	b g x = build_ g x
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── type `Ls[?a]` is not a function
//│ ║  l.23: 	def nil: Ls['a]
//│ ║        	         ^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.260: 	b g x = build_ g x
//│ ║         	        ^^^^^^^^^^
//│ ╟── from application:
//│ ║  l.201: 	def build_ = fun g -> g (fun x -> fun xs -> cons (x, xs)) nil
//│ ╙──       	                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│  = [Function: b3]



rec def fold f z xs =
  let ht = xs.HeadTail in case ht of {
  | undefined -> z
  | _ -> (fun ((h, t)) -> f h (fold f z t)) ht
  }
//│ fold: ('a -> 'b -> 'b) -> 'b -> Ls['a] -> 'b
//│     = [Function: fold]

fold add 0 xs0
//│ res: int
//│    = 0

fold add 0 xs1
//│ res: int
//│    = 1

fold add 0 xs3
//│ res: int
//│    = 6



