:NoRecursiveTypes
:GeneralizeCurriedFunctions
:DontDistributeForalls


rec def foo x y =
  let tmp = foo x y in (x, y,)
//│ foo: 'a -> 'b -> ('a, 'b,)
//│    = [Function: foo]

foo
//│ res: 'a -> 'b -> ('a, 'b,)
//│    = [Function: foo]

def foo_ty: 'a -> (forall 'b. 'b -> ('a, 'b,))
//│ foo_ty: 'a -> (forall 'b. 'b -> ('a, 'b,))
//│       = <missing implementation>


:e // Needs distributivity (see at the end)
foo_ty = foo
//│ 'a -> 'b -> ('a, 'b,)
//│   <:  foo_ty:
//│ 'a -> (forall 'b. 'b -> ('a, 'b,))
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.21: 	foo_ty = foo
//│ ║        	^^^^^^^^^^^^
//│ ╟── type `‘b_71_72` is not an instance of type `'b_71_73`
//│ ║  l.15: 	def foo_ty: 'a -> (forall 'b. 'b -> ('a, 'b,))
//│ ║        	                          ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.15: 	def foo_ty: 'a -> (forall 'b. 'b -> ('a, 'b,))
//│ ╙──      	                          ^^
//│       = [Function: foo]

foo_ty x y = (x, y,)
//│ 'a -> (forall 'b. 'b -> ('a, 'b,))
//│   <:  foo_ty:
//│ 'a -> (forall 'b. 'b -> ('a, 'b,))
//│       = [Function: foo_ty1]


rec def foo2 x y z =
  let tmp = foo2 x y z in (x, y, z)
//│ foo2: 'a -> 'b -> 'c -> ('a, 'b, 'c,)
//│     = [Function: foo2]

def foo2_ty: 'a -> (forall 'b. 'b -> (forall 'c. 'c -> ('a, 'b, 'c,)))
//│ foo2_ty: 'a -> (forall 'b. 'b -> (forall 'c. 'c -> ('a, 'b, 'c,)))
//│        = <missing implementation>

:e
foo2_ty = foo2
//│ 'a -> 'b -> 'c -> ('a, 'b, 'c,)
//│   <:  foo2_ty:
//│ 'a -> (forall 'b. 'b -> (forall 'c. 'c -> ('a, 'b, 'c,)))
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.53: 	foo2_ty = foo2
//│ ║        	^^^^^^^^^^^^^^
//│ ╟── type `‘c_163_164` is not an instance of type `'c_163_165`
//│ ║  l.48: 	def foo2_ty: 'a -> (forall 'b. 'b -> (forall 'c. 'c -> ('a, 'b, 'c,)))
//│ ║        	                                             ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.48: 	def foo2_ty: 'a -> (forall 'b. 'b -> (forall 'c. 'c -> ('a, 'b, 'c,)))
//│ ╙──      	                                             ^^
//│        = [Function: foo2]

foo2_ty x y z = (x, y, z,)
//│ 'a -> (forall 'b. 'b -> (forall 'c. 'c -> ('a, 'b, 'c,)))
//│   <:  foo2_ty:
//│ 'a -> (forall 'b. 'b -> (forall 'c. 'c -> ('a, 'b, 'c,)))
//│        = [Function: foo2_ty1]



rec def r x = let tmp = x in x
//│ r: 'a -> 'a
//│  = [Function: r]

rec def x = x
//│ x: nothing
//│  = [Function: x]

rec def lr1 = { tail = lr1 }
//│ lr1: 'lr1
//│   where
//│     'lr1 :> {tail: 'lr1}
//│    = [Function: lr1]

rec def lr1 = { head = 0; tail = lr1 }
//│ lr1: 'lr1
//│   where
//│     'lr1 :> {head: 0, tail: 'lr1}
//│    = [Function: lr11]



// * With distributivity:
:DistributeForalls


foo_ty = foo
//│ 'a -> 'b -> ('a, 'b,)
//│   <:  foo_ty:
//│ 'a -> (forall 'b. 'b -> ('a, 'b,))
//│       = [Function: foo]


// TODO?
:e
foo2_ty = foo2
//│ 'a -> 'b -> 'c -> ('a, 'b, 'c,)
//│   <:  foo2_ty:
//│ 'a -> (forall 'b. 'b -> (forall 'c. 'c -> ('a, 'b, 'c,)))
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.111: 	foo2_ty = foo2
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `‘c_269_270` is not an instance of type `'c_269_271`
//│ ║  l.48: 	def foo2_ty: 'a -> (forall 'b. 'b -> (forall 'c. 'c -> ('a, 'b, 'c,)))
//│ ║        	                                             ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.48: 	def foo2_ty: 'a -> (forall 'b. 'b -> (forall 'c. 'c -> ('a, 'b, 'c,)))
//│ ╙──      	                                             ^^
//│        = [Function: foo2]


