// * Variations/minimizations on the case found in the Fiota test
// * These tests exercise problems that could arise from distributing
// * RHS functions with polymorphic codomain.



S x = x x
//│ S: ('a -> 'b & 'a) -> 'b
//│  = [Function: S]

S: (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)
//│ res: (forall 'a. 'a -> 'a) -> (forall 'a0. 'a0 -> 'a0)
//│    = [Function: S]


S x y = x
//│ S: 'a -> anything -> 'a
//│  = [Function: S1]

S: (forall 'a. 'a -> 'a) -> anything -> (forall 'c. 'c -> 'c)
//│ res: (forall 'a. 'a -> 'a) -> anything -> (forall 'c. 'c -> 'c)
//│    = [Function: S1]

S: 'c -> 'b -> (forall 'a. 'a -> 'a)
//│ res: (??a -> ??a0) -> anything -> (forall 'a. 'a -> 'a)
//│    = [Function: S1]

S: (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)
//│ res: (forall 'a. 'a -> 'a) -> (forall 'a0. 'a0 -> 'a0) -> (forall 'a1. 'a1 -> 'a1)
//│    = [Function: S1]


S x y = x y
//│ S: ('a -> 'b) -> 'a -> 'b
//│  = [Function: S2]

S: (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)
//│ res: (forall 'a. 'a -> 'a) -> (forall 'a0. 'a0 -> 'a0) -> (forall 'a1. 'a1 -> 'a1)
//│    = [Function: S2]


S x y z = x z y
//│ S: ('a -> 'b -> 'c) -> 'b -> 'a -> 'c
//│  = [Function: S3]

S: (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)
//│ res: (forall 'a. 'a -> 'a) -> (forall 'a0. 'a0 -> 'a0) -> (forall 'a1. 'a1 -> 'a1) -> (forall 'a2. 'a2 -> 'a2)
//│    = [Function: S3]



:NoJS



def T: 'a -> 'a -> anything -> 'a
//│ T: 'a -> 'a -> anything -> 'a

T: (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)
//│ res: (forall 'a. 'a -> 'a) -> (forall 'a0. 'a0 -> 'a0) -> (forall 'a1. 'a1 -> 'a1) -> (forall 'a2. 'a2 -> 'a2)


// * This one works out because we currently DO NOT distribute out when both sides of
// * the constraint are plain function types:

def T: ('a, 'a -> 'a)
//│ T: ('a, 'a -> 'a,)

T: (forall 'a. 'a -> 'a, (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a))
//│ res: (forall 'a. 'a -> 'a, (forall 'a0. 'a0 -> 'a0) -> (forall 'a1. 'a1 -> 'a1),)


// * However, we can contort things enough so that we end up forcing the distribution,
// * and causing a problematic extrusion/avoidance:

def T: ('a, forall 'b. ('a, 'b) -> 'a)
//│ T: ('a, ('a, anything,) -> 'a,)

:e
T: (anything, (forall 'a. 'a -> 'a, anything) -> (forall 'a. 'a -> 'a))
//│ res: (anything, (forall 'a. 'a -> 'a, anything,) -> (forall 'a0. 'a0 -> 'a0),)


// * Similarly:

def T: 'a -> (forall 'b. ('a, 'b) -> 'a)
//│ T: 'a -> ('a, anything,) -> 'a

:e
T: anything -> (forall 'a. 'a -> 'a, anything) -> (forall 'a. 'a -> 'a)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.90: 	T: anything -> (forall 'a. 'a -> 'a, anything) -> (forall 'a. 'a -> 'a)
//│ ║        	^
//│ ╟── type `anything` is not a function
//│ ║  l.90: 	T: anything -> (forall 'a. 'a -> 'a, anything) -> (forall 'a. 'a -> 'a)
//│ ║        	   ^^^^^^^^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.90: 	T: anything -> (forall 'a. 'a -> 'a, anything) -> (forall 'a. 'a -> 'a)
//│ ╙──      	                                                              ^^^^^^^^
//│ res: anything -> (forall 'a. 'a -> 'a, anything,) -> (forall 'a0. 'a0 -> 'a0)


