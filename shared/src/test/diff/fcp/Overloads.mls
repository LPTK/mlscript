
:NoJS


type IISS = int -> int & string -> string
type BBNN = bool -> bool & number -> number
type ZZII = 0 -> 0 & int -> int
//│ Defined type alias IISS
//│ Defined type alias BBNN
//│ Defined type alias ZZII

def IISS: int -> int & string -> string
def BBNN: bool -> bool & number -> number
def ZZII: 0 -> 0 & int -> int
//│ IISS: int -> int & string -> string
//│ BBNN: bool -> bool & number -> number
//│ ZZII: 0 -> 0 & int -> int


IISS : IISS
//│ res: IISS

IISS : int -> int & string -> string
//│ res: int -> int & string -> string

IISS : IISS | BBNN
//│ res: BBNN | IISS

:e
IISS : ZZII
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.30: 	IISS : ZZII
//│ ║        	^^^^
//│ ╟── type `int` does not match type `0`
//│ ║  l.12: 	def IISS: int -> int & string -> string
//│ ║        	                 ^^^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.7: 	type ZZII = 0 -> 0 & int -> int
//│ ╙──     	                 ^
//│ res: ZZII

:e
IISS : BBNN
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.43: 	IISS : BBNN
//│ ║        	^^^^
//│ ╟── type `bool` does not match type `int | string`
//│ ║  l.6: 	type BBNN = bool -> bool & number -> number
//│ ╙──     	            ^^^^
//│ res: BBNN


// * These tests show that we currently throw away information when constraining LHS overloading sets:

IISS : int -> int
//│ res: int -> int

IISS : (0 | 1) -> number
//│ res: (0 | 1) -> number

IISS : 'a -> 'a
//│ res: ('a & (int | string)) -> (int | string | 'a)

IISS 0
//│ res: int | string

(IISS : int -> int) 0
//│ res: int

(if true then IISS else BBNN) 0
//│ res: bool | number | string

fun x -> (if true then IISS else BBNN) x
//│ res: int -> (bool | number | string)

if true then IISS else BBNN
//│ res: bool -> bool & number -> number | int -> int & string -> string

(if true then IISS else ZZII) : int -> int
//│ res: int -> int

(if true then IISS else BBNN) : (0 | 1) -> number
//│ res: (0 | 1) -> number

:e
(if true then IISS else BBNN) : (0 | 1 | true) -> number
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.86: 	(if true then IISS else BBNN) : (0 | 1 | true) -> number
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `true` does not match type `int | string`
//│ ║  l.86: 	(if true then IISS else BBNN) : (0 | 1 | true) -> number
//│ ╙──      	                                         ^^^^
//│ res: (0 | 1 | true) -> number


// * Note that type normalization used to be very aggressive at approximating non-tag type negations,
// * to simplify the result, but this was changed as it was unsound

def test: ~(int -> int)
//│ test: ~(int -> int)

// * See also test file BooleanFail.mls about this previous unsoundness
:e
test = 42
not test
//│ 42
//│   <:  test:
//│ ~(int -> int)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.105: 	not test
//│ ║         	^^^^^^^^
//│ ╟── type `~(int -> int)` is not an instance of type `bool`
//│ ║  l.99: 	def test: ~(int -> int)
//│ ║        	          ^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `bool`
//│ ║  l.105: 	not test
//│ ╙──       	    ^^^^
//│ res: bool | error

def test: ~(int -> int) & ~bool
//│ test: ~bool & ~(int -> int)

:ds
def test: ~(int -> int) & bool
//│ ⬤ Typed as: (~((Int -> Int)) & Bool)
//│  where: 
//│ ⬤ Initial: (~((Int -> Int)) & Bool)
//│  where: 
//│ allVarPols: 
//│ ⬤ Cleaned up: (~((Int -> Int)) & Bool)
//│  where: 
//│ ⬤ Unskid: (~((Int -> Int)) & Bool)
//│  where: 
//│ analyze1[=] (~((Int -> Int)) & Bool)
//│ | analyze1[=] ~((Int -> Int))
//│ | | analyze1[=;-] (Int -> Int)
//│ | | | analyze1[=;-;-] (Int,)
//│ | | | | analyze1[=;-;-] Int
//│ | | | analyze1[=;-] Int
//│ | analyze1[=] Bool
//│ [inv] 
//│ [nums] 
//│ analyze2[=] (~((Int -> Int)) & Bool)
//│ | Components Set((None,~((Int -> Int))), (None,Bool))
//│ | >> Processing (~((Int -> Int)) & Bool) at [-]
//│ | go (~((Int -> Int)) & Bool)   ()
//│ | | go ~((Int -> Int))   ()
//│ | | go Bool   (~((Int -> Int)))
//│ | >> Occurrences LinkedHashSet(~((Int -> Int)), Bool)
//│ | analyze2[=] ~((Int -> Int))
//│ | | analyze2[=;-] (Int -> Int)
//│ | | | analyze2[=;-;-] (Int,)
//│ | | | | analyze2[=;-;-] Int
//│ | | | analyze2[=;-] Int
//│ | analyze2[=] Bool
//│ [occs] 
//│ [vars] TreeSet()
//│ [rec] Set()
//│ [sub] 
//│ [bounds] 
//│ [rec] Set()
//│ transform[=] (~((Int -> Int)) & Bool)   ()  =  None
//│ | transform[=] ~((Int -> Int))   ()  =  None
//│ | | transform[=] (Int -> Int)   ()  =;-  None
//│ | | | transform[=] (Int,)   ()  =;-;-  None
//│ | | | | transform[=] Int   ()  =;-;-  None
//│ | | | | ~> Int
//│ | | | ~> (Int,)
//│ | | | transform[=] Int   ()  =;-  None
//│ | | | ~> Int
//│ | | ~> (Int -> Int)
//│ | ~> ~((Int -> Int))
//│ | transform[=] Bool   ()  =  None
//│ | ~> Bool
//│ ~> (~((Int -> Int)) & Bool)
//│ ⬤ Type after simplification: (~((Int -> Int)) & Bool)
//│  where: 
//│ allVarPols: 
//│ normLike[=] (~((Int -> Int)) & Bool)
//│ | norm[=] (~((Int -> Int)) & Bool)
//│ | | DNF[-,true,false,1024]((~((Int -> Int)) & Bool))
//│ | | | DNF[-,true,false,1024](~((Int -> Int)))
//│ | | | | (?!,⊥,(Int -> Int))
//│ | | | | List(~(|(Int -> Int)))
//│ | | | | DNF(0, ~(|(Int -> Int)))
//│ | | | = DNF(0, ~(|(Int -> Int)))
//│ | | | DNF[-,true,false,1024](Bool)
//│ | | | | DNF[-,true,false,1024](#bool<>)
//│ | | | | = DNF(0, #bool<>{})
//│ | | | = DNF(0, #bool<>{})
//│ | | | ????????
//│ | | | ... |(Int -> Int) ⊥
//│ | | | (%%%%%%%,List(),Some(Left((Int -> Int))),TreeMap(),#bool<>{})
//│ /!!!\ Uncaught error: scala.MatchError: (Some(#bool<>),(Int -> Int)) (of class scala.Tuple2)
//│ 	at: mlscript.NormalForms$LhsNf.$amp(NormalForms.scala:108)
//│ 	at: mlscript.NormalForms$Conjunct$.$anonfun$mk$4(NormalForms.scala:641)
//│ 	at: mlscript.NormalForms$Conjunct$.$anonfun$mk$4$adapted(NormalForms.scala:640)
//│ 	at: scala.Option.filter(Option.scala:319)
//│ 	at: mlscript.NormalForms$Conjunct$.mk(NormalForms.scala:640)
//│ 	at: mlscript.NormalForms$Conjunct.$amp(NormalForms.scala:556)
//│ 	at: mlscript.NormalForms$DNF.$anonfun$$amp$26(NormalForms.scala:762)
//│ 	at: scala.collection.immutable.List.flatMap(List.scala:293)
//│ 	at: mlscript.NormalForms$DNF.$amp(NormalForms.scala:762)
//│ 	at: mlscript.NormalForms$DNF.$anonfun$$amp$24(NormalForms.scala:707)

def test: ~(int -> int) & ~(bool -> bool)
//│ test: ~(nothing -> (bool | int))

def test: ~(int -> int | bool -> bool)
//│ test: ~(nothing -> (bool | int))

def test: ~(int -> int & string -> string) & ~(bool -> bool & number -> number)
//│ test: in ~(nothing -> (number | string) & int -> number & nothing -> (bool | string) & nothing -> (bool | int)) out ~(nothing -> (bool | int) & nothing -> (bool | string) & int -> number & nothing -> (number | string))



