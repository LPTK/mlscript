// * Adaptation of QML's original existentials example; using encoded existentials and plain records


:NoRecursiveTypes
:GeneralizeCurriedFunctions
// :DistributeForalls
// :ArgGen
// :NoConstrainedTypes



type ArraysRep[A, Rep] = {
    init: A -> Rep;
    sub: Rep -> int -> A;
    update: Rep -> int -> A -> Rep;
    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
  }
//│ Defined type alias ArraysRep[=A, =Rep]

type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ Defined type alias Arrays[=A]


def baseImpl: ArraysRep['a, 'a]
baseImpl = {
    init   = fun a -> a;
    sub    = fun r -> fun (i : int) -> r;
    update = fun r -> fun (i : int) -> fun a -> a;
    fold   = fun f -> fun b -> fun r -> f r b
  }
//│ baseImpl: ArraysRep['a, 'a]
//│         = <missing implementation>
//│ {fold: forall 'a. 'a -> (forall 'b. 'b -> (forall 'b, 'c, 'd, 'a, 'e. ('c -> 'e
//│   where
//│     'a <: 'c -> ('b -> 'e & 'd)))), init: forall 'f. 'f -> 'f, sub: forall 'g. 'g -> int -> 'g, update: forall 'h. 'h -> int -> (forall 'i. 'i -> 'i)}
//│   <:  baseImpl:
//│ ArraysRep['a, 'a]
//│         = {
//│             init: [Function: init],
//│             sub: [Function: sub],
//│             update: [Function: update],
//│             fold: [Function: fold]
//│           }

def base: Arrays['a]
def base f = f baseImpl
//│ base: Arrays['a]
//│     = <missing implementation>
//│ ((forall 'a. ArraysRep['a, 'a]) -> 'b & 'c) -> 'b
//│   <:  base:
//│ Arrays['a]
//│     = [Function: base]


def stepImpl_ty: ArraysRep['a, 'r] -> ArraysRep['a, ('r, string)]
//│ stepImpl_ty: ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│            = <missing implementation>

// * Not enough to type `step` later in the file
def stepImpl arrImpl = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0
  }
//│ stepImpl: 'a -> {fold: forall 'b. 'b -> (forall 'c. 'c -> (forall 'd, 'c, 'fold, 'e, 'f, 'a, 'g, 'b, 'h. (('e, 'h,) -> 'f
//│   where
//│     'a <: {fold: 'b -> ('c -> ('e -> 'f & 'g) & 'd) & 'fold}))), init: forall 'i, 'j, 'init, 'a. ('i -> ('j, "hi",)
//│   where
//│     'a <: {init: 'i -> 'j & 'init}), sub: forall 'k, 'l. ('k, 'l,) -> (forall 'm, 'n, 'o, 'sub, 'a, 'k. ('n -> 'm
//│   where
//│     'a <: {sub: 'k -> ('n -> 'm & 'o) & 'sub})), update: forall 'p, 'q. ('p, 'q,) -> (forall 'r. 'r -> (forall 'r, 'update, 's, 't, 'p, 'u, 'v, 'a. ('s -> ('v, "hey",)
//│   where
//│     'a <: {update: 'p -> ('r -> ('s -> 'v & 'u) & 't) & 'update})))}
//│         = [Function: stepImpl]

stepImpl_ty = stepImpl
//│ 'a -> {fold: forall 'b. 'b -> (forall 'c. 'c -> (forall 'a, 'b, 'd, 'e, 'f, 'g, 'h, 'fold, 'c. (('f, 'e,) -> 'h
//│   where
//│     'a <: {fold: 'b -> ('c -> ('f -> 'h & 'g) & 'd) & 'fold}))), init: forall 'i, 'j, 'init, 'a. ('i -> ('j, "hi",)
//│   where
//│     'a <: {init: 'i -> 'j & 'init}), sub: forall 'k, 'l. ('k, 'l,) -> (forall 'm, 'k, 'n, 'sub, 'a, 'o. ('n -> 'o
//│   where
//│     'a <: {sub: 'k -> ('n -> 'o & 'm) & 'sub})), update: forall 'p, 'q. ('p, 'q,) -> (forall 'r. 'r -> (forall 'update, 's, 'a, 'r, 't, 'u, 'p, 'v. ('t -> ('u, "hey",)
//│   where
//│     'a <: {update: 'p -> ('r -> ('t -> 'u & 'v) & 's) & 'update})))}
//│   <:  stepImpl_ty:
//│ ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│            = [Function: stepImpl]

type Fold[A, Rep] = (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ Defined type alias Fold[+A, -Rep]

// * Bad annotation: polymorphism level at which it's typed makes 'a and 'rep locally quantified,
// *  which is NOT what we want!
def stepImpl_Ann_1 arrImpl = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> (arrImpl.fold: Fold['a, 'rep]) f b r0
  }
//│ stepImpl_Ann_1: 'c -> {fold: forall 'd. 'd -> (forall 'e. 'e -> (forall 'f, 'a, 'g, 'rep, 'c, 'fold, 'b, 'h, 'rep0, 'e, 'a0, 'd. (('f & 'rep0, 'h,) -> ('e | 'g)
//│   where
//│     'c <: {fold: Fold['a, 'rep] & 'fold}
//│     'd <: 'a0 -> ('b | 'e) -> ('b & 'g)))), init: forall 'init, 'c, 'i, 'j. ('i -> ('j, "hi",)
//│   where
//│     'c <: {init: 'i -> 'j & 'init}), sub: forall 'k, 'l. ('k, 'l,) -> (forall 'm, 'n, 'c, 'k, 'sub, 'o. ('o -> 'm
//│   where
//│     'c <: {sub: 'k -> ('o -> 'm & 'n) & 'sub})), update: forall 'p, 'q. ('p, 'q,) -> (forall 'r. 'r -> (forall 's, 'update, 'r, 'c, 't, 'u, 'p, 'v. ('s -> ('v, "hey",)
//│   where
//│     'c <: {update: 'p -> ('r -> ('s -> 'v & 'u) & 't) & 'update})))}
//│               = [Function: stepImpl_Ann_1]

// * Still not enough to type `step` later in the file – this annotation actually doesn't help at all
def stepImpl_Ann_2 (arrImpl: ArraysRep['a, 'r]) = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0
  }
//│ stepImpl_Ann_2: ArraysRep['a, 'r] -> {fold: forall 'c. 'c -> (forall 'd. 'd -> (forall 'a, 'e, 'd, 'c, 'f, 'b, 'r, 'g. (('r & 'g, 'e,) -> ('d | 'f)
//│   where
//│     'c <: 'a -> ('b | 'd) -> ('b & 'f)))), init: forall 'h, 'i. ('a & 'h) -> ('r | 'i, "hi",), sub: forall 'j, 'k. ('r & 'j, 'k,) -> (forall 'l, 'm, 'n. (int & 'l & 'm) -> ('a | 'n)), update: forall 'o, 'p. ('r & 'o, 'p,) -> (forall 'm. (int & 'm) -> (forall 'q, 's. ('a & 's) -> ('r | 'q, "hey",)))}
//│               = [Function: stepImpl_Ann_2]

stepImpl_ty = stepImpl_Ann_2
//│ ArraysRep['a, 'r] -> {fold: forall 'c. 'c -> (forall 'd. 'd -> (forall 'e, 'c, 'f, 'd, 'r, 'b, 'a, 'g. (('r & 'e, 'f,) -> ('d | 'g)
//│   where
//│     'c <: 'a -> ('b | 'd) -> ('b & 'g)))), init: forall 'h, 'i. ('a & 'i) -> ('r | 'h, "hi",), sub: forall 'j, 'k. ('r & 'j, 'k,) -> (forall 'l, 'm, 'n. (int & 'l & 'm) -> ('a | 'n)), update: forall 'o, 'p. ('r & 'o, 'p,) -> (forall 'm. (int & 'm) -> (forall 'q, 's. ('a & 'q) -> ('r | 's, "hey",)))}
//│   <:  stepImpl_ty:
//│ ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│            = [Function: stepImpl_Ann_2]

// * This one seems that it would work but it's again typed at the wrong polymorphism level (I think?)
def stepImpl_Ann_3 arrImpl = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = (fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0) : Fold['a, ('rep, string)]
  }
//│ stepImpl_Ann_3: ({fold: (‘a_1060_1086 -> (‘b_1061_1087 & 'b) -> (‘b_1061_1087 | 'c) | 'd) -> ((‘b_1061_1087 | 'c) -> ((‘rep_1062_1092 | 'e) -> (‘b_1061_1087 & 'b) & 'f) & 'g) & 'fold} & 'h) -> {fold: Fold['a, ('rep, string,)], init: forall 'i, 'j, 'init, 'h. ('i -> ('j, "hi",)
//│   where
//│     'h <: {init: 'i -> 'j & 'init}), sub: forall 'k, 'l. ('k, 'l,) -> (forall 'm, 'n, 'h, 'o, 'k, 'sub. ('m -> 'n
//│   where
//│     'h <: {sub: 'k -> ('m -> 'n & 'o) & 'sub})), update: forall 'p, 'q. ('p, 'q,) -> (forall 'r. 'r -> (forall 's, 'r, 'update, 't, 'h, 'p, 'u, 'v. ('v -> ('u, "hey",)
//│   where
//│     'h <: {update: 'p -> ('r -> ('v -> 'u & 't) & 's) & 'update})))}
//│               = [Function: stepImpl_Ann_3]

:e
stepImpl_ty = stepImpl_Ann_3
//│ ({fold: (‘a_1060_1086 -> (‘b_1061_1087 & 'b) -> (‘b_1061_1087 | 'c) | 'd) -> ((‘b_1061_1087 | 'c) -> ((‘rep_1062_1092 | 'e) -> (‘b_1061_1087 & 'b) & 'f) & 'g) & 'fold} & 'h) -> {fold: Fold['a, ('rep, string,)], init: forall 'i, 'j, 'init, 'h. ('i -> ('j, "hi",)
//│   where
//│     'h <: {init: 'i -> 'j & 'init}), sub: forall 'k, 'l. ('k, 'l,) -> (forall 'k, 'sub, 'h, 'm, 'n, 'o. ('n -> 'o
//│   where
//│     'h <: {sub: 'k -> ('n -> 'o & 'm) & 'sub})), update: forall 'p, 'q. ('p, 'q,) -> (forall 'r. 'r -> (forall 'p, 's, 't, 'h, 'u, 'update, 'r, 'v. ('u -> ('s, "hey",)
//│   where
//│     'h <: {update: 'p -> ('r -> ('u -> 's & 'v) & 't) & 'update})))}
//│   <:  stepImpl_ty:
//│ ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.151: 	stepImpl_ty = stepImpl_Ann_3
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a_1289` is not an instance of type `'a_1060_1086`
//│ ║  l.55: 	def stepImpl_ty: ArraysRep['a, 'r] -> ArraysRep['a, ('r, string)]
//│ ║        	                           ^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.139: 	    fold   = (fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0) : Fold['a, ('rep, string)]
//│ ╙──       	                                                                              ^^
//│            = [Function: stepImpl_Ann_3]

// * This one finally works! The annotation needs to be on the result!
// *  Notice the skolem in the parameter's inferred fold type:
def stepImpl_Ann_4 arrImpl = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0
  } : ArraysRep['a, 'r]
//│ stepImpl_Ann_4: ({fold: ('a -> (‘b_1483_1507 & 'b) -> (‘b_1483_1507 | 'c) | 'd) -> ((‘b_1483_1507 | 'c) -> ('e -> (‘b_1483_1507 & 'b) & 'f) & 'g) & 'fold, init: 'h -> ('e & 'i & 'j & 'k & 'l) & 'init, sub: 'l -> ((int | 'm) -> ('a & 'n) & 'o) & 'sub, update: 'k -> ((int | 'm | 'p) -> ('q -> ('e & 'j & 'k & 'l & 's) & 't) & 'u) & 'update} & 'v) -> ArraysRep['a, 'r]
//│   where
//│     'r :> ('i | 's, "hey" | "hi",)
//│        <: ('e & 'j & 'k & 'l, 'w & 'x & 'y,)
//│     'a <: 'q & 'h
//│               = [Function: stepImpl_Ann_4]

test = stepImpl_Ann_4 baseImpl
//│ test: ArraysRep['a, 'r]
//│   where
//│     'r :> ('a, "hey" | "hi",)
//│        <: ('a, 'b & 'c & 'd,)
//│     = {
//│         init: [Function: init],
//│         sub: [Function: sub],
//│         update: [Function: update],
//│         fold: [Function: fold]
//│       }

stepImpl_ty = stepImpl_Ann_4
//│ ({fold: ('a -> (‘b_1483_1507 & 'b) -> (‘b_1483_1507 | 'c) | 'd) -> ((‘b_1483_1507 | 'c) -> ('e -> (‘b_1483_1507 & 'b) & 'f) & 'g) & 'fold, init: 'h -> ('e & 'i & 'j & 'k & 'l) & 'init, sub: 'l -> ((int | 'm) -> ('a & 'n) & 'o) & 'sub, update: 'k -> ((int | 'm | 'p) -> ('q -> ('e & 'j & 'k & 'l & 's) & 't) & 'u) & 'update} & 'v) -> ArraysRep['a, 'r]
//│   where
//│     'r :> ('i | 's, "hey" | "hi",)
//│        <: ('e & 'j & 'k & 'l, 'w & 'x & 'y,)
//│     'a <: 'q & 'h
//│   <:  stepImpl_ty:
//│ ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│            = [Function: stepImpl_Ann_4]

// * Note: this one expectedly doesn't work, as in `QML_exist_Classes.mls`
// def stepImpl2 (arr: Arrays['a]) = arr stepImpl

def stepImpl2 arr = arr stepImpl
//│ stepImpl2: ((forall 'a. 'a -> {fold: forall 'b. 'b -> (forall 'c. 'c -> (forall 'd, 'c, 'e, 'b, 'f, 'a, 'fold, 'g, 'h. (('f, 'h,) -> 'g
//│   where
//│     'a <: {fold: 'b -> ('c -> ('f -> 'g & 'd) & 'e) & 'fold}))), init: forall 'i, 'init, 'a, 'j. ('j -> ('i, "hi",)
//│   where
//│     'a <: {init: 'j -> 'i & 'init}), sub: forall 'k, 'l. ('k, 'l,) -> (forall 'sub, 'm, 'k, 'a, 'n, 'o. ('o -> 'n
//│   where
//│     'a <: {sub: 'k -> ('o -> 'n & 'm) & 'sub})), update: forall 'p, 'q. ('p, 'q,) -> (forall 'r. 'r -> (forall 'update, 'r, 's, 't, 'a, 'u, 'v, 'p. ('s -> ('t, "hey",)
//│   where
//│     'a <: {update: 'p -> ('r -> ('s -> 't & 'v) & 'u) & 'update})))}) -> 'w & 'x) -> 'w
//│          = [Function: stepImpl2]

def stepImpl2_ arr = arr stepImpl_ty
//│ stepImpl2_: ((forall 'a, 'r. ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]) -> 'b & 'c) -> 'b
//│           = [Function: stepImpl2_]

// * Expectedly doesn't work (see comment on `stepImpl_Ann_1`)
// def stepImpl2_Ann_1 arr = arr stepImpl_Ann_1

def stepImpl2_Ann_2 arr = arr stepImpl_Ann_2
//│ stepImpl2_Ann_2: ((forall 'a, 'r. ArraysRep['a, 'r] -> {fold: forall 'c. 'c -> (forall 'd. 'd -> (forall 'b, 'r, 'a, 'e, 'f, 'd, 'c, 'g. (('r & 'f, 'e,) -> ('d | 'g)
//│   where
//│     'c <: 'a -> ('b | 'd) -> ('b & 'g)))), init: forall 'h, 'i. ('a & 'h) -> ('r | 'i, "hi",), sub: forall 'j, 'k. ('r & 'j, 'k,) -> (forall 'l, 'm, 'n. (int & 'l & 'm) -> ('a | 'n)), update: forall 'o, 'p. ('r & 'p, 'o,) -> (forall 'm. (int & 'm) -> (forall 'q, 's. ('a & 'q) -> ('r | 's, "hey",)))}) -> 't & 'u) -> 't
//│                = [Function: stepImpl2_Ann_2]

def stepImpl2_Ann_3 arr = arr stepImpl_Ann_3
//│ stepImpl2_Ann_3: ((forall 'b, 'c, 'fold, 'd, 'rep, 'e, 'f, 'g, 'a, 'h. ({fold: (‘a_1060_1086 -> (‘b_1061_1087 & 'c) -> (‘b_1061_1087 | 'd) | 'h) -> ((‘b_1061_1087 | 'd) -> ((‘rep_1062_1092 | 'f) -> (‘b_1061_1087 & 'c) & 'e) & 'b) & 'fold} & 'g) -> {fold: Fold['a, ('rep, string,)], init: forall 'g, 'i, 'j, 'init. ('i -> ('j, "hi",)
//│   where
//│     'g <: {init: 'i -> 'j & 'init}), sub: forall 'k, 'l. ('k, 'l,) -> (forall 'm, 'n, 'o, 'g, 'k, 'sub. ('m -> 'n
//│   where
//│     'g <: {sub: 'k -> ('m -> 'n & 'o) & 'sub})), update: forall 'p, 'q. ('p, 'q,) -> (forall 'r. 'r -> (forall 's, 'update, 't, 'p, 'u, 'r, 'v, 'g. ('t -> ('s, "hey",)
//│   where
//│     'g <: {update: 'p -> ('r -> ('t -> 's & 'v) & 'u) & 'update})))}) -> 'w & 'x) -> 'w
//│                = [Function: stepImpl2_Ann_3]

def stepImpl2_Ann_4 arr = arr stepImpl_Ann_4
//│ stepImpl2_Ann_4: ((forall 'b, 'c, 'update, 'd, 'e, 'f, 'g, 'h, 'i, 'init, 'j, 'k, 'fold, 'l, 'm, 'r, 'n, 'o, 'p, 'q, 's, 'sub, 't, 'u, 'v, 'a, 'w, 'x, 'y. ({fold: ('a -> (‘b_1483_1507 & 'm) -> (‘b_1483_1507 | 'k) | 'u) -> ((‘b_1483_1507 | 'k) -> ('p -> (‘b_1483_1507 & 'm) & 'd) & 'x) & 'fold, init: 'g -> ('p & 'h & 'c & 'v & 'l) & 'init, sub: 'l -> ((int | 'y) -> ('a & 'e) & 'q) & 'sub, update: 'v -> ((int | 'y | 's) -> ('b -> ('p & 'c & 'v & 'l & 't) & 'w) & 'o) & 'update} & 'n) -> ArraysRep['a, 'r]) -> 'z & 'a1) -> 'z
//│   where
//│     'r :> ('h | 't, "hey" | "hi",)
//│        <: ('p & 'c & 'v & 'l, 'j & 'i & 'f,)
//│     'a <: 'b & 'g
//│                = [Function: stepImpl2_Ann_4]

def stepImpl2_Ann_2_Ann (arr: Arrays['a]) = arr stepImpl_Ann_2
// def stepImpl2_Ann_2_Ann (arr: Arrays['a]) = arr stepImpl_Ann_2 : Arrays['a]
// def stepImpl2_Ann_2_Ann (arr: ArraysRep['a, 'r]) = arr stepImpl_Ann_2
//│ stepImpl2_Ann_2_Ann: Arrays['a] -> ({fold: forall 'c. 'c -> (forall 'd. 'd -> (forall 'e, 'f, 'a0, 'g, 'c, 'a1, 'r, 'd, 'b, 'r0, 'a2. ((‘Rep_2198_2243 & 'r0 & 'r & 'g, 'e,) -> ('f | 'd)
//│   where
//│     'c <: ('a2 | 'a0 | 'a1) -> ('b | 'd) -> ('b & 'f)))), init: forall 'h, 'i. ('h & 'a0 & 'a2) -> ('r0 | ‘Rep_2198_2243 | 'i, "hi",), sub: forall 'j, 'k. (‘Rep_2198_2243 & 'r0 & 'j & 'r, 'k,) -> (forall 'l, 'm, 'n. (int & 'l & 'm) -> ('a2 | 'a0 | 'a1 | 'n)), update: forall 'o, 'p. (‘Rep_2198_2243 & 'r0 & 'r & 'o, 'p,) -> (forall 'm. (int & 'm) -> (forall 'q, 's. ('a0 & 'a2 & 'q) -> ('r0 | ‘Rep_2198_2243 | 's, "hey",)))} | 't)
//│                    = [Function: stepImpl2_Ann_2_Ann]



def step: Arrays['a] -> Arrays['a]
//│ step: Arrays['a] -> Arrays['a]
//│     = <missing implementation>

// * There used to be a very subtly extrusion here related to the polymorphism of `arrImpl.fold`
// *  and it not being known at the `stepImpl` definition site.
// * But this problem actually disappeared after fixing a subtle bug in type freshening...!
def step arr f = f (stepImpl2 arr)
//│ 'a -> (forall 'b, 'a, 'c, 'd, 'e. (('e -> 'b & 'c) -> 'b
//│   where
//│     'a <: (forall 'f. 'f -> {fold: forall 'g. 'g -> (forall 'h. 'h -> (forall 'h, 'i, 'j, 'fold, 'k, 'f, 'l, 'g, 'm. (('m, 'l,) -> 'k
//│   where
//│     'f <: {fold: 'g -> ('h -> ('m -> 'k & 'j) & 'i) & 'fold}))), init: forall 'f, 'n, 'o, 'init. ('n -> ('o, "hi",)
//│   where
//│     'f <: {init: 'n -> 'o & 'init}), sub: forall 'p, 'q. ('q, 'p,) -> (forall 'sub, 'r, 's, 't, 'f, 'q. ('t -> 's
//│   where
//│     'f <: {sub: 'q -> ('t -> 's & 'r) & 'sub})), update: forall 'u, 'v. ('u, 'v,) -> (forall 'w. 'w -> (forall 'x, 'y, 'z, 'u, 'update, 'w, 'f, 'a1. ('y -> ('z, "hey",)
//│   where
//│     'f <: {update: 'u -> ('w -> ('y -> 'z & 'a1) & 'x) & 'update})))}) -> ('d & 'e)))
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│     = [Function: step]

// * Expectedly doesn't work (see comment on `stepImpl_Ann_1`)
// def step arr f = f (stepImpl2_Ann_1 arr)

def step arr f = f (stepImpl2_Ann_2 arr)
//│ 'c -> (forall 'd, 'e, 'c, 'f, 'g. (('d -> 'e & 'f) -> 'e
//│   where
//│     'c <: (forall 'r, 'a. ArraysRep['a, 'r] -> {fold: forall 'h. 'h -> (forall 'i. 'i -> (forall 'h, 'j, 'i, 'k, 'b, 'r, 'l, 'a. (('r & 'j, 'k,) -> ('i | 'l)
//│   where
//│     'h <: 'a -> ('b | 'i) -> ('b & 'l)))), init: forall 'm, 'n. ('a & 'm) -> ('r | 'n, "hi",), sub: forall 'o, 'p. ('r & 'o, 'p,) -> (forall 'q, 's, 't. (int & 'q & 's) -> ('a | 't)), update: forall 'u, 'v. ('r & 'u, 'v,) -> (forall 's. (int & 's) -> (forall 'w, 'x. ('a & 'w) -> ('r | 'x, "hey",)))}) -> ('g & 'd)))
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│     = [Function: step1]

:e
def step arr f = f (stepImpl2_Ann_3 arr)
//│ 'b -> (forall 'c, 'd, 'e, 'f, 'b. (('d -> 'c & 'f) -> 'c
//│   where
//│     'b <: (forall 'g, 'h, 'i, 'j, 'a, 'k, 'rep, 'l, 'fold, 'm. ({fold: (‘a_1060_1086 -> (‘b_1061_1087 & 'h) -> (‘b_1061_1087 | 'm) | 'l) -> ((‘b_1061_1087 | 'm) -> ((‘rep_1062_1092 | 'g) -> (‘b_1061_1087 & 'h) & 'j) & 'k) & 'fold} & 'i) -> {fold: Fold['a, ('rep, string,)], init: forall 'n, 'o, 'init, 'i. ('n -> ('o, "hi",)
//│   where
//│     'i <: {init: 'n -> 'o & 'init}), sub: forall 'p, 'q. ('p, 'q,) -> (forall 'r, 'i, 'sub, 's, 'p, 't. ('r -> 't
//│   where
//│     'i <: {sub: 'p -> ('r -> 't & 's) & 'sub})), update: forall 'u, 'v. ('u, 'v,) -> (forall 'w. 'w -> (forall 'x, 'i, 'u, 'y, 'z, 'a1, 'w, 'update. ('x -> ('y, "hey",)
//│   where
//│     'i <: {update: 'u -> ('w -> ('x -> 'y & 'a1) & 'z) & 'update})))}) -> ('e & 'd)))
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.302: 	def step arr f = f (stepImpl2_Ann_3 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a_2952` is not an instance of type `'a_1060_1086`
//│ ║  l.265: 	def step: Arrays['a] -> Arrays['a]
//│ ║         	                 ^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.139: 	    fold   = (fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0) : Fold['a, ('rep, string)]
//│ ╙──       	                                                                              ^^
//│     = [Function: step2]

// * This used to be the only working one based on an internal annotation
def step arr f = f (stepImpl2_Ann_4 arr)
//│ 'b -> (forall 'b, 'c, 'd, 'e, 'f. (('d -> 'c & 'f) -> 'c
//│   where
//│     'b <: (forall 'g, 'h, 'i, 'j, 'k, 'r, 'l, 'm, 'n, 'init, 'o, 'p, 'q, 's, 'a, 't, 'u, 'v, 'w, 'x, 'fold, 'y, 'update, 'z, 'a1, 'b1, 'sub, 'c1, 'd1. ({fold: ('a -> (‘b_1483_1507 & 'h) -> (‘b_1483_1507 | 'q) | 'w) -> ((‘b_1483_1507 | 'q) -> ('z -> (‘b_1483_1507 & 'h) & 'p) & 'i) & 'fold, init: 'v -> ('z & 'd1 & 'y & 'x & 't) & 'init, sub: 't -> ((int | 'm) -> ('a & 'j) & 's) & 'sub, update: 'x -> ((int | 'm | 'l) -> ('b1 -> ('z & 'y & 'x & 't & 'k) & 'g) & 'u) & 'update} & 'o) -> ArraysRep['a, 'r]) -> ('e & 'd)))
//│   where
//│     'r :> ('d1 | 'k, "hey" | "hi",)
//│        <: ('z & 'y & 'x & 't, 'n & 'c1 & 'a1,)
//│     'a <: 'b1 & 'v
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│     = [Function: step3]

def step arr f = f (stepImpl2_Ann_2_Ann arr)
//│ 'c -> (forall 'd, 'e, 'c, 'a. (((forall 'r, 'a0, 'f, 'a1, 'r0, 'g, 'a2. {fold: forall 'h. 'h -> (forall 'i. 'i -> (forall 'r, 'h, 'a0, 'i, 'b, 'a1, 'j, 'k, 'r0, 'l, 'a2. ((‘Rep_2198_2243 & 'r & 'r0 & 'l, 'j,) -> ('k | 'i)
//│   where
//│     'h <: ('a1 | 'a2 | 'a0) -> ('b | 'i) -> ('b & 'k)))), init: forall 'm, 'n. ('m & 'a2 & 'a1) -> ('r | ‘Rep_2198_2243 | 'n, "hi",), sub: forall 'o, 'p. (‘Rep_2198_2243 & 'r & 'o & 'r0, 'p,) -> (forall 'q, 's, 't. (int & 'q & 's) -> ('a1 | 'a2 | 'a0 | 't)), update: forall 'u, 'v. (‘Rep_2198_2243 & 'r & 'r0 & 'u, 'v,) -> (forall 's. (int & 's) -> (forall 'w, 'x. ('a2 & 'a1 & 'w) -> ('r | ‘Rep_2198_2243 | 'x, "hey",)))} | 'g | 'f) -> 'd & 'e) -> 'd
//│   where
//│     'c <: Arrays['a]))
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│     = [Function: step4]

def step (arr: Arrays['a]) f = f (stepImpl2_Ann_2_Ann arr)
//│ Arrays['a] -> (forall 'c, 'd. ((forall 'a0, 'a1, 'a2, 'r, 'e, 'r0, 'f. {fold: forall 'g. 'g -> (forall 'h. 'h -> (forall 'r, 'a0, 'h, 'b, 'i, 'j, 'k, 'r0, 'a1, 'g, 'a2. ((‘Rep_2198_2243 & 'r0 & 'r & 'i, 'j,) -> ('k | 'h)
//│   where
//│     'g <: ('a2 | 'a1 | 'a0) -> ('b | 'h) -> ('b & 'k)))), init: forall 'l, 'm. ('l & 'a1 & 'a2) -> ('r0 | ‘Rep_2198_2243 | 'm, "hi",), sub: forall 'n, 'o. (‘Rep_2198_2243 & 'r0 & 'n & 'r, 'o,) -> (forall 'p, 'q, 's. (int & 'p & 'q) -> ('a2 | 'a1 | 'a0 | 's)), update: forall 't, 'u. (‘Rep_2198_2243 & 'r0 & 'r & 't, 'u,) -> (forall 'q. (int & 'q) -> (forall 'v, 'w. ('a1 & 'a2 & 'v) -> ('r0 | ‘Rep_2198_2243 | 'w, "hey",)))} | 'f | 'e) -> 'c & 'd) -> 'c)
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│     = [Function: step5]

// * Also works, but this one is easier as it internally uses the fully-annotated `stepImpl_ty`
def step arr f = f (stepImpl2_ arr)
//│ 'b -> (forall 'c, 'b, 'd, 'e, 'f. (('d -> 'e & 'c) -> 'e
//│   where
//│     'b <: (forall 'a, 'r. ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]) -> ('f & 'd)))
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│     = [Function: step6]



ssb = step (step base)
//│ ssb: Arrays['a]
//│    = [Function (anonymous)]

ssb (fun arr ->
    let r2 = arr.update (arr.init true) 1 false
    in (arr.sub r2 0, arr.sub r2 1)
  )
//│ res: (bool, bool,)
//│    = [ false, false ]



rec def mkMonoArray n =
  if n == 0 then base else step (mkMonoArray(n - 1))
//│ mkMonoArray: int -> (forall 'a. Arrays['a])
//│            = [Function: mkMonoArray]

snb = mkMonoArray 5
//│ snb: Arrays['a] | 'b
//│    = [Function (anonymous)]

snb (fun arr -> arr.init true)
//│ res: ‘Rep_3823_3827 | ‘Rep_3830_3834
//│    = [ [ [ [Array], 'hi' ], 'hi' ], 'hi' ]



