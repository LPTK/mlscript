// * Adaptation of QML's original existentials example; using encoded existentials and plain records


:NoRecursiveTypes
// :DistributeForalls
// :GeneralizeArguments
// :ConstrainedTypes



type ArraysRep[A, Rep] = {
    init: A -> Rep;
    sub: Rep -> int -> A;
    update: Rep -> int -> A -> Rep;
    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
  }
//│ Defined type alias ArraysRep[=A, =Rep]

type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ Defined type alias Arrays[=A]


def baseImpl: ArraysRep['a, 'a]
baseImpl = {
    init   = fun a -> a;
    sub    = fun r -> fun (i : int) -> r;
    update = fun r -> fun (i : int) -> fun a -> a;
    fold   = fun f -> fun b -> fun r -> f r b
  }
//│ baseImpl: ArraysRep['a, 'a]
//│         = <missing implementation>
//│ {fold: forall 'a 'b 'c. ('a -> 'b -> 'c) -> 'b -> 'a -> 'c, init: forall 'd. 'd -> 'd, sub: forall 'e. 'e -> int -> 'e, update: forall 'f. anything -> int -> 'f -> 'f}
//│   <:  baseImpl:
//│ ArraysRep['a, 'a]
//│         = {
//│             init: [Function: init],
//│             sub: [Function: sub],
//│             update: [Function: update],
//│             fold: [Function: fold]
//│           }

def base: Arrays['a]
def base f = f baseImpl
//│ base: Arrays['a]
//│     = <missing implementation>
//│ ((forall 'a. ArraysRep['a, 'a]) -> 'b) -> 'b
//│   <:  base:
//│ Arrays['a]
//│     = [Function: base]


def stepImpl_ty: ArraysRep['a, 'r] -> ArraysRep['a, ('r, string)]
//│ stepImpl_ty: ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│            = <missing implementation>

// * Not enough to type `step` later in the file
def stepImpl arrImpl = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0
  }
//│ stepImpl: {fold: 'a -> 'b -> 'c -> 'd, init: 'e -> 'f, sub: 'g -> 'h -> 'i, update: 'j -> 'k -> 'l -> 'm} -> {fold: 'a -> 'b -> ('c, anything,) -> 'd, init: 'e -> ('f, "hi",), sub: ('g, anything,) -> 'h -> 'i, update: ('j, anything,) -> 'k -> 'l -> ('m, "hey",)}
//│         = [Function: stepImpl]

:e // * Since "sound extrusion"
stepImpl_ty = stepImpl
//│ {fold: 'a -> 'b -> 'c -> 'd, init: 'e -> 'f, sub: 'g -> 'h -> 'i, update: 'j -> 'k -> 'l -> 'm} -> {fold: 'a -> 'b -> ('c, anything,) -> 'd, init: 'e -> ('f, "hi",), sub: ('g, anything,) -> 'h -> 'i, update: ('j, anything,) -> 'k -> 'l -> ('m, "hey",)}
//│   <:  stepImpl_ty:
//│ ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.67: 	stepImpl_ty = stepImpl
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.15: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.15: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ╙──      	                 ^^
//│            = [Function: stepImpl]

type Fold[A, Rep] = (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ Defined type alias Fold[+A, -Rep]

// * Bad annotation: polymorphism level at which it's typed makes 'a and 'rep locally quantified,
// *  which is NOT what we want!
def stepImpl_Ann_1 arrImpl = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> (arrImpl.fold: Fold['a, 'rep]) f b r0
  }
//│ stepImpl_Ann_1: {fold: Fold[?, ?], init: 'a -> 'c, sub: 'd -> 'e -> 'f, update: 'g -> 'h -> 'i -> 'j} -> {fold: forall 'b. (nothing -> 'b -> 'b) -> 'b -> (anything, anything,) -> 'b, init: 'a -> ('c, "hi",), sub: ('d, anything,) -> 'e -> 'f, update: ('g, anything,) -> 'h -> 'i -> ('j, "hey",)}
//│               = [Function: stepImpl_Ann_1]

// * Still not enough to type `step` later in the file – this annotation actually doesn't help at all
def stepImpl_Ann_2 (arrImpl: ArraysRep['a, 'r]) = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0
  }
//│ stepImpl_Ann_2: ArraysRep['a, 'r] -> {fold: forall 'b. ('a -> 'b -> 'b) -> 'b -> ('r, anything,) -> 'b, init: 'a -> ('r, "hi",), sub: ('r, anything,) -> int -> 'a, update: ('r, anything,) -> int -> 'a -> ('r, "hey",)}
//│               = [Function: stepImpl_Ann_2]

stepImpl_ty = stepImpl_Ann_2
//│ ArraysRep['a, 'r] -> {fold: forall 'b. ('a -> 'b -> 'b) -> 'b -> ('r, anything,) -> 'b, init: 'a -> ('r, "hi",), sub: ('r, anything,) -> int -> 'a, update: ('r, anything,) -> int -> 'a -> ('r, "hey",)}
//│   <:  stepImpl_ty:
//│ ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│            = [Function: stepImpl_Ann_2]

// * This one seems that it would work but it's again typed at the wrong polymorphism level (I think?)
def stepImpl_Ann_3 arrImpl = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = (fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0) : Fold['a, ('rep, string)]
  }
//│ stepImpl_Ann_3: {fold: (nothing -> nothing -> anything) -> anything -> anything -> nothing, init: 'a -> 'b, sub: 'c -> 'd -> 'e, update: 'f -> 'g -> 'h -> 'i} -> {fold: Fold[nothing, (anything, string,)], init: 'a -> ('b, "hi",), sub: ('c, anything,) -> 'd -> 'e, update: ('f, anything,) -> 'g -> 'h -> ('i, "hey",)}
//│               = [Function: stepImpl_Ann_3]

:e
stepImpl_ty = stepImpl_Ann_3
//│ {fold: (nothing -> nothing -> anything) -> anything -> anything -> nothing, init: 'a -> 'b, sub: 'c -> 'd -> 'e, update: 'f -> 'g -> 'h -> 'i} -> {fold: Fold[nothing, (anything, string,)], init: 'a -> ('b, "hi",), sub: ('c, anything,) -> 'd -> 'e, update: ('f, anything,) -> 'g -> 'h -> ('i, "hey",)}
//│   <:  stepImpl_ty:
//│ ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.123: 	stepImpl_ty = stepImpl_Ann_3
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `'a` does not match type `nothing`
//│ ║  l.52: 	def stepImpl_ty: ArraysRep['a, 'r] -> ArraysRep['a, ('r, string)]
//│ ║        	                           ^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.117: 	    fold   = (fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0) : Fold['a, ('rep, string)]
//│ ╙──       	                                                                              ^^
//│            = [Function: stepImpl_Ann_3]

// * This one finally works! The annotation needs to be on the result!
// *  Notice the skolem in the parameter's inferred fold type:
def stepImpl_Ann_4 arrImpl = {
    init   = fun a -> (arrImpl.init a, "hi");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.update r0 i a, "hey");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0
  } : ArraysRep['a, 'r]
//│ stepImpl_Ann_4: {fold: ('a -> nothing -> anything) -> anything -> 'b -> nothing, init: ('c | 'd) -> ('b & 'e), sub: 'b -> int -> 'd, update: 'b -> int -> ('c | 'd) -> ('b & 'e)} -> ArraysRep['a, 'r]
//│   where
//│     'r :> ('e, "hey" | "hi",)
//│        <: ('b, anything,)
//│     'a :> 'd
//│        <: 'c
//│               = [Function: stepImpl_Ann_4]

:e // * Since "sound extrusion"
test = stepImpl_Ann_4 baseImpl
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.155: 	test = stepImpl_Ann_4 baseImpl
//│ ║         	       ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.15: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.15: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ╙──      	                 ^^
//│ test: ArraysRep['a, 'r]
//│   where
//│     'r :> (nothing, "hey" | "hi",) | error
//│        <: ('a, anything,)
//│     'a :> error
//│     = {
//│         init: [Function: init],
//│         sub: [Function: sub],
//│         update: [Function: update],
//│         fold: [Function: fold]
//│       }

:e // * Since "sound extrusion"
stepImpl_ty = stepImpl_Ann_4
//│ {fold: ('a -> nothing -> anything) -> anything -> 'b -> nothing, init: ('c | 'd) -> ('b & 'e), sub: 'b -> int -> 'd, update: 'b -> int -> ('c | 'd) -> ('b & 'e)} -> ArraysRep['a, 'r]
//│   where
//│     'r :> ('e, "hey" | "hi",)
//│        <: ('b, anything,)
//│     'a :> 'd
//│        <: 'c
//│   <:  stepImpl_ty:
//│ ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.178: 	stepImpl_ty = stepImpl_Ann_4
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.15: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.15: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ╙──      	                 ^^
//│            = [Function: stepImpl_Ann_4]

// * Note: this one expectedly doesn't work, as in `QML_exist_Classes.mls`
// def stepImpl2 (arr: Arrays['a]) = arr stepImpl

def stepImpl2 arr = arr stepImpl
//│ stepImpl2: ((forall 'a 'b 'c 'd 'e 'f 'g 'h 'i 'j 'k 'l 'm. {fold: 'm -> 'b -> 'k -> 'l, init: 'g -> 'd, sub: 'h -> 'j -> 'a, update: 'c -> 'e -> 'i -> 'f} -> {fold: 'm -> 'b -> ('k, anything,) -> 'l, init: 'g -> ('d, "hi",), sub: ('h, anything,) -> 'j -> 'a, update: ('c, anything,) -> 'e -> 'i -> ('f, "hey",)}) -> 'n) -> 'n
//│          = [Function: stepImpl2]

def stepImpl2_ arr = arr stepImpl_ty
//│ stepImpl2_: ((forall 'a 'r. ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]) -> 'b) -> 'b
//│           = [Function: stepImpl2_]

// * Expectedly doesn't work (see comment on `stepImpl_Ann_1`)
// def stepImpl2_Ann_1 arr = arr stepImpl_Ann_1

def stepImpl2_Ann_2 arr = arr stepImpl_Ann_2
//│ stepImpl2_Ann_2: ((forall 'a 'r. ArraysRep['a, 'r] -> {fold: forall 'b. ('a -> 'b -> 'b) -> 'b -> ('r, anything,) -> 'b, init: 'a -> ('r, "hi",), sub: ('r, anything,) -> int -> 'a, update: ('r, anything,) -> int -> 'a -> ('r, "hey",)}) -> 'c) -> 'c
//│                = [Function: stepImpl2_Ann_2]

def stepImpl2_Ann_3 arr = arr stepImpl_Ann_3
//│ stepImpl2_Ann_3: ((forall 'a 'b 'c 'd 'e 'f 'g 'h 'i. {fold: (nothing -> nothing -> anything) -> anything -> anything -> nothing, init: 'i -> 'a, sub: 'c -> 'f -> 'g, update: 'h -> 'b -> 'd -> 'e} -> {fold: Fold[nothing, (anything, string,)], init: 'i -> ('a, "hi",), sub: ('c, anything,) -> 'f -> 'g, update: ('h, anything,) -> 'b -> 'd -> ('e, "hey",)}) -> 'j) -> 'j
//│                = [Function: stepImpl2_Ann_3]

def stepImpl2_Ann_4 arr = arr stepImpl_Ann_4
//│ stepImpl2_Ann_4: ((forall 'a 'b 'c 'd 'e 'r. {fold: ('a -> nothing -> anything) -> anything -> 'c -> nothing, init: ('d | 'e) -> ('c & 'b), sub: 'c -> int -> 'e, update: 'c -> int -> ('d | 'e) -> ('c & 'b)} -> ArraysRep['a, 'r]) -> 'f) -> 'f
//│   where
//│     'r :> ('b, "hey" | "hi",)
//│        <: ('c, anything,)
//│     'a :> 'e
//│        <: 'd
//│                = [Function: stepImpl2_Ann_4]

def stepImpl2_Ann_2_Ann (arr: Arrays['a]) = arr stepImpl_Ann_2
// def stepImpl2_Ann_2_Ann (arr: Arrays['a]) = arr stepImpl_Ann_2 : Arrays['a]
// def stepImpl2_Ann_2_Ann (arr: ArraysRep['a, 'r]) = arr stepImpl_Ann_2
//│ stepImpl2_Ann_2_Ann: Arrays['a] -> {fold: forall 'b. ('a0 -> 'b -> 'b) -> 'b -> (nothing, anything,) -> 'b, init: 'a0 -> (anything, "hi",), sub: (nothing, anything,) -> int -> 'a0, update: (nothing, anything,) -> int -> 'a0 -> (anything, "hey",)}
//│                    = [Function: stepImpl2_Ann_2_Ann]



def step: Arrays['a] -> Arrays['a]
//│ step: Arrays['a] -> Arrays['a]
//│     = <missing implementation>

// * There used to be a very subtly extrusion here related to the polymorphism of `arrImpl.fold`
// *  and it not being known at the `stepImpl` definition site.
// * But this problem actually disappeared after fixing a subtle bug in type freshening...!
:e // * Since "sound extrusion"
def step arr f = f (stepImpl2 arr)
//│ ((forall 'a 'b 'c 'd 'e 'f 'g 'h 'i 'j 'k 'l 'm. {fold: 'k -> 'b -> 'c -> 'l, init: 'i -> 'e, sub: 'd -> 'm -> 'h, update: 'g -> 'j -> 'a -> 'f} -> {fold: 'k -> 'b -> ('c, anything,) -> 'l, init: 'i -> ('e, "hi",), sub: ('d, anything,) -> 'm -> 'h, update: ('g, anything,) -> 'j -> 'a -> ('f, "hey",)}) -> 'n) -> ('n -> 'o) -> 'o
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.245: 	def step arr f = f (stepImpl2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.19: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.19: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.59: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
//│ ╙──      	                                                    ^^
//│     = [Function: step]

// * Expectedly doesn't work (see comment on `stepImpl_Ann_1`)
// def step arr f = f (stepImpl2_Ann_1 arr)

:e // * Since "sound extrusion"
def step arr f = f (stepImpl2_Ann_2 arr)
//│ ((forall 'a 'r. ArraysRep['a, 'r] -> {fold: forall 'b. ('a -> 'b -> 'b) -> 'b -> ('r, anything,) -> 'b, init: 'a -> ('r, "hi",), sub: ('r, anything,) -> int -> 'a, update: ('r, anything,) -> int -> 'a -> ('r, "hey",)}) -> 'c) -> ('c -> 'd) -> 'd
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.267: 	def step arr f = f (stepImpl2_Ann_2 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.19: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.19: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.99: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
//│ ╙──      	                                                    ^^
//│     = [Function: step1]

:e
def step arr f = f (stepImpl2_Ann_3 arr)
//│ ((forall 'a 'b 'c 'd 'e 'f 'g 'h 'i. {fold: (nothing -> nothing -> anything) -> anything -> anything -> nothing, init: 'g -> 'd, sub: 'b -> 'e -> 'i, update: 'a -> 'c -> 'f -> 'h} -> {fold: Fold[nothing, (anything, string,)], init: 'g -> ('d, "hi",), sub: ('b, anything,) -> 'e -> 'i, update: ('a, anything,) -> 'c -> 'f -> ('h, "hey",)}) -> 'j) -> ('j -> 'k) -> 'k
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.286: 	def step arr f = f (stepImpl2_Ann_3 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `'a` does not match type `nothing`
//│ ║  l.237: 	def step: Arrays['a] -> Arrays['a]
//│ ║         	                 ^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.117: 	    fold   = (fun f -> fun b -> fun ((r0, r1)) -> arrImpl.fold f b r0) : Fold['a, ('rep, string)]
//│ ╙──       	                                                                              ^^
//│     = [Function: step2]

// * This used to be the only working one based on an internal annotation
:e // * Since "sound extrusion"
def step arr f = f (stepImpl2_Ann_4 arr)
//│ ((forall 'b 'c 'r 'd 'a 'e. {fold: ('a -> nothing -> anything) -> anything -> 'e -> nothing, init: ('c | 'b) -> ('e & 'd), sub: 'e -> int -> 'b, update: 'e -> int -> ('c | 'b) -> ('e & 'd)} -> ArraysRep['a, 'r]) -> 'f) -> ('f -> 'g) -> 'g
//│   where
//│     'r :> ('d, "hey" | "hi",)
//│        <: ('e, anything,)
//│     'a :> 'b
//│        <: 'c
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.303: 	def step arr f = f (stepImpl2_Ann_4 arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.15: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ║        	                 ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.15: 	    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ ╙──      	                 ^^
//│     = [Function: step3]

:e // * Since "sound extrusion"
def step arr f = f (stepImpl2_Ann_2_Ann arr)
//│ Arrays['a] -> ({fold: forall 'b. ('a0 -> 'b -> 'b) -> 'b -> (nothing, anything,) -> 'b, init: 'a0 -> (anything, "hi",), sub: (nothing, anything,) -> int -> 'a0, update: (nothing, anything,) -> int -> 'a0 -> (anything, "hey",)} -> 'c) -> 'c
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.324: 	def step arr f = f (stepImpl2_Ann_2_Ann arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.19: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.19: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.99: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
//│ ╙──      	                                                    ^^
//│     = [Function: step4]

:e // * Since "sound extrusion"
def step (arr: Arrays['a]) f = f (stepImpl2_Ann_2_Ann arr)
//│ Arrays['a] -> ({fold: forall 'b. ('a0 -> 'b -> 'b) -> 'b -> (nothing, anything,) -> 'b, init: 'a0 -> (anything, "hi",), sub: (nothing, anything,) -> int -> 'a0, update: (nothing, anything,) -> int -> 'a0 -> (anything, "hey",)} -> 'c) -> 'c
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.343: 	def step (arr: Arrays['a]) f = f (stepImpl2_Ann_2_Ann arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.19: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.19: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.99: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.sub r0 i;
//│ ╙──      	                                                    ^^
//│     = [Function: step5]

// * Also worked, but this one is easier as it internally uses the fully-annotated `stepImpl_ty`
:e // * Since "sound extrusion"
def step arr f = f (stepImpl2_ arr)
//│ ((forall 'a 'r. ArraysRep['a, 'r] -> ArraysRep['a, ('r, string,)]) -> 'b) -> ('b -> 'c) -> 'c
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.363: 	def step arr f = f (stepImpl2_ arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.19: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.19: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from type variable:
//│ ║  l.52: 	def stepImpl_ty: ArraysRep['a, 'r] -> ArraysRep['a, ('r, string)]
//│ ╙──      	                                                     ^^
//│     = [Function: step6]



ssb = step (step base)
//│ ssb: Arrays['a]
//│    = [Function (anonymous)]

ssb (fun arr ->
    let r2 = arr.update (arr.init true) 1 false
    in (arr.sub r2 0, arr.sub r2 1)
  )
//│ res: (bool, bool,)
//│    = [ false, false ]



rec def mkMonoArray n =
  if n == 0 then base else step (mkMonoArray(n - 1))
//│ mkMonoArray: int -> Arrays['a]
//│            = [Function: mkMonoArray]

snb = mkMonoArray 5
//│ snb: Arrays['a]
//│    = [Function (anonymous)]

snb (fun arr -> arr.init true)
//│ res: anything
//│    = [ [ [ [Array], 'hi' ], 'hi' ], 'hi' ]



