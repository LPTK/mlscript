:NoRecursiveTypes
:GeneralizeCurriedFunctions

// type bot = 0;;
type Bot = forall 'a. 'a
//│ Defined type alias Bot

// (* Rank 6 with intersection types, untypable in predicative System F,
//    typable in impredicative System F *)


// let imp (z : bot) =
//   (fun (x : ['a] ('a -> 'u) -> 'v) -> x x)
//   (fun (y : 'a -> bot) -> y z y);;
def imp (z: Bot) =
  (fun (x: forall 'a. ('a -> 'u) -> 'v) -> x x)
  (fun (y: 'a -> Bot) -> y z y)
def imp' z =
  (fun x -> x x)
  (fun y -> y z y)
//│ imp: Bot -> (forall 'a. 'a | 'b)
//│    = [Function: imp]
//│ imp': ('a -> ('b -> ((forall 'c, 'd, 'e. ('a -> ('c -> 'd & 'e) & 'c) -> 'd | 'f) -> ('g & 'h & 'i) & 'j & 'k) & 'l) & 'a & 'b) -> 'i
//│     = [Function: imp$]


// (* Quelques constantes. *)

// type sid = ['a] 'a -> 'a
type Sid = forall 'a. 'a -> 'a
//│ Defined type alias Sid

// let id = fun x -> x
// ;;
def id = fun x -> x
//│ id: 'a -> 'a
//│   = [Function: id]

// let delta = fun (x:sid) -> x x
// ;;
def delta = fun (x: Sid) -> x x
def delta' = fun x -> x x
//│ delta: Sid -> (Sid | 'a)
//│      = [Function: delta]
//│ delta': ('a -> 'b & 'a) -> 'b
//│       = [Function: delta$]

// delta id ;;
delta id
delta' id
//│ res: Sid | 'a
//│    = [Function: id]
//│ res: 'a -> 'a
//│    = [Function: id]

// let t a b c d e = (fun x -> a x x) ((fun y -> b (c y)) (d e)) ;;
def t a b c d e = (fun x -> a x x) ((fun y -> b (c y)) (d e))
//│ t: 'a -> (forall 'b. 'b -> (forall 'c. 'c -> (forall 'd. 'd -> (forall 'e, 'f, 'g, 'c, 'd, 'h, 'i, 'a, 'j, 'k, 'l, 'b, 'm, 'n. ('f -> 'k
//│   where
//│     'c <: 'l -> 'e
//│     'b <: 'e -> ('h & 'i & 'm)
//│     'd <: 'f -> ('l & 'j)
//│     'a <: 'h -> ('h -> ('g & 'k) & 'n))))))
//│  = [Function: t]

// let t w z a b = (fun y -> (fun x -> w (x y) z) a) b ;;
def t w z a b = (fun y -> (fun x -> w (x y) z) a) b
//│ t: 'a -> (forall 'b. 'b -> (forall 'c. 'c -> (forall 'c, 'd, 'a, 'e, 'f, 'g, 'h, 'i, 'b, 'j. (('f & 'e) -> 'j
//│   where
//│     'a <: 'h -> ('b -> ('i & 'd & 'j) & 'g)
//│     'c <: 'f -> 'h))))
//│  = [Function: t1]

// let t y a = (fun x -> x (x y)) ((fun z -> z) (fun x -> a x)) ;;
def t y a = (fun x -> x (x y)) ((fun z -> z) (fun x -> a x))
//│ t: 'a -> (forall 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i. (('a | 'h) -> ('c & 'b & 'g) & 'g -> ('f & 'e & 'd) & 'i) -> 'd)
//│  = [Function: t2]

// (* Rank 1 *)
// (fun x -> fun y -> x y) (fun y -> fun x -> x y) ;;
(fun x -> fun y -> x y) (fun y -> fun x -> x y)
//│ res: 'a -> 'b
//│   where
//│     forall 'c. 'c -> (forall 'd, 'e. ('c -> 'd & 'e) -> 'd) <: 'a -> 'b
//│    = [Function (anonymous)]

// (* Rank 3 *)
// (fun x -> fun y -> x) delta ;;
(fun x -> fun y -> x) delta
(fun x -> fun y -> x) delta'
//│ res: 'a -> (forall 'b. Sid -> (Sid | 'b))
//│    = [Function (anonymous)]
//│ res: 'a -> (forall 'b, 'c. ('b -> 'c & 'b) -> 'c)
//│    = [Function (anonymous)]

// (* Rank 5 *)
// (fun x -> fun y -> x y) (fun y -> fun x -> x y) delta ;;
(fun x -> fun y -> x y) (fun y -> fun x -> x y) delta
(fun x -> fun y -> x y) (fun y -> fun x -> x y) delta'
//│ res: ((forall 'a. Sid -> (Sid | 'a)) -> 'b & 'c) -> 'b
//│    = [Function (anonymous)]
//│ res: ((forall 'a, 'b. ('a -> 'b & 'a) -> 'b) -> 'c & 'd) -> 'c
//│    = [Function (anonymous)]

// (* Rank 8 *)
// (fun (x:sid) -> x x x x x) id delta ;;
(fun (x: Sid) -> x x x x x) id delta
(fun x -> x x x x x) id delta'
//│ res: Sid -> (Sid | 'a)
//│    = [Function: delta]
//│ res: ('a -> 'b & 'a) -> 'b
//│    = [Function: delta$]

// (* Rank 2 *)
// type sk = ['a,'b] 'a -> 'b -> 'a;;
// (fun (f:sk) -> fun x -> f f x) (fun v -> fun w -> v) ;;
type Sk = forall 'a 'b. 'a -> 'b -> 'a
(fun (f: Sk) -> fun x -> f f x) (fun v -> fun w -> v)
(fun f -> fun x -> f f x) (fun v -> fun w -> v)
//│ Defined type alias Sk
//│ res: ('a & 'b) -> (Sk | 'c)
//│    = [Function (anonymous)]
//│ res: 'a -> 'b
//│   where
//│     forall 'c. 'c -> (forall 'd. 'd -> 'c) <: (forall 'c. 'c -> (forall 'd. 'd -> 'c)) -> ('a -> 'b & 'e)
//│    = [Function (anonymous)]

// (* Rank 3 *)
// (fun t -> fun k -> t k) (fun (f:sk) -> fun x -> f f x) (fun v -> fun w -> v);;
(fun t -> fun k -> t k) (fun (f: Sk) -> fun x -> f f x) (fun v -> fun w -> v)
(fun t -> fun k -> t k) (fun f -> fun x -> f f x) (fun v -> fun w -> v)
//│ res: ('a & 'b) -> (Sk | 'c)
//│    = [Function (anonymous)]
//│ res: 'a -> 'b
//│   where
//│     forall 'c. 'c -> (forall 'd. 'd -> 'c) <: (forall 'c. 'c -> (forall 'd. 'd -> 'c)) -> ('a -> 'b & 'e)
//│    = [Function (anonymous)]


// let k = fun x y -> x
// let k' = fun x y -> y
// let app = fun f x -> f x
// let two = fun f x -> f (f x)
// let three = fun f x -> f (f (f x))
def k = fun x -> fun y -> x
def k2 = fun x -> fun y -> y
def app = fun f -> fun x -> f x
def two = fun f -> fun x -> f (f x)
def three = fun f -> fun x -> f (f (f x))
//│ k: 'a -> (forall 'b. 'b -> 'a)
//│  = [Function: k]
//│ k2: 'a -> (forall 'b. 'b -> 'b)
//│   = [Function: k2]
//│ app: 'a -> (forall 'a, 'b, 'c. ('b -> 'c
//│   where
//│     'a <: 'b -> 'c))
//│    = [Function: app]
//│ two: 'a -> (forall 'a, 'b, 'c, 'd. ('b -> 'd
//│   where
//│     'a <: 'b -> 'c & 'c -> 'd))
//│    = [Function: two]
//│ three: 'a -> (forall 'b, 'c, 'd, 'e, 'a. ('b -> 'e
//│   where
//│     'a <: 'b -> 'c & 'c -> 'd & 'd -> 'e))
//│      = [Function: three]


// * Tony noticed this did not work before this commit generalizing the LHS of ascriptions...
// :e // TODO this works when generalizing the LHS of ascriptions
(app id): Sid
//│ res: Sid
//│    = [Function (anonymous)]
// * this one worked:
let t = app id in t: Sid
//│ res: Sid
//│    = [Function (anonymous)]


// type Int = ['a] ('a -> 'a) -> ('a -> 'a)
// ;;
type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ Defined type alias ChurchInt

// (* Factorial of two and three *)
// (* Only ONE annotation ! *)
// let t y = (fun h -> h (h (h (fun x -> y)))) (fun f -> fun (n:Int) -> n (fun v -> k') k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k') (fun f -> fun x -> f (p k' f x))) (fun s -> s k' k') k) g) x)) two ;;

:e // FIXME?
def t y = (fun h -> h (h (h (fun x -> y)))) (fun f -> fun (n: ChurchInt) -> n (fun v -> k2) k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k2) (fun f -> fun x -> f (p k2 f x))) (fun s -> s k2 k2) k) g) x)) two
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.189: 	def t y = (fun h -> h (h (h (fun x -> y)))) (fun f -> fun (n: ChurchInt) -> n (fun v -> k2) k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k2) (fun f -> fun x -> f (p k2 f x))) (fun s -> s k2 k2) k) g) x)) two
//│ ║         	                                                                                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α964_1003^6  <:  ((‹∀ 0. ‹∀ 1. (α834_837'' -> ‹∀ 2. (α835_836''' -> α835_836''')›)››,) -> α966_1031^6)    TypeVariable  FunctionType
//│ ╙──  ... looks like:  α964_1003^6  <:  ((‹∀ 0. ‹∀ 1. (α834_837'' -> ‹∀ 2. (α835_836''' -> α835_836''')›)››,) -> α966_1004^8)
//│ t: 'b -> (forall 'c, 'd, 'e, 'f. ('e & 'f) -> (forall 'g, 'a, 'h, 'i, 'j, 'k, 'l, 'e, 'm, 'n. (('j & 'a & 'g & 'k) -> ('g | 'n)
//│   where
//│     'f <: 'j -> 'n
//│     ChurchInt -> (forall 'f, 'o, 'p. ('o & 'f) -> (forall 'q, 'r, 's, 'l, 'j, 't, 'u, 'o, 'a0, 'n, 'v. (('j & 'a0 & 't & 'v) -> ('t | 'n)
//│   where
//│     'f <: 'j -> 'n
//│     ChurchInt -> (forall 'w, 'f, 'x. ('x & 'f) -> (forall 'a1, 'b, 'y, 'x, 'l, 'j, 'z, 'f, 'a1, 'b1, 'c1, 'd1, 'n. (('a1 & 'b1 & 'a1 & 'j) -> ('b1 | 'n)
//│   where
//│     forall 'e1. 'e1 -> 'b | 'c1 <: (error | 'z | 'l) -> ('x -> ('a1 -> ('a1 & 'b1) & 'y) & 'd1)
//│     'f <: 'j -> 'n)) | 'w) | 'r <: (error | 'l | 'u) -> ('o -> ('a0 -> ('a0 & 't) & 's) & 'q))) | 'p) | 'i <: (error | 'l) -> ('e -> ('a -> ('a & 'g) & 'h) & 'm))) | 'c | 'd)
//│  = [Function: t3]

// :e // fails after new-refreshing-extrusion
// :e // Works since inconsistent constrained types...
def t2 y = (fun h -> h (h (h (fun x -> y)))) (fun f -> fun n -> n (fun v -> k2) k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k2) (fun f -> fun x -> f (p k2 f x))) (fun s -> s k2 k2) k) g) x)) two
//│ t2: 'a -> (forall 'b. 'b -> (forall 'c, 'd, 'e, 'b, 'f, 'g, 'h, 'i, 'j, 'k. ('e -> 'k
//│   where
//│     forall 'l, 'm. 'l -> (forall 'l, 'n, 'o, 'p. ('n -> 'p
//│   where
//│     'l <: 'n -> 'o & 'o -> 'p)) | 'm <: (forall 'q. 'q -> (forall 'r, 's, 't, 'q, 'u. (('t -> ((forall 'v. 'v -> (forall 'w, 'x, 'y, 'q, 'z, 'v, 'a1. ('w -> 'a1
//│   where
//│     'q <: (forall 'b1. 'b1 -> (forall 'c1. 'c1 -> 'c1)) -> ('v -> ('w -> 'x & 'y) & 'z)
//│     'v <: 'x -> 'a1))) -> 'r & 's) & 'u) -> 'r
//│   where
//│     'q <: (forall 'b1. 'b1 -> (forall 'c1. 'c1 -> 'c1)) -> 't))) -> ((forall 'd1, 'e1, 'f1. ((forall 'b1. 'b1 -> (forall 'c1. 'c1 -> 'c1)) -> ((forall 'b1. 'b1 -> (forall 'c1. 'c1 -> 'c1)) -> 'd1 & 'e1) & 'f1) -> 'd1) -> ((forall 'g1. 'g1 -> (forall 'h1. 'h1 -> 'g1)) -> 'h & 'i) & 'f) & 'c -> ('e -> 'k & 'j)
//│     forall 'i1, 'j1, 'k1, 'l1, 'm1. ((forall 'n1. 'n1 -> (forall 'b1. 'b1 -> (forall 'c1. 'c1 -> 'c1))) -> ((forall 'g1. 'g1 -> (forall 'h1. 'h1 -> 'g1)) -> ((forall 'o1. 'o1 -> (forall 'o1, 'p1, 'q1. ('p1 -> 'q1
//│   where
//│     'o1 <: 'p1 -> 'q1))) -> ((forall 'r1. 'r1 -> (forall 's1, 't1, 'u1, 'v1, 'w1, 'x1, 'y1, 'l1, 'r1, 'z1, 'a2. ('t1 -> 'z1
//│   where
//│     'l1 <: (forall 'q. 'q -> (forall 'r, 's, 't, 'q, 'u. (('t -> ((forall 'v. 'v -> (forall 'w, 'x, 'y, 'q, 'z, 'v, 'a1. ('w -> 'a1
//│   where
//│     'q <: (forall 'b1. 'b1 -> (forall 'c1. 'c1 -> 'c1)) -> ('v -> ('w -> 'x & 'y) & 'z)
//│     'v <: 'x -> 'a1))) -> 'r & 's) & 'u) -> 'r
//│   where
//│     'q <: (forall 'b1. 'b1 -> (forall 'c1. 'c1 -> 'c1)) -> 't))) -> ((forall 'd1, 'e1, 'f1. ((forall 'b1. 'b1 -> (forall 'c1. 'c1 -> 'c1)) -> ((forall 'b1. 'b1 -> (forall 'c1. 'c1 -> 'c1)) -> 'd1 & 'e1) & 'f1) -> 'd1) -> ((forall 'g1. 'g1 -> (forall 'h1. 'h1 -> 'g1)) -> 's1 & 'w1) & 'u1) & 'v1 -> ('t1 -> 'z1 & 'x1)
//│     forall 'b2, 'c2, 'd2, 'e2, 'f2. ((forall 'n1. 'n1 -> (forall 'b1. 'b1 -> (forall 'c1. 'c1 -> 'c1))) -> ((forall 'g1. 'g1 -> (forall 'h1. 'h1 -> 'g1)) -> ((forall 'o1. 'o1 -> (forall 'o1, 'p1, 'q1. ('p1 -> 'q1
//│   where
//│     'o1 <: 'p1 -> 'q1))) -> ((forall 'g2. 'g2 -> (forall 'h2, 'g2, 'i2, 'j2, 'k2, 'l2, 'm2, 'n2, 'o2, 'p2, 'f2, 'a. ('l2 -> 'j2
//│   where
//│     'f2 <: (forall 'q. 'q -> (forall 'r, 's, 't, 'q, 'u. (('t -> ((forall 'v. 'v -> (forall 'w, 'x, 'y, 'q, 'z, 'v, 'a1. ('w -> 'a1
//│   where
//│     'q <: (forall 'b1. 'b1 -> (forall 'c1. 'c1 -> 'c1)) -> ('v -> ('w -> 'x & 'y) & 'z)
//│     'v <: 'x -> 'a1))) -> 'r & 's) & 'u) -> 'r
//│   where
//│     'q <: (forall 'b1. 'b1 -> (forall 'c1. 'c1 -> 'c1)) -> 't))) -> ((forall 'd1, 'e1, 'f1. ((forall 'b1. 'b1 -> (forall 'c1. 'c1 -> 'c1)) -> ((forall 'b1. 'b1 -> (forall 'c1. 'c1 -> 'c1)) -> 'd1 & 'e1) & 'f1) -> 'd1) -> ((forall 'g1. 'g1 -> (forall 'h1. 'h1 -> 'g1)) -> 'm2 & 'o2) & 'n2) & 'k2 -> ('l2 -> 'j2 & 'h2)
//│     forall 'q2. 'q2 -> 'a | 'p2 <: 'm2 -> ('g2 -> 'k2 & 'i2)))) -> 'b2 & 'e2) & 'c2) & 'd2) & 'f2) -> 'b2 | 'y1 <: 's1 -> ('r1 -> 'v1 & 'a2)))) -> 'k1 & 'm1) & 'i1) & 'j1) & 'l1) -> 'k1 | 'g <: 'h -> ('b -> 'c & 'd))) | 'r2)
//│   = [Function: t21]

// :e // fails since the fix to spurious-TV-cycles // succeeds since the fix to the fix to spurious-TV-cycles...
t id succ 0
//│ res: int
//│    = 2

//:e // due to tapping
t2 id succ 0
//│ res: int
//│    = 2

// let t y = (fun h -> h (h (h (h (fun x -> y))))) (fun f -> fun (n:Int) -> n (fun v -> k') k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k') (fun f -> fun x -> f (p k' f x))) (fun s -> s k' k') k) g) x)) three

// :e // due to tapping
:e // fails since the fix to spurious-TV-cycles
def t y = (fun h -> h (h (h (fun x -> y)))) (fun f -> fun (n: ChurchInt) -> n (fun v -> k2) k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k2) (fun f -> fun x -> f (p k2 f x))) (fun s -> s k2 k2) k) g) x)) three
def t2 y = (fun h -> h (h (h (fun x -> y)))) (fun f -> fun n -> n (fun v -> k2) k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k2) (fun f -> fun x -> f (p k2 f x))) (fun s -> s k2 k2) k) g) x)) three
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.258: 	def t y = (fun h -> h (h (h (fun x -> y)))) (fun f -> fun (n: ChurchInt) -> n (fun v -> k2) k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k2) (fun f -> fun x -> f (p k2 f x))) (fun s -> s k2 k2) k) g) x)) three
//│ ║         	                                                                                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  α2346_2385^6  <:  ((‹∀ 0. ‹∀ 1. (α834_837'' -> ‹∀ 2. (α835_836''' -> α835_836''')›)››,) -> α2348_2413^6)    TypeVariable  FunctionType
//│ ╙──  ... looks like:  α2346_2385^6  <:  ((‹∀ 0. ‹∀ 1. (α834_837'' -> ‹∀ 2. (α835_836''' -> α835_836''')›)››,) -> α2348_2386^8)
//│ t: 'b -> (forall 'c, 'd, 'e, 'f. ('c & 'd) -> (forall 'g, 'h, 'i, 'a, 'j, 'k, 'l, 'm, 'n, 'c. (('l & 'a & 'h & 'i) -> ('h | 'j)
//│   where
//│     'd <: 'l -> 'j
//│     ChurchInt -> (forall 'd, 'o, 'p. ('o & 'd) -> (forall 'q, 'r, 's, 't, 'k, 'u, 'l, 'j, 'a0, 'o, 'v. (('l & 'a0 & 'u & 't) -> ('u | 'j)
//│   where
//│     'd <: 'l -> 'j
//│     ChurchInt -> (forall 'd, 'w, 'x. ('w & 'd) -> (forall 'w, 'y, 'z, 'a1, 'b1, 'k, 'b, 'l, 'a1, 'c1, 'd1, 'j, 'd. (('a1 & 'c1 & 'd1 & 'l) -> ('c1 | 'j)
//│   where
//│     'd <: 'l -> 'j
//│     forall 'e1. 'e1 -> 'b | 'b1 <: (error | 'z | 'k) -> ('w -> ('a1 -> ('a1 & 'c1) & 'a1) & 'y))) | 'x) | 'v <: (error | 'k | 'r) -> ('o -> ('a0 -> ('a0 & 'u) & 'q) & 's))) | 'p) | 'g <: (error | 'k) -> ('c -> ('a -> ('a & 'h) & 'm) & 'n))) | 'e | 'f)
//│  = [Function: t4]
//│ t2: 'a -> (forall 'b. 'b -> (forall 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'b, 'j, 'k. ('d -> 'e
//│   where
//│     forall 'l, 'm. 'l -> (forall 'n, 'o, 'l, 'p, 'q. ('p -> 'q
//│   where
//│     'l <: 'p -> 'o & 'o -> 'n & 'n -> 'q)) | 'm <: (forall 'r. 'r -> (forall 'r, 's, 't, 'u, 'v. (('v -> ((forall 'w. 'w -> (forall 'r, 'x, 'w, 'y, 'z, 'a1, 'b1. ('b1 -> 'z
//│   where
//│     'r <: (forall 'c1. 'c1 -> (forall 'd1. 'd1 -> 'd1)) -> ('w -> ('b1 -> 'x & 'y) & 'a1)
//│     'w <: 'x -> 'z))) -> 'u & 's) & 't) -> 'u
//│   where
//│     'r <: (forall 'c1. 'c1 -> (forall 'd1. 'd1 -> 'd1)) -> 'v))) -> ((forall 'e1, 'f1, 'g1. ((forall 'c1. 'c1 -> (forall 'd1. 'd1 -> 'd1)) -> ((forall 'c1. 'c1 -> (forall 'd1. 'd1 -> 'd1)) -> 'e1 & 'f1) & 'g1) -> 'e1) -> ((forall 'h1. 'h1 -> (forall 'i1. 'i1 -> 'h1)) -> 'h & 'i) & 'c) & 'f -> ('d -> 'e & 'k)
//│     forall 'j1, 'k1, 'l1, 'm1, 'n1. ((forall 'o1. 'o1 -> (forall 'c1. 'c1 -> (forall 'd1. 'd1 -> 'd1))) -> ((forall 'h1. 'h1 -> (forall 'i1. 'i1 -> 'h1)) -> ((forall 'p1. 'p1 -> (forall 'p1, 'q1, 'r1. ('q1 -> 'r1
//│   where
//│     'p1 <: 'q1 -> 'r1))) -> ((forall 's1. 's1 -> (forall 't1, 'u1, 'v1, 'w1, 's1, 'x1, 'y1, 'z1, 'a2, 'b2, 'm1. ('y1 -> 'b2
//│   where
//│     'm1 <: (forall 'r. 'r -> (forall 'r, 's, 't, 'u, 'v. (('v -> ((forall 'w. 'w -> (forall 'r, 'x, 'w, 'y, 'z, 'a1, 'b1. ('b1 -> 'z
//│   where
//│     'r <: (forall 'c1. 'c1 -> (forall 'd1. 'd1 -> 'd1)) -> ('w -> ('b1 -> 'x & 'y) & 'a1)
//│     'w <: 'x -> 'z))) -> 'u & 's) & 't) -> 'u
//│   where
//│     'r <: (forall 'c1. 'c1 -> (forall 'd1. 'd1 -> 'd1)) -> 'v))) -> ((forall 'e1, 'f1, 'g1. ((forall 'c1. 'c1 -> (forall 'd1. 'd1 -> 'd1)) -> ((forall 'c1. 'c1 -> (forall 'd1. 'd1 -> 'd1)) -> 'e1 & 'f1) & 'g1) -> 'e1) -> ((forall 'h1. 'h1 -> (forall 'i1. 'i1 -> 'h1)) -> 'x1 & 'u1) & 'v1) & 'w1 -> ('y1 -> 'b2 & 't1)
//│     forall 'c2, 'd2, 'e2, 'f2, 'g2. ((forall 'o1. 'o1 -> (forall 'c1. 'c1 -> (forall 'd1. 'd1 -> 'd1))) -> ((forall 'h1. 'h1 -> (forall 'i1. 'i1 -> 'h1)) -> ((forall 'p1. 'p1 -> (forall 'p1, 'q1, 'r1. ('q1 -> 'r1
//│   where
//│     'p1 <: 'q1 -> 'r1))) -> ((forall 'h2. 'h2 -> (forall 'i2, 'a, 'h2, 'j2, 'k2, 'l2, 'm2, 'n2, 'o2, 'p2, 'q2, 'f2. ('q2 -> 'm2
//│   where
//│     'f2 <: (forall 'r. 'r -> (forall 'r, 's, 't, 'u, 'v. (('v -> ((forall 'w. 'w -> (forall 'r, 'x, 'w, 'y, 'z, 'a1, 'b1. ('b1 -> 'z
//│   where
//│     'r <: (forall 'c1. 'c1 -> (forall 'd1. 'd1 -> 'd1)) -> ('w -> ('b1 -> 'x & 'y) & 'a1)
//│     'w <: 'x -> 'z))) -> 'u & 's) & 't) -> 'u
//│   where
//│     'r <: (forall 'c1. 'c1 -> (forall 'd1. 'd1 -> 'd1)) -> 'v))) -> ((forall 'e1, 'f1, 'g1. ((forall 'c1. 'c1 -> (forall 'd1. 'd1 -> 'd1)) -> ((forall 'c1. 'c1 -> (forall 'd1. 'd1 -> 'd1)) -> 'e1 & 'f1) & 'g1) -> 'e1) -> ((forall 'h1. 'h1 -> (forall 'i1. 'i1 -> 'h1)) -> 'i2 & 'o2) & 'k2) & 'p2 -> ('q2 -> 'm2 & 'l2)
//│     forall 'r2. 'r2 -> 'a | 'n2 <: 'i2 -> ('h2 -> 'p2 & 'j2)))) -> 'e2 & 'd2) & 'c2) & 'g2) & 'f2) -> 'e2 | 'a2 <: 'x1 -> ('s1 -> 'w1 & 'z1)))) -> 'l1 & 'k1) & 'j1) & 'n1) & 'm1) -> 'l1 | 'j <: 'h -> ('b -> 'f & 'g))) | 's2)
//│   = [Function: t22]

// (* This comment is from the ORIGINAL PAGE: *)
// (* Factorial of three. Exposed bugs in old implementation. This one works correctly, but the generated files take up to 3.8GB, and it takes about 1 hour on a 2GHz PIII box to get the result. You can see the final judgement here. Yes, the result is the Church numeral for 6. *)

// (* We test that the result is 6: *)
// let succ n = n + 1 ;;
// t id succ 0 ;;

// :e // fails since the fix to spurious-TV-cycles // succeeds since the fix to the fix to spurious-TV-cycles...
t id succ 0
//│ res: int
//│    = 6

// :e // TODO try without cycle check // works with quantif extrus
// :e // FIXME? refreshing-extr
:e // Fails since inconsistent constrained types
t2 id succ 0
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.325: 	t2 id succ 0
//│ ║         	^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  int<number>  <:  α835_4136    ClassTag  TypeVariable
//│ ╙──  ... looks like:  int<number>  <:  α835_836'''
//│ res: error
//│    = 6

// let t (z : 0) = let x = (fun (y: ['t > 0] 'a -> 't) -> y z y) in x x;;
def t (z: nothing) = let x = fun (y: forall 't. 'a -> 't) -> y z y in x x
//│ t: nothing -> (forall 'a. 'a | 'b)
//│  = [Function: t5]

// (* Plus petit. *)
// type tt = ['b = 0] ['c > ['a] ['d = ['t] 'a -> 't] ['e] 'd -> 'e] 'b -> 'c ;;
// let t (z : 0) = let x = (fun (y: ['t > 0] 'a -> 't) -> y z) in x x;;
type Tt = forall 'b 'c. ('b & nothing) -> ('c | (forall 'a 'd 'e. ('d & (forall 't. 'a -> 't))) -> 'e)
def t (z: nothing) = let x = fun (y: forall 't. 'a -> 't) -> y z in x x
//│ Defined type alias Tt
//│ t: nothing -> (forall 't, 'a. 't | 'a | 'b)
//│  = [Function: t6]

// (*
//     * Rank 3, untypable in System F?
//       (fun x -> z (x (fun f -> fun u -> f u)) (x (fun v -> fun g -> g v))) (fun y -> y y y)
// FIXME: z is free???

//     * Untypable at any rank
//       (fun x -> x x) (fun x -> x x)
// :e // TODO show failure without cycle check // works with quantif extrus
:re
:e // FIXME? refreshing-extr
(fun x -> x x) (fun x -> x x)
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.359: 	(fun x -> x x) (fun x -> x x)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α4282_4284' -> α4283_4285')›  <:  α4282_4291    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α4282_4284' -> α4283_4285')›  <:  α4282_4284'
//│ res: error
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

//     * Rank 3, untypable in F2 but F3
//       (fun f x -> f (f x)) (fun f x -> f (f x)) (fun v w -> v)
(fun f -> fun x -> f (f x)) (fun f -> fun x -> f (f x)) (fun v -> fun w -> v)
//│ res: 'a -> 'b
//│   where
//│     forall 'c, 'd, 'e. ('c -> 'e
//│   where
//│     forall 'f. 'f -> (forall 'g. 'g -> 'f) <: 'c -> 'd & 'd -> 'e) <: 'a -> 'h & 'h -> 'b
//│    = [Function (anonymous)]

//     * Rank 4, alternate formulation, untypeable in F2, but F3
//       (fun two k -> two two k)(fun f x -> f (f x)) (fun v w -> v)
// :e // fails after new-refreshing-extrusion // Works since inconsistent constrained types...
(fun two -> fun k -> two two k) (fun f -> fun x -> f (f x)) (fun v -> fun w -> v)
//│ res: 'a -> 'b
//│   where
//│     forall 'c, 'd, 'e. ('c -> 'e
//│   where
//│     forall 'f. 'f -> (forall 'g. 'g -> 'f) <: 'c -> 'd & 'd -> 'e) <: 'a -> 'h & 'h -> 'b
//│    = [Function (anonymous)]

//     * Rank 5, causes huge blowup. Do not attempt to output skeletons !
//       (fun two k -> two two two k)(fun f -x -> f (f x)) (fun v w -> v)
// * Note: the only example in this file that requires `:GeneralizeCurriedFunctions`
// :e // due to not stashing...?
// :e // FIXedME? refreshing-extr // Works since inconsistent constrained types...
(fun two -> fun k -> two two two k) (fun f -> fun x -> f (f x)) (fun v -> fun w -> v)
//│ res: 'a -> 'b
//│   where
//│     forall 'c, 'd, 'e. ('c -> 'e
//│   where
//│     forall 'f, 'g, 'h. ('f -> 'h
//│   where
//│     forall 'i, 'j, 'k. ('k -> 'j
//│   where
//│     forall 'l. 'l -> (forall 'm. 'm -> 'l) <: 'k -> 'i & 'i -> 'j) <: 'f -> 'g & 'g -> 'h) <: 'c -> 'd & 'd -> 'e) <: 'a -> 'n & 'n -> 'b
//│    = [Function (anonymous)]



//  ?????
//     * Factorial of two, using the Y combinator
//       (fun h -> (fun x -> h (x x)) (fun x -> h (x x))) (fun f -> fun n -> n (fun v -> fun x -> fun y -> y) k (fun f -> fun x -> f x)(fun g -> fun x -> n (f (n (fun p -> fun s -> s (p (fun x -> fun y -> y)) (fun f -> fun x -> f (p (fun x -> fun y -> y) f x))) (fun s -> s (fun f -> fun x -> x) (fun f -> fun x -> x)) k) g) x)) (fun f -> fun x -> f (f x))

// *)
// :e // works with quantif extrus
:e // FIXME? refreshing-extr
:re
(fun h -> (fun x -> h (x x)) (fun x -> h (x x))) (fun f -> fun n -> n (fun v -> fun x -> fun y -> y) k (fun f -> fun x -> f x)(fun g -> fun x -> n (f (n (fun p -> fun s -> s (p (fun x -> fun y -> y)) (fun f -> fun x -> f (p (fun x -> fun y -> y) f x))) (fun s -> s (fun f -> fun x -> x) (fun f -> fun x -> x)) k) g) x)) (fun f -> fun x -> f (f x))
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.418: 	(fun h -> (fun x -> h (x x)) (fun x -> h (x x))) (fun f -> fun n -> n (fun v -> fun x -> fun y -> y) k (fun f -> fun x -> f x)(fun g -> fun x -> n (f (n (fun p -> fun s -> s (p (fun x -> fun y -> y)) (fun f -> fun x -> f (p (fun x -> fun y -> y) f x))) (fun s -> s (fun f -> fun x -> x) (fun f -> fun x -> x)) k) g) x)) (fun f -> fun x -> f (f x))
//│ ║         	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 1. {(α4578_4583'' -> α4580_4582'') where: α4571' :> ((α4579_4581'',) -> α4580_4582'')}›  <:  α4578_4593'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 1. {(α4578_4583'' -> α4580_4582'') where: α4571' :> ((α4579_4581'',) -> α4580_4582'')}›  <:  α4578_4583''
//│ res: error
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded


