:NoRecursiveTypes

// * In these tests, argument generalization is sometimes needed; I have annotated where.
:GeneralizeArguments


// type bot = 0;;
type Bot = forall 'a. 'a
//│ Defined type alias Bot

// (* Rank 6 with intersection types, untypable in predicative System F,
//    typable in impredicative System F *)


// let imp (z : bot) =
//   (fun (x : ['a] ('a -> 'u) -> 'v) -> x x)
//   (fun (y : 'a -> bot) -> y z y);;
def imp (z: Bot) =
  (fun (x: forall 'a. ('a -> 'u) -> 'v) -> x x)
  (fun (y: 'a -> Bot) -> y z y)
//│ imp: Bot -> nothing
//│    = [Function: imp]

def imp' z =
  (fun x -> x x)
  (fun y -> y z y)
//│ imp': ('a -> 'a -> (forall 'b 'c. ('a -> 'b -> 'c & 'b) -> 'c) -> 'd & 'a) -> 'd
//│     = [Function: imp$]


// (* Quelques constantes. *)

// type sid = ['a] 'a -> 'a
type Sid = forall 'a. 'a -> 'a
//│ Defined type alias Sid

// let id = fun x -> x
// ;;
def id = fun x -> x
//│ id: 'a -> 'a
//│   = [Function: id]

// let delta = fun (x:sid) -> x x
// ;;
def delta = fun (x: Sid) -> x x
def delta' = fun x -> x x
//│ delta: Sid -> Sid
//│      = [Function: delta]
//│ delta': ('a -> 'b & 'a) -> 'b
//│       = [Function: delta$]

// delta id ;;
delta id
delta' id
//│ res: Sid
//│    = [Function: id]
//│ res: 'a -> 'a
//│    = [Function: id]

// let t a b c d e = (fun x -> a x x) ((fun y -> b (c y)) (d e)) ;;
def t a b c d e = (fun x -> a x x) ((fun y -> b (c y)) (d e))
//│ t: ('a -> 'a -> 'b) -> ('c -> 'a) -> ('d -> 'c) -> ('e -> 'd) -> 'e -> 'b
//│  = [Function: t]

// let t w z a b = (fun y -> (fun x -> w (x y) z) a) b ;;
def t w z a b = (fun y -> (fun x -> w (x y) z) a) b
//│ t: ('a -> 'b -> 'c) -> 'b -> ('d -> 'a) -> 'd -> 'c
//│  = [Function: t1]

// let t y a = (fun x -> x (x y)) ((fun z -> z) (fun x -> a x)) ;;
def t y a = (fun x -> x (x y)) ((fun z -> z) (fun x -> a x))
//│ t: 'a -> (('b | 'a) -> 'b) -> 'b
//│  = [Function: t2]

// (* Rank 1 *)
// (fun x -> fun y -> x y) (fun y -> fun x -> x y) ;;
// * Note that the `forall` is not distributed out because there's no enclosing polymorphic type here!
(fun x -> fun y -> x y) (fun y -> fun x -> x y)
//│ res: 'a -> (forall 'b. ('a -> 'b) -> 'b)
//│    = [Function (anonymous)]

// (* Rank 3 *)
// (fun x -> fun y -> x) delta ;;
(fun x -> fun y -> x) delta
(fun x -> fun y -> x) delta'
//│ res: anything -> Sid -> Sid
//│    = [Function (anonymous)]
//│ res: anything -> (forall 'a 'b. ('a -> 'b & 'a) -> 'b)
//│    = [Function (anonymous)]

// (* Rank 5 *)
// (fun x -> fun y -> x y) (fun y -> fun x -> x y) delta ;;
(fun x -> fun y -> x y) (fun y -> fun x -> x y) delta
(fun x -> fun y -> x y) (fun y -> fun x -> x y) delta'
//│ res: ((Sid -> Sid) -> 'a) -> 'a
//│    = [Function (anonymous)]
//│ res: ((forall 'a 'b. ('a -> 'b & 'a) -> 'b) -> 'c) -> 'c
//│    = [Function (anonymous)]

// (* Rank 8 *)
// (fun (x:sid) -> x x x x x) id delta ;;
(fun (x: Sid) -> x x x x x) id delta
(fun x -> x x x x x) id delta'
//│ res: Sid -> Sid
//│    = [Function: delta]
//│ res: ('a -> 'b & 'a) -> 'b
//│    = [Function: delta$]

// (* Rank 2 *)
// type sk = ['a,'b] 'a -> 'b -> 'a;;
// (fun (f:sk) -> fun x -> f f x) (fun v -> fun w -> v) ;;
type Sk = forall 'a 'b. 'a -> 'b -> 'a
(fun (f: Sk) -> fun x -> f f x) (fun v -> fun w -> v)
(fun f -> fun x -> f f x) (fun v -> fun w -> v)
//│ Defined type alias Sk
//│ res: anything -> Sk
//│    = [Function (anonymous)]
//│ res: anything -> (forall 'a. 'a -> anything -> 'a)
//│    = [Function (anonymous)]

// (* Rank 3 *)
// (fun t -> fun k -> t k) (fun (f:sk) -> fun x -> f f x) (fun v -> fun w -> v);;
(fun t -> fun k -> t k) (fun (f: Sk) -> fun x -> f f x) (fun v -> fun w -> v)
(fun t -> fun k -> t k) (fun f -> fun x -> f f x) (fun v -> fun w -> v)
//│ res: anything -> Sk
//│    = [Function (anonymous)]
//│ res: anything -> (forall 'a. 'a -> anything -> 'a)
//│    = [Function (anonymous)]


// let k = fun x y -> x
// let k' = fun x y -> y
// let app = fun f x -> f x
// let two = fun f x -> f (f x)
// let three = fun f x -> f (f (f x))
def k = fun x -> fun y -> x
def k2 = fun x -> fun y -> y
def app = fun f -> fun x -> f x
def two = fun f -> fun x -> f (f x)
def three = fun f -> fun x -> f (f (f x))
//│ k: 'a -> anything -> 'a
//│  = [Function: k]
//│ k2: anything -> 'a -> 'a
//│   = [Function: k2]
//│ app: ('a -> 'b) -> 'a -> 'b
//│    = [Function: app]
//│ two: ('a -> 'b & 'b -> 'c) -> 'a -> 'c
//│    = [Function: two]
//│ three: ('a -> 'b & 'b -> 'c & 'c -> 'd) -> 'a -> 'd
//│      = [Function: three]


:e // * Note: this test case of ours works when generalizing the LHS of ascriptions
(app id): Sid
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.154: 	(app id): Sid
//│ ║         	^^^^^^^^
//│ ╟── type variable `'a` leaks out of its scope
//│ ║  l.34: 	type Sid = forall 'a. 'a -> 'a
//│ ║        	                      ^^
//│ ╟── back into type variable `'a`
//│ ║  l.34: 	type Sid = forall 'a. 'a -> 'a
//│ ║        	                            ^^
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this application:
//│ ║  l.138: 	def app = fun f -> fun x -> f x
//│ ╙──       	                            ^^^
//│ res: Sid
//│    = [Function (anonymous)]
// * this one works:
let t = app id in t: Sid
//│ res: Sid
//│    = [Function (anonymous)]


// type Int = ['a] ('a -> 'a) -> ('a -> 'a)
// ;;
type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ Defined type alias ChurchInt


// (* Factorial of two and three *)
// (* Only ONE annotation ! *)
// let t y = (fun h -> h (h (h (fun x -> y)))) (fun f -> fun (n:Int) -> n (fun v -> k') k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k') (fun f -> fun x -> f (p k' f x))) (fun s -> s k' k') k) g) x)) two ;;

// * [FCP-LIM] requires :GeneralizeArguments
def t y = (fun h -> h (h (h (fun x -> y)))) (fun f -> fun (n: ChurchInt) -> n (fun v -> k2) k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k2) (fun f -> fun x -> f (p k2 f x))) (fun s -> s k2 k2) k) g) x)) two
//│ t: ('b -> 'a -> 'a) -> ('c -> 'd & 'a -> 'a & 'b) -> ('a & 'c) -> ('a | 'd)
//│  = [Function: t3]

t id succ 0
//│ res: int
//│    = 2

// * Same as above but WITHOUT the type annotation (unlike MLF)
:e
def t_ y = (fun h -> h (h (h (fun x -> y)))) (fun f -> fun n -> n (fun v -> k2) k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k2) (fun f -> fun x -> f (p k2 f x))) (fun s -> s k2 k2) k) g) x)) two
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a <: ? -> 'b -> 'c
//│     'b :> forall 'd 'e. ((forall 'f. ? -> 'f -> 'f) -> (forall 'g. ? -> 'g -> 'g) -> 'e & 'd) -> (? -> 'd | 'e) | 'h
//│     'h :> forall 'i. 'i -> 'i | 'b
//│        <: (forall 'i. ? -> 'i -> 'i) -> ((? -> (forall 'j. ? -> 'j -> 'j)) -> (forall 'd. 'd -> ? -> 'd) -> (forall 'k 'l. ('k -> 'l) -> 'k -> 'l) -> (? -> 'm -> 'n) -> 'a & (forall 'o 'p 'q 'r 's. ((forall 'i. ? -> 'i -> 'i) -> 's & (forall 't. ? -> 't -> 't) -> 'p -> 'o -> 'r) -> ('s -> (forall 'u. ('r -> 'u & 'p) -> 'o -> 'u) -> 'q) -> 'q) -> (forall 'e. ((forall 'f. ? -> 'f -> 'f) -> (forall 'g. ? -> 'g -> 'g) -> 'e) -> 'e) -> (forall 'v. 'v -> ? -> 'v) -> ? & ? -> 'm -> 'n) & (forall 't. ? -> 't -> 't) -> ? -> ? -> ?
//│     'm :> 'b
//│        <: 'n
//│     'n :> forall 'i. 'i -> 'i | 'b
//│        <: 'c
//│     'c <: ? & 'h
//│ ║  l.197: 	def t_ y = (fun h -> h (h (h (fun x -> y)))) (fun f -> fun n -> n (fun v -> k2) k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k2) (fun f -> fun x -> f (p k2 f x))) (fun s -> s k2 k2) k) g) x)) two
//│ ╙──       	                                                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Subtyping constraint of the form `?a <: (forall ?b ?c ?d ?e. ?e -> ?d -> ?c) -> ?f` exceeded recursion depth limit (250)
//│ ║  l.197: 	def t_ y = (fun h -> h (h (h (fun x -> y)))) (fun f -> fun n -> n (fun v -> k2) k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k2) (fun f -> fun x -> f (p k2 f x))) (fun s -> s k2 k2) k) g) x)) two
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ t_: (nothing -> anything) -> error
//│   = [Function: t_]

t_ id succ 0
//│ res: error
//│    = 2

// * Works with CT:
:ConstrainedTypes
def t_ y = (fun h -> h (h (h (fun x -> y)))) (fun f -> fun n -> n (fun v -> k2) k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k2) (fun f -> fun x -> f (p k2 f x))) (fun s -> s k2 k2) k) g) x)) two
//│ t_: 'a -> 'b -> ('c -> 'd
//│   where
//│     forall 'e 'f 'g. ('e -> 'f & 'f -> 'g) -> 'e -> 'g <: (forall 'h. ('h
//│   where
//│     forall 'i. ('i
//│   where
//│     forall 'j 'k 'l. 'l -> ((forall 'm. anything -> anything -> 'm -> 'm) -> (forall 'n. 'n -> anything -> 'n) -> (forall 'o 'p. ('o -> 'p) -> 'o -> 'p) -> (forall 'q 'r 's. 'q -> ('r -> 's
//│   where
//│     'j <: (forall 't. ('t
//│   where
//│     'l <: (forall 'u. ('u
//│   where
//│     'j <: (forall 'v 'w. 'v -> ((forall 'x. ('x
//│   where
//│     'v <: (forall 'y. anything -> 'y -> 'y) -> 'x)) -> (forall 'z 'a1 'b1. 'z -> ('a1 -> 'b1
//│   where
//│     'z <: (forall 'c1. ('c1
//│   where
//│     'v <: (forall 'd1. anything -> 'd1 -> 'd1) -> 'z -> 'a1 -> 'c1)) -> 'b1)) -> 'w) -> 'w) -> (forall 'e1. ((forall 'f1. anything -> 'f1 -> 'f1) -> (forall 'g1. anything -> 'g1 -> 'g1) -> 'e1) -> 'e1) -> (forall 'h1. 'h1 -> anything -> 'h1) -> 'u)) -> 'q -> 't)) -> 'r -> 's)) -> 'k & 'j) -> 'k <: (forall 'i1. ('i1
//│   where
//│     forall 'j 'k 'l. 'l -> ((forall 'm. anything -> anything -> 'm -> 'm) -> (forall 'n. 'n -> anything -> 'n) -> (forall 'o 'p. ('o -> 'p) -> 'o -> 'p) -> (forall 'q 'r 's. 'q -> ('r -> 's
//│   where
//│     'j <: (forall 't. ('t
//│   where
//│     'l <: (forall 'u. ('u
//│   where
//│     'j <: (forall 'v 'w. 'v -> ((forall 'x. ('x
//│   where
//│     'v <: (forall 'y. anything -> 'y -> 'y) -> 'x)) -> (forall 'z 'a1 'b1. 'z -> ('a1 -> 'b1
//│   where
//│     'z <: (forall 'c1. ('c1
//│   where
//│     'v <: (forall 'd1. anything -> 'd1 -> 'd1) -> 'z -> 'a1 -> 'c1)) -> 'b1)) -> 'w) -> 'w) -> (forall 'e1. ((forall 'f1. anything -> 'f1 -> 'f1) -> (forall 'g1. anything -> 'g1 -> 'g1) -> 'e1) -> 'e1) -> (forall 'h1. 'h1 -> anything -> 'h1) -> 'u)) -> 'q -> 't)) -> 'r -> 's)) -> 'k & 'j) -> 'k <: (anything -> 'a) -> 'i1)) -> 'i) <: (forall 'j1. ('j1
//│   where
//│     forall 'e 'f 'g. ('e -> 'f & 'f -> 'g) -> 'e -> 'g <: (forall 'v 'k1. 'v -> ((forall 'x. ('x
//│   where
//│     'v <: (forall 'y. anything -> 'y -> 'y) -> 'x)) -> (forall 'z 'a1 'b1. 'z -> ('a1 -> 'b1
//│   where
//│     'z <: (forall 'c1. ('c1
//│   where
//│     'v <: (forall 'd1. anything -> 'd1 -> 'd1) -> 'z -> 'a1 -> 'c1)) -> 'b1)) -> 'k1) -> 'k1) -> (forall 'e1. ((forall 'f1. anything -> 'f1 -> 'f1) -> (forall 'g1. anything -> 'g1 -> 'g1) -> 'e1) -> 'e1) -> (forall 'l1. 'l1 -> anything -> 'l1) -> 'j1)) -> 'b -> 'h)) -> 'c -> 'd)
//│   = [Function: t_1]
:NoConstrainedTypes

t_ id succ 0
//│ res: int
//│    = 2


// let t y = (fun h -> h (h (h (h (fun x -> y))))) (fun f -> fun (n:Int) -> n (fun v -> k') k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k') (fun f -> fun x -> f (p k' f x))) (fun s -> s k' k') k) g) x)) three

// * [FCP-LIM] requires :GeneralizeArguments
def t y = (fun h -> h (h (h (fun x -> y)))) (fun f -> fun (n: ChurchInt) -> n (fun v -> k2) k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k2) (fun f -> fun x -> f (p k2 f x))) (fun s -> s k2 k2) k) g) x)) three
//│ t: ('b -> 'a -> 'a) -> ('c -> 'd & 'a -> 'a & 'b) -> ('a & 'c) -> ('a | 'd)
//│  = [Function: t4]

// * Same as above but WITHOUT the type annotation (unlike MLF)
// * Interestingly this one does NOT require CT
:Fuel 6000
:e // occurs-check
def t_ y = (fun h -> h (h (h (fun x -> y)))) (fun f -> fun n -> n (fun v -> k2) k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k2) (fun f -> fun x -> f (p k2 f x))) (fun s -> s k2 k2) k) g) x)) three
//│ ╔══[ERROR] Inferred recursive type: ? -> (((forall 'a. nothing -> ('a -> 'a | ?)) | 'b) -> nothing & (forall 'c 'd. ((forall 'e. ? -> 'e -> 'e) -> (forall 'f. ? -> 'f -> 'f) -> 'c & 'd) -> (? -> 'd | 'c) | ?) -> ((forall 'g. ? -> 'g -> 'g) -> ? -> ? -> ? & (forall 'h. ? -> 'h -> 'h) -> nothing & 'b))
//│ ║  l.285: 	def t_ y = (fun h -> h (h (h (fun x -> y)))) (fun f -> fun n -> n (fun v -> k2) k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k2) (fun f -> fun x -> f (p k2 f x))) (fun s -> s k2 k2) k) g) x)) three
//│ ╙──       	                                                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ t_: ('a -> ('b -> 'c & 'd & 'e)) -> ('a & 'f) -> ((forall 'g. anything -> 'g -> 'g) -> (forall 'h 'i 'j 'k 'l 'm. ((forall 'n. anything -> 'n -> 'n) -> 'm & (forall 'o. anything -> 'o -> 'o) -> 'k -> 'j -> 'i) -> ('m -> (forall 'p. ('i -> 'p & 'k) -> 'j -> 'p) -> 'l) -> ('h -> 'h | 'l) | 'q | 'd) -> (forall 'r 's. ((forall 't. anything -> 't -> 't) -> (forall 'u. anything -> 'u -> 'u) -> 'r & (forall 'v. anything -> 'v -> 'v) -> (forall 'w. anything -> 'w -> 'w) -> 'r & 's) -> (anything -> 's | 'r) | 'x | 'y | 'z | 'a1) -> 'b & (forall 'b1. anything -> 'b1 -> 'b1) -> 'c1 & (forall 'd1. anything -> 'd1 -> 'd1) -> anything & (forall 'e1. anything -> 'e1 -> 'e1) -> nothing -> nothing -> anything & 'z) -> 'a1
//│   where
//│     'b :> forall 'f1 'g1. ((forall 'h1. anything -> 'h1 -> 'h1) -> (forall 'i1. anything -> 'i1 -> 'i1) -> 'g1 & (forall 'v. anything -> 'v -> 'v) -> (forall 'w. anything -> 'w -> 'w) -> 'g1 & 'g1 & 'f1) -> (anything -> 'f1 | 'g1) | 'y | 'z | 'a1
//│        <: (forall 'j1. anything -> 'j1 -> 'j1) -> nothing -> nothing -> anything & (forall 'k1. anything -> 'k1 -> 'k1) -> anything
//│     'y :> forall 'l1 'm1. ((forall 'n1 'o1. anything -> 'n1 -> ('o1 -> 'o1 | 'n1) | 'c1) -> (forall 'p1. ('b -> 'p1 & 'q) -> ('b & 'x) -> 'p1) -> 'l1) -> ('m1 -> 'm1 | 'l1)
//│        <: (forall 'q1. anything -> 'q1 -> 'q1) -> nothing -> nothing -> anything & (forall 'r1. anything -> 'r1 -> 'r1) -> ((forall 's1. anything -> anything -> 's1 -> 's1) -> (forall 't1. 't1 -> anything -> 't1) -> (forall 'u1 'v1. ('v1 -> 'u1) -> 'v1 -> 'u1) -> ('a -> ('b & 'x & 'w1) -> 'c) -> 'f -> ('y -> ((forall 'x1. anything -> 'x1 -> 'x1) -> nothing -> nothing -> anything & (forall 'y1. anything -> 'y1 -> 'y1) -> anything & (forall 'z1. anything -> 'z1 -> 'z1) -> 'c1 & (forall 'a2. anything -> 'a2 -> 'a2) -> (forall 'b2 'c2 'd2 'e2 'f2 'g2. ((forall 'n. anything -> 'n -> 'n) -> 'd2 & (forall 'o. anything -> 'o -> 'o) -> 'b2 -> 'f2 -> 'g2) -> ('d2 -> (forall 'h2. ('g2 -> 'h2 & 'b2) -> 'f2 -> 'h2) -> 'c2) -> ('e2 -> 'e2 | 'c2) | 'q | 'd) -> (forall 'i2 'j2. ((forall 't. anything -> 't -> 't) -> (forall 'u. anything -> 'u -> 'u) -> 'j2 & (forall 'v. anything -> 'v -> 'v) -> (forall 'w. anything -> 'w -> 'w) -> 'j2 & 'i2) -> (anything -> 'i2 | 'j2) | 'x | 'y | 'z | 'a1) -> 'b & 'a1) & (forall 'k2 'l2. ((forall 'v. anything -> 'v -> 'v) -> (forall 'w. anything -> 'w -> 'w) -> 'k2 & 'l2) -> (anything -> 'l2 | 'k2) | 'z | 'a1) -> 'y) & (forall 'm2 'n2 'o2 'p2 'q2. ((forall 'r2. anything -> 'r2 -> 'r2) -> 'm2 & (forall 's2. anything -> 's2 -> 's2) -> 'q2 -> 'p2 -> 'n2) -> ('m2 -> (forall 't2. ('n2 -> 't2 & 'q2) -> 'p2 -> 't2) -> 'o2) -> 'o2) -> (forall 'u2. ((forall 'v2. anything -> 'v2 -> 'v2) -> (forall 'w2. anything -> 'w2 -> 'w2) -> 'u2) -> 'u2) -> (forall 'x2. 'x2 -> anything -> 'x2) -> anything & 'd -> 'e) & (forall 'y2. anything -> 'y2 -> 'y2) -> anything
//│     'e <: (forall 'z2 'a3. ((forall 'v. anything -> 'v -> 'v) -> (forall 'w. anything -> 'w -> 'w) -> 'z2 & 'a3) -> (anything -> 'a3 | 'z2) | 'w1 | 'y | 'z | 'a1) -> 'c
//│     'c <: (forall 'x1. anything -> 'x1 -> 'x1) -> nothing -> nothing -> anything & (forall 'y1. anything -> 'y1 -> 'y1) -> anything & (forall 'z1. anything -> 'z1 -> 'z1) -> 'c1 & (forall 'a2. anything -> 'a2 -> 'a2) -> (forall 'b3 'c3 'd3 'e3 'f3 'g3. ((forall 'n. anything -> 'n -> 'n) -> 'b3 & (forall 'o. anything -> 'o -> 'o) -> 'c3 -> 'f3 -> 'g3) -> ('b3 -> (forall 'h3. ('g3 -> 'h3 & 'c3) -> 'f3 -> 'h3) -> 'd3) -> ('e3 -> 'e3 | 'd3) | 'q | 'd) -> (forall 'i3 'j3. ((forall 't. anything -> 't -> 't) -> (forall 'u. anything -> 'u -> 'u) -> 'i3 & (forall 'v. anything -> 'v -> 'v) -> (forall 'w. anything -> 'w -> 'w) -> 'i3 & 'j3) -> (anything -> 'j3 | 'i3) | 'x | 'y | 'z | 'a1) -> 'b & 'y & 'a1
//│   = [Function: t_2]
:ResetFuel

// (* This comment is from the ORIGINAL PAGE: *)
// (* Factorial of three. Exposed bugs in old implementation. This one works correctly, but the generated files take up to 3.8GB, and it takes about 1 hour on a 2GHz PIII box to get the result. You can see the final judgement here. Yes, the result is the Church numeral for 6. *)

// (* We test that the result is 6: *)
// let succ n = n + 1 ;;
// t id succ 0 ;;

t id succ 0
//│ res: int
//│    = 6

:stats
:e // * Strange recursive error. The bounds graph is quite large and hard to analyze for debugging...
t_ id succ 0
//│ ╔══[ERROR] Inferred recursive type: (forall 'a 'b 'c 'd. ((forall 'e. ? -> 'e -> 'e) -> (forall 'f. ? -> 'f -> 'f) -> 'c & (forall 'g. ? -> 'g -> 'g) -> (forall 'h. ? -> 'h -> 'h) -> 'd & 'c & 'a) -> (? -> 'a | 'c | 'd) | nothing -> ('b -> 'b | ?) | ?) -> nothing & (forall 'a 'i 'd. ((forall 'g. ? -> 'g -> 'g) -> (forall 'h. ? -> 'h -> 'h) -> 'd & 'a) -> (? -> 'a | 'd) | ? | nothing -> ('i -> 'i | ?)) -> nothing
//│ ║  l.285: 	def t_ y = (fun h -> h (h (h (fun x -> y)))) (fun f -> fun n -> n (fun v -> k2) k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k2) (fun f -> fun x -> f (p k2 f x))) (fun s -> s k2 k2) k) g) x)) three
//│ ╙──       	                                                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.313: 	t_ id succ 0
//│ ║         	^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` is not an instance of type `int`
//│ ║  l.285: 	def t_ y = (fun h -> h (h (h (fun x -> y)))) (fun f -> fun n -> n (fun v -> k2) k app (fun g -> fun x -> n (f (n (fun p -> fun s -> s (p k2) (fun f -> fun x -> f (p k2 f x))) (fun s -> s k2 k2) k) g) x)) three
//│ ╙──       	                                                                                                                                                                                ^^^^^^^^^^^^^^^^
//│ res: error
//│    = 6
//│ constrain calls  : 239
//│ annoying  calls  : 0
//│ subtyping calls  : 2880


// let t (z : 0) = let x = (fun (y: ['t > 0] 'a -> 't) -> y z y) in x x;;
def t (z: nothing) = let x = fun (y: forall 't. 'a -> 't) -> y z y in x x
//│ t: nothing -> nothing
//│  = [Function: t5]

// (* Plus petit. *)
// type tt = ['b = 0] ['c > ['a] ['d = ['t] 'a -> 't] ['e] 'd -> 'e] 'b -> 'c ;;
// let t (z : 0) = let x = (fun (y: ['t > 0] 'a -> 't) -> y z) in x x;;
type Tt = forall 'b 'c. ('b & nothing) -> ('c | (forall 'a 'd 'e. ('d & (forall 't. 'a -> 't))) -> 'e)
def t (z: nothing) = let x = fun (y: forall 't. 'a -> 't) -> y z in x x
//│ Defined type alias Tt
//│ t: nothing -> nothing
//│  = [Function: t6]


// (*
//     * Rank 3, untypable in System F?
//       (fun x -> z (x (fun f -> fun u -> f u)) (x (fun v -> fun g -> g v))) (fun y -> y y y)

// * Note: `z` is free in the MLF commented example... TODO: Ask the MLF authors what they meant


//     * Untypable at any rank
//       (fun x -> x x) (fun x -> x x)

:re
:e
(fun x -> x x) (fun x -> x x)
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.357: 	(fun x -> x x) (fun x -> x x)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ res: error
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded


//     * Rank 3, untypable in F2 but F3
//       (fun f x -> f (f x)) (fun f x -> f (f x)) (fun v w -> v)

:e
(fun f -> fun x -> f (f x)) (fun f -> fun x -> f (f x)) (fun v -> fun w -> v)
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> anything -> anything -> 'a
//│ ╙──
//│ res: 'a -> 'b
//│   where
//│     'a :> 'b
//│     'b :> anything -> anything -> 'a
//│    = [Function (anonymous)]

:RecursiveTypes
(fun f -> fun x -> f (f x)) (fun f -> fun x -> f (f x)) (fun v -> fun w -> v)
//│ res: 'a -> 'b
//│   where
//│     'a :> 'b
//│     'b :> anything -> anything -> 'a
//│    = [Function (anonymous)]
:NoRecursiveTypes


//     * Rank 4, alternate formulation, untypeable in F2, but F3
//       (fun two k -> two two k)(fun f x -> f (f x)) (fun v w -> v)

:e
(fun two -> fun k -> two two k) (fun f -> fun x -> f (f x)) (fun v -> fun w -> v)
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> anything -> anything -> 'a
//│ ╙──
//│ res: 'a -> 'b
//│   where
//│     'a :> 'b
//│     'b :> anything -> anything -> 'a
//│    = [Function (anonymous)]

:RecursiveTypes
(fun two -> fun k -> two two k) (fun f -> fun x -> f (f x)) (fun v -> fun w -> v)
//│ res: 'a -> 'b
//│   where
//│     'a :> 'b
//│     'b :> anything -> anything -> 'a
//│    = [Function (anonymous)]
:NoRecursiveTypes


//     * Rank 5, causes huge blowup. Do not attempt to output skeletons !
//       (fun two k -> two two two k)(fun f -x -> f (f x)) (fun v w -> v)

:e
(fun two -> fun k -> two two two k) (fun f -> fun x -> f (f x)) (fun v -> fun w -> v)
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> anything -> 'a
//│ ╙──
//│ res: 'a -> 'b
//│   where
//│     'a :> 'b | 'c
//│     'b :> anything -> 'c
//│     'c :> anything -> 'a | 'b
//│    = [Function (anonymous)]

:RecursiveTypes
(fun two -> fun k -> two two two k) (fun f -> fun x -> f (f x)) (fun v -> fun w -> v)
//│ res: 'a -> 'b
//│   where
//│     'a :> 'b | 'c
//│     'b :> anything -> 'c
//│     'c :> anything -> 'a | 'b
//│    = [Function (anonymous)]
:NoRecursiveTypes

// * Also works with CT:
:ConstrainedTypes
(fun two -> fun k -> two two two k) (fun f -> fun x -> f (f x)) (fun v -> fun w -> v)
//│ res: 'a -> 'b
//│   where
//│     forall 'c. ('c
//│   where
//│     forall 'd 'e 'f. 'd -> ('e -> 'f
//│   where
//│     'd <: (forall 'g. ('g
//│   where
//│     'd <: 'e -> 'g)) -> 'f) <: (forall 'h. ('h
//│   where
//│     forall 'i. ('i
//│   where
//│     forall 'd 'j 'k. 'd -> ('j -> 'k
//│   where
//│     'd <: (forall 'l. ('l
//│   where
//│     'd <: 'j -> 'l)) -> 'k) <: (forall 'd 'm 'n. 'd -> ('m -> 'n
//│   where
//│     'd <: (forall 'o. ('o
//│   where
//│     'd <: 'm -> 'o)) -> 'n)) -> 'i) <: (forall 'p. 'p -> anything -> 'p) -> 'h)) -> 'c) <: (forall 'q. ('q
//│   where
//│     forall 'c. ('c
//│   where
//│     forall 'd 'e 'f. 'd -> ('e -> 'f
//│   where
//│     'd <: (forall 'g. ('g
//│   where
//│     'd <: 'e -> 'g)) -> 'f) <: (forall 'h. ('h
//│   where
//│     forall 'i. ('i
//│   where
//│     forall 'd 'j 'k. 'd -> ('j -> 'k
//│   where
//│     'd <: (forall 'l. ('l
//│   where
//│     'd <: 'j -> 'l)) -> 'k) <: (forall 'd 'm 'n. 'd -> ('m -> 'n
//│   where
//│     'd <: (forall 'o. ('o
//│   where
//│     'd <: 'm -> 'o)) -> 'n)) -> 'i) <: (forall 'p. 'p -> anything -> 'p) -> 'h)) -> 'c) <: 'a -> 'q)) -> 'b
//│    = [Function (anonymous)]
:NoConstrainedTypes



//  ?????
//     * Factorial of two, using the Y combinator
//       (fun h -> (fun x -> h (x x)) (fun x -> h (x x))) (fun f -> fun n -> n (fun v -> fun x -> fun y -> y) k (fun f -> fun x -> f x)(fun g -> fun x -> n (f (n (fun p -> fun s -> s (p (fun x -> fun y -> y)) (fun f -> fun x -> f (p (fun x -> fun y -> y) f x))) (fun s -> s (fun f -> fun x -> x) (fun f -> fun x -> x)) k) g) x)) (fun f -> fun x -> f (f x))

// * This one still doesn't work with :RecursiveTypes
:e
:re
(fun h -> (fun x -> h (x x)) (fun x -> h (x x))) (fun f -> fun n -> n (fun v -> fun x -> fun y -> y) k (fun f -> fun x -> f x)(fun g -> fun x -> n (f (n (fun p -> fun s -> s (p (fun x -> fun y -> y)) (fun f -> fun x -> f (p (fun x -> fun y -> y) f x))) (fun s -> s (fun f -> fun x -> x) (fun f -> fun x -> x)) k) g) x)) (fun f -> fun x -> f (f x))
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a <: (('b & 'c & 'd) -> ('e | 'd) | 'f) -> 'c -> 'd & (forall 'g 'h 'i 'j 'k. ((forall 'l. anything -> 'l -> 'l) -> 'i & (forall 'm. anything -> 'm -> 'm) -> 'k -> 'g -> 'h) -> ('i -> (forall 'n. ('h -> 'n & 'k) -> 'g -> 'n) -> 'j) -> 'j) -> (forall 'o. ((forall 'p. anything -> 'p -> 'p) -> (forall 'q. anything -> 'q -> 'q) -> 'o) -> 'o) -> (forall 'r. 'r -> anything -> 'r) -> 'a & (forall 's. anything -> anything -> 's -> 's) -> (forall 't. 't -> anything -> 't) -> (forall 'u 'v. ('u -> 'v) -> 'u -> 'v) -> (('b -> 'e & 'f & 'w) -> ('c & 'd) -> 'd) -> 'w -> 'f
//│ ║  l.499: 	(fun h -> (fun x -> h (x x)) (fun x -> h (x x))) (fun f -> fun n -> n (fun v -> fun x -> fun y -> y) k (fun f -> fun x -> f x)(fun g -> fun x -> n (f (n (fun p -> fun s -> s (p (fun x -> fun y -> y)) (fun f -> fun x -> f (p (fun x -> fun y -> y) f x))) (fun s -> s (fun f -> fun x -> x) (fun f -> fun x -> x)) k) g) x)) (fun f -> fun x -> f (f x))
//│ ╙──       	                                                                                                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.499: 	(fun h -> (fun x -> h (x x)) (fun x -> h (x x))) (fun f -> fun n -> n (fun v -> fun x -> fun y -> y) k (fun f -> fun x -> f x)(fun g -> fun x -> n (f (n (fun p -> fun s -> s (p (fun x -> fun y -> y)) (fun f -> fun x -> f (p (fun x -> fun y -> y) f x))) (fun s -> s (fun f -> fun x -> x) (fun f -> fun x -> x)) k) g) x)) (fun f -> fun x -> f (f x))
//│ ║         	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.499: 	(fun h -> (fun x -> h (x x)) (fun x -> h (x x))) (fun f -> fun n -> n (fun v -> fun x -> fun y -> y) k (fun f -> fun x -> f x)(fun g -> fun x -> n (f (n (fun p -> fun s -> s (p (fun x -> fun y -> y)) (fun f -> fun x -> f (p (fun x -> fun y -> y) f x))) (fun s -> s (fun f -> fun x -> x) (fun f -> fun x -> x)) k) g) x)) (fun f -> fun x -> f (f x))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ res: error
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

// *)


