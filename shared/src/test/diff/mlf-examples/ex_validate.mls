:NoRecursiveTypes
:GeneralizeCurriedFunctions

// ============ Dummy classes to represent the types in the examples ============

class List[a]
  method Head: a
  method Tail: List[a]
//│ Defined class List[+a]
//│ Declared List.Head: List['a] -> 'a
//│ Declared List.Tail: List['a] -> List['a]

class Cons[a]: List[a] & { head: a; tail: List[a] }
  method Head = this.head
  method Tail = this.tail
def cons[a]: a -> List[a] -> List[a]
def cons head tail = Cons { head; tail }
//│ Defined class Cons[+a]
//│ Defined Cons.Head: Cons['a] -> 'a
//│ Defined Cons.Tail: Cons['a] -> List['a]
//│ cons: 'a -> List['a] -> List['a]
//│     = <missing implementation>
//│ 'b -> (forall 'c, 'a, 'd, 'head, 'tail. (List['a] & 'c & 'tail) -> ((Cons['a | 'b] with {head: 'head | 'b, tail: 'tail}) | 'd))
//│   <:  cons:
//│ 'a -> List['a] -> List['a]
//│     = [Function: cons]

class Nil[a]: List[a]
  method Head = error
  method Tail = this
def nil: List['a]
nil = Nil {}
//│ Defined class Nil[+a]
//│ Defined Nil.Head: Nil[?] -> nothing
//│ Defined Nil.Tail: (Nil['a] & 'this) -> (Nil['a] & 'this)
//│ nil: List[nothing]
//│    = <missing implementation>
//│ Nil[nothing]
//│   <:  nil:
//│ List[nothing]
//│    = Nil {}

// ============ Type signatures for functions used in the examples ============

def head: forall 'a. List['a] -> 'a
def head l = l.Head
//│ head: List['a] -> 'a
//│     = <missing implementation>
//│ (List['a & 'b] & 'c & 'this) -> 'b
//│   <:  head:
//│ List['a] -> 'a
//│     = [Function: head]

def tail: forall 'a. List['a] -> List['a]
def tail l = l.Tail
//│ tail: List['a] -> List['a]
//│     = <missing implementation>
//│ (List['a] & 'b & 'this) -> (List['a] | 'c)
//│   <:  tail:
//│ List['a] -> List['a]
//│     = [Function: tail]

def is_empty: forall 'a. List['a] -> bool
def is_empty l = eq l nil
//│ is_empty: List['a] -> bool
//│         = <missing implementation>
//│ ('a & 'b) -> (bool | 'c)
//│   <:  is_empty:
//│ List['a] -> bool
//│         = [Function: is_empty]

def concat: forall 'a. List['a] -> List['a] -> List['a]
rec def concat l1 l2 =
  if is_empty l1 then l2
  else cons (head l1) (concat (tail l1) l2)
//│ concat: List['a] -> List['a] -> List['a]
//│       = <missing implementation>
//│ List[?] -> List['a] -> List['a]
//│   <:  concat:
//│ List['a] -> List['a] -> List['a]
//│       = [Function: concat1]

def print_bool: bool -> unit
def print_bool b = log b
//│ print_bool: bool -> unit
//│           = <missing implementation>
//│ ('a & 'b) -> (unit | 'c)
//│   <:  print_bool:
//│ bool -> unit
//│           = [Function: print_bool]

def print_int: int -> unit
def print_int i = log i
//│ print_int: int -> unit
//│          = <missing implementation>
//│ ('a & 'b) -> (unit | 'c)
//│   <:  print_int:
//│ int -> unit
//│          = [Function: print_int]

def print_string: string -> unit
def print_string s = log s
//│ print_string: string -> unit
//│             = <missing implementation>
//│ ('a & 'b) -> (unit | 'c)
//│   <:  print_string:
//│ string -> unit
//│             = [Function: print_string]

def print x = log x
//│ print: ('a & 'b) -> (unit | 'c)
//│      = [Function: print]



// (* Ces exemples permettent de tester durement le syst�me de types. *)

// type id = ['a] 'a -> 'a
type Id = forall 'a. 'a -> 'a
//│ Defined type alias Id

// let choose x y = if true then x else y
// let succ n = n + 1
// let z = (succ : int -> int)
def choose x y = if true then x else y
def succ n = n + 1
def z = succ : int -> int
//│ choose: 'a -> (forall 'b, 'c, 'd. ('b & 'c & 'd) -> ('a | 'd))
//│       = [Function: choose]
//│ succ: (int & 'a) -> (int | 'b)
//│     = [Function: succ]
//│ z: int -> int
//│  = [Function: z]

// let id x = x
// let z = choose (id:id) id
// let z = (choose id succ) 10
// let z = (choose succ id) 10
def id x = x
z = choose (id : Id) id
z = (choose id succ) 10
z = (choose succ id) 10
//│ id: 'a -> 'a
//│   = [Function: id]
//│ z: 'a -> 'a | Id
//│  = [Function: id]
//│ z: int | 'a
//│  = 10
//│ z: int | 'a
//│  = 11

// untype fun x -> x x
fun x -> x x
//│ res: ('a -> 'b & 'a) -> 'b
//│    = [Function: res]

// let delta (x:id) = x x
def delta (x: Id) = x x
def delta_ x = x x
//│ delta: Id -> (Id | 'a)
//│      = [Function: delta]
//│ delta_: ('a -> 'b & 'a) -> 'b
//│       = [Function: delta_]

// let z = delta (delta id)

// :e // FIXME? failed with genLamBodies but works with quantif extrus
def z = delta (delta id)
//│ z: Id | 'a
//│  = [Function: z4]

def z_ = delta_ (delta_ id)
//│ z_: 'a -> 'a
//│   = [Function: z_]

// untype delta succ
:e
delta succ
delta_ succ
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.178: 	delta succ
//│ ║         	^^^^^^^^^^
//│ ╟── type `‘a_518` is not an instance of type `int`
//│ ║  l.119: 	type Id = forall 'a. 'a -> 'a
//│ ║         	                 ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.126: 	def succ n = n + 1
//│ ╙──       	             ^
//│ res: error
//│    = 'function succ(n) {  return n + 1;}1'
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.179: 	delta_ succ
//│ ║         	^^^^^^^^^^^
//│ ╟── function of type `?a -> (forall ?b. ?b)` is not an instance of type `int`
//│ ║  l.126: 	def succ n = n + 1
//│ ║         	         ^^^^^^^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.179: 	delta_ succ
//│ ║         	       ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.126: 	def succ n = n + 1
//│ ╙──       	             ^
//│ res: error
//│    = 'function succ(n) {  return n + 1;}1'

// let z = delta (choose id id)

// :e // FIXME? failed with genLamBodies but works with quantif extrus
def z = delta (choose id id)
//│ z: Id | 'a
//│  = [Function: z5]

def z_ = delta_ (choose id id)
//│ z_: 'a -> 'a
//│   = [Function: z_1]

// let step g = (g 1) - (g 0)
// let apply_to_id f = f id
// let test1 = apply_to_id step
// let test2 = apply_to_id delta
def step g = (g 1) - (g 0)
def apply_to_id f = f id
test1 = apply_to_id step
test2 = apply_to_id delta
test2_ = apply_to_id delta_
//│ step: (0 -> (int & 'a & 'b) & 1 -> (int & 'b) & 'c) -> (int | 'd)
//│     = [Function: step]
//│ apply_to_id: ((forall 'a. 'a -> 'a) -> 'b & 'c) -> 'b
//│            = [Function: apply_to_id]
//│ test1: int | 'a
//│      = 1
//│ test2: Id | 'a
//│      = [Function: id]
//│ test2_: 'a -> 'a
//│       = [Function: id]

// type s  = ['a] list ('a) -> bool
// let annote_s (x:id) = (x : s -> s)
type S = forall 'a. List['a] -> bool
def annote_s (x: Id) = x : S -> S
def annote_s_ x = x : S -> S
//│ Defined type alias S
//│ annote_s: Id -> S -> S
//│         = [Function: annote_s]
//│ annote_s_: (S -> S & 'a) -> S -> S
//│          = [Function: annote_s_]

// let isnil l = l = []
def isnil l = eq l nil
//│ isnil: ('a & 'b) -> (bool | 'c)
//│      = [Function: isnil]

// passif value_restriction
// let t = fun x y ->
//   let isnil = (annote_s x) y in
//   (isnil [ 1 ; 2 ; 3] , isnil [] , isnil ["ok"] , isnil [true])
// in t id isnil
let t = fun x -> fun y ->
  let isnil = (annote_s x) y in
    (isnil (cons 1 (cons 2 (cons 3 nil))), isnil nil, isnil (cons "ok" nil), isnil (cons true nil)) 
  in t id isnil
let t = fun x -> fun y ->
  let isnil = (annote_s_ x) y in
    (isnil (cons 1 (cons 2 (cons 3 nil))), isnil nil, isnil (cons "ok" nil), isnil (cons true nil)) 
  in t id isnil
//│ res: (bool | 'a | 'b, bool | 'c | 'b, bool | 'd | 'b, bool | 'b,)
//│    = [ false, true, false, false ]
//│ res: (bool | 'a | 'b, bool | 'c | 'b, bool | 'd | 'b, bool | 'b,)
//│    = [ false, true, false, false ]

// untype fun x y ->
//   let isnil = (x:id) y in
//   (isnil [ 1 ; 2 ; 3] , isnil [] , isnil ["ok"] , isnil [true])
fun x -> fun y ->
  let isnil = (x : Id) y in
    (isnil (cons 1 (cons 2 (cons 3 nil))), isnil nil, isnil (cons "ok" nil), isnil (cons true nil))
fun x -> fun y ->
  let isnil = x y in
    (isnil (cons 1 (cons 2 (cons 3 nil))), isnil nil, isnil (cons "ok" nil), isnil (cons true nil)) 
//│ res: Id -> (forall 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k. ((List[1 | 2 | 3 | 'a] | 'd) -> 'g & List['a] -> 'c & (List[true | 'k] | 'h) -> 'e & (List["ok" | 'b] | 'j) -> 'i & 'f) -> ('g, 'c, 'i, 'e,))
//│    = [Function: res]
//│ res: ('a -> 'b) -> (forall 'b, 'c, 'd, 'e, 'a, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm. (('a & 'g) -> ('c, 'm, 'h, 'l,)
//│   where
//│     'b <: (List[1 | 2 | 3 | 'e] | 'd) -> 'c & List['f] -> 'm & (List["ok" | 'j] | 'i) -> 'h & (List[true | 'f] | 'k) -> 'l))
//│    = [Function: res]

// (*let t1 = f delta	
// let t2 = f step*)

// let partage x = choose id x
// let departage x = choose id (x:id)
def partage x = choose id x
def departage x = choose id (x : Id)
//│ partage: ('a & 'b & 'c & 'd & 'e) -> (forall 'e, 'f. 'f -> 'f | 'e)
//│        = [Function: partage]
//│ departage: (Id & 'a) -> (forall 'b, 'c. 'b -> 'b | Id | 'c)
//│          = [Function: departage]

// let delta' = fun x -> (departage x) x
// untype fun x -> partage x x
def delta' = fun x -> (departage x) x
def delta'_ = fun x -> (partage x) x
//│ delta': (Id & 'b & 'a & 'c & 'd & 'e) -> 'c
//│       = [Function: delta$]
//│ delta'_: ('a -> 'b & 'a & 'c & 'b & 'd & 'e & 'f & 'g & 'h & 'i) -> 'b
//│        = [Function: delta$_]

// let t = fun x -> (x:id) x, x
// let t = fun (x:id) -> x x, (x:id)
// let t = fun (x:id) -> x x, x
// untype fun x -> x (x:id), x
// untype fun x -> x x, (x:id)
def t = fun x -> ((x : Id) x, x)
def t = fun (x: Id) -> (x x, (x : Id))
def t = fun (x: Id) -> (x x, x)
def t = fun x -> (x (x : Id), x)
def t = fun x -> (x x, x : Id)
def t_ = fun x -> (x x, x)
//│ t: (Id & 'b & 'a & 'c) -> ('c, 'b,)
//│  = [Function: t]
//│ t: Id -> (Id | 'a, Id | 'a,)
//│  = [Function: t1]
//│ t: Id -> (Id | 'a, Id | 'a,)
//│  = [Function: t2]
//│ t: (Id & Id -> 'a & 'b) -> ('a, 'b,)
//│  = [Function: t3]
//│ t: (Id & 'a -> 'b & 'a) -> ('b, Id,)
//│  = [Function: t4]
//│ t_: ('a -> 'b & 'a) -> ('b, 'a,)
//│   = [Function: t_]

// untype fun x -> (x:id), x x
fun x -> (x : Id, x x)
//│ res: (Id & 'a -> 'b & 'a) -> (Id, 'b,)
//│    = [Function: res]

// let ig x = () (* ignore *)
def ig x = null
//│ ig: 'a -> null
//│   = [Function: ig]

// (* The following is not typable in System F (afaik) *)
// let aa f = f id
// untype fun g -> ig (g delta) ; (fun t -> ig (g t) ; t succ) (fun x -> succ (x 8))
// let ff = fun (g:['a > id] ['b] ('a -> 'b) -> 'b) ->
//         ig (g delta) ; (fun t -> ig (g t) ; t succ) (fun x -> succ (x 8))
def aa f = f id
def ff = fun (g: forall 'a 'b. (('a | Id) -> 'b) -> 'b) ->
  let _ = ig (g delta) in
    (fun t ->
      let _ = ig (g t) in
      t succ
    ) (fun x -> succ (x 8))
def ff_ = fun g ->
  let _ = ig (g delta) in
    (fun t ->
      let _ = ig (g t) in
      t succ
    ) (fun x -> succ (x 8))
//│ aa: ((forall 'a. 'a -> 'a) -> 'b & 'c) -> 'b
//│   = [Function: aa]
//│ ff: (forall 'a, 'b. (('a | Id) -> 'b) -> 'b) -> (forall 'c, 'd. int | 'c | 'e | 'd)
//│   = [Function: ff]
//│ ff_: ((forall 'a, 'b, 'c. (8 -> (int & 'a & 'b) & 'c) -> (forall 'd, 'e, 'f. int | 'd | 'e | 'f) | 'g) -> ('h & 'i) & (forall 'j. Id -> (Id | 'j)) -> ('k & 'l) & 'm) -> (forall 'e, 'f. int | 'e | 'n | 'f)
//│    = [Function: ff_]

// let bigtest = ff aa
bigtest = ff aa
bigtest_ = ff_ aa
//│ bigtest: int | 'a | 'b | 'c
//│        = 10
//│ bigtest_: int | 'a | 'b | 'c
//│         = 10

// (* Variable libre / variable li�e dans les annotations. *)
// let example f = (f:['a] 'a -> int -> 'b) f
// let mkpair x y = (x,y)
def example f = (f: forall 'a. 'a -> int -> 'b) f
def example_ f = f f
def mkpair x y = (x, y)
//│ example: (forall 'a. 'a -> int -> 'b & 'c & 'a0) -> (int -> 'b | 'd)
//│        = [Function: example]
//│ example_: ('a -> 'b & 'a) -> 'b
//│         = [Function: example_]
//│ mkpair: 'a -> (forall 'b. 'b -> ('a, 'b,))
//│       = [Function: mkpair]

// untype example mkpair
// (* �a echoue parce qu'on instancie 'b avec un type contenant 'a *)
// (* Il faudrait que le message d'erreur soit plus clair. *)
example mkpair
example_ mkpair
//│ res: int -> (‘a_1458_1463, int,) | 'a
//│    = [Function (anonymous)]
//│ res: 'a -> (forall 'b. 'b -> (forall 'c. 'c -> ('b, 'c,)), 'a,)
//│    = [Function (anonymous)]



// (* Exemple MLF avec des fonctions et des constructions r�cursives. *)

// let rec x = 1 :: y
// and     y = 2 :: x

:RecursiveTypes // needed for this recursive def
:ng
rec def p = { x = cons 1 p.y; y = cons 2 p.x }
def x = p.x
def y = p.y
//│ p: {x: List[1 | 2], y: List[1 | 2]}
//│ x: List[1 | 2]
//│ y: List[1 | 2]
:NoRecursiveTypes

// let print_int x = print_string "#"; print_int x; print_string " "
// let intprint x = print_int x
def print_int x =
  let _ = print_string "#" in
  let _ = print_int x in
  print_string " "
def intprint x = print_int x
//│ (int & 'a) -> (unit | 'b)
//│   <:  print_int:
//│ int -> unit
//│          = [Function: print_int1]
//│ intprint: (int & 'a) -> (unit | 'b)
//│         = [Function: intprint]

// let myNil l = l = []
def myNil l = eq l nil
//│ myNil: ('a & 'b) -> (bool | 'c)
//│      = [Function: myNil]

// let rec append x l =
//   if l = [] then [x]
//   else (car l)::(append x (cdr l))
rec def append x l =
  if eq l nil then cons x nil
  else cons (head l) (append x (tail l))
//│ append: 'a -> List['a] -> List['a]
//│       = [Function: append]

// let rec map l f =
//  if l = [] then []
//  else (f (car l)) :: (map (cdr l) f)
rec def map l f =
  if eq l nil then nil
  else cons (f (head l)) (map (tail l) f)
//│ map: List['a] -> ('a -> 'b) -> List['b]
//│    = [Function: map]

// let message () = print "** MESSAGE **"
def message (_: unit) = print "** MESSAGE **"
//│ message: unit -> (forall 'a. unit | 'b | 'a)
//│        = [Function: message]

// let intfa f = f 15
def intfa f = f 15
//│ intfa: (15 -> 'a & 'b) -> 'a
//│      = [Function: intfa]

// let polyann (a:'x) (b:int) f (g:int -> 'x -> 'y) = g (f 10) a b

// FIXME SOF
def polyann (a: 'x) (b: int) f (g: int -> 'x -> 'y) = g (f 10) a b
//│ polyann: 'x -> (int & 'a) -> (forall 'b. 'b -> (forall 'c, 'd, 'y, 'a, 'b, 'x, 'x0. ((int -> ('x | 'x0) -> (int -> 'd & 'y & 'c)) -> 'd
//│   where
//│     'b <: 10 -> (int & 'a))))
//│        = [Function: polyann]

def polyann_ a b f g = g (f 10) a b
//│ polyann_: 'a -> (forall 'b. 'b -> (forall 'c. 'c -> (forall 'd, 'e, 'f, 'c, 'g, 'b, 'a, 'h. (('f -> ('a -> ('b -> 'd & 'h) & 'e) & 'g) -> 'd
//│   where
//│     'c <: 10 -> 'f))))
//│         = [Function: polyann_]

// let voyage (f:'p -> 'q) x y = (y, f x)
def voyage (f: 'p -> 'q) x y = (y, f x)
//│ voyage: ('p -> 'q) -> (forall 'a. ('p & 'a) -> (forall 'b, 'c. 'b -> ('b, 'q | 'c,)))
//│       = [Function: voyage]

def voyage_ f x y = (y, f x)
//│ voyage_: 'a -> (forall 'b. 'b -> (forall 'a, 'b, 'c, 'd. ('d -> ('d, 'c,)
//│   where
//│     'a <: 'b -> 'c)))
//│        = [Function: voyage_]

// let main =

//   let print_sep s l =

//     let max_depth = 20 in

//     let rec alpha = print_list
//     and print_list n l =

//       if not(n < 0) then

//         if nil l then print_string "]"
//         else 
//           begin
//             intprint (car l);
//             print_string s;
//             print_list (n-1) (cdr l)
//           end
//       else 
// 	       begin
// 	         print_string ("... ]");
// 	         (* failwith ("T�te de liste : "^(string_of_int (car l))) *)
// 	       end
//     in
//     print_string "[";
//     print_list max_depth l;

//   in

//   print (myNil [1;2]);
//   print " ";
//   print (myNil ["foo";"bar"]);
//   print "\n";

//   let ll = [10; 20; 30; 40] @ [50; 60; 70] in
//   let ll2 = append 80 ll in
//   print_sep "; " ll2;
//   print_string "\n";
//   print_sep "" x;

//   ()

:RecursiveTypes // needed for this recursive def
:ng
def main =
  let print_sep = fun s -> fun l ->
    let max_depth = 20 in
      let rec p =
        { alpha = p.print_list;
          print_list = fun n -> fun l ->
            if not (n < 0) then
              if is_empty l then print_string "]"
              else
                let _ = intprint (head l) in
                let _ = print_string s in
                p.print_list (n - 1) (tail l)
            else
              print_string "... ]"
        } in
      let alpha = p.alpha in
      let print_list = p.print_list in
        let _ = print_string "[" in
        print_list max_depth l
  in
    let _ = print (myNil (cons 1 (cons 2 nil))) in
    let _ = print " " in
    let _ = print (myNil (cons "foo" (cons "bar" nil))) in
    let _ = print "\n" in
    let ll = concat (cons 10 (cons 20 (cons 30 (cons 40 nil)))) (cons 50 (cons 60 (cons 70 nil))) in
      let ll2 = append 80 ll in
        let _ = print_sep "; " ll2 in
        let _ = print_string "\n" in
        let _ = print_sep "" x in
        null
//│ main: null
:NoRecursiveTypes

// (* Des probl�mes d'unification � gogo. *)
// type sid = ['a] 'a -> 'a
// type siid = ['a,'b] ('a -> 'b) -> ('a -> 'b)
// type sdup = ['a,'b] ('a -> 'a) -> ('b -> 'b)
// type sdip = ['a]    ('a -> 'a) -> ('a -> 'a)
// type i = int
// type j = bool

// (*  PAGE 1 *)

// please unify ['a > ['a0 > sid] i -> 'a0] 'a -> 'a 
// (* with *) :   ['c > sdup] (i -> 'c) -> (i -> 'c)
// (* Result should be *) 
//          =   ['a0 > sdip] ['a = i -> 'a0] 'a -> 'a

// please unify ['a > ['a0 > sid] i -> 'a0] ['b > ['b0 > siid] j -> 'b0] 'a -> 'b
//          :   ['c > sdup] (i -> 'c) -> (j -> 'c)
//          =   ['c0 > sdip] (i -> 'c0) -> (j -> 'c0)

// please unify ['a > sid, 'b > sdup] 'a -> 'b  :   sid
//          =   ['a > sdip] 'a -> 'a

// please failon_unify ['a > sid, 'b = sdup] 'a -> 'b  :   sid

// please unify ['a > sid, 'b = siid] 'a -> 'b  :   sid
//          =   ['a = siid] 'a -> 'a

// please unify ['a > ['a1 > sid, 'a2 > siid] 'a1 -> 'a2] 'a -> 'a
//          :   ['c > ['c2 > siid] (i -> i) -> 'c2] 'c -> 'c
//          =   ['a > ['c2 > siid] (i -> i) -> 'c2] 'a -> 'a

// please unify ['a > ['a0 > siid] ('a0 -> i) -> i] 'a -> 'a
//          :   ['a > ['a0 > sdup] 'a0 -> i] ('a -> i) -> ('a -> i)
//          =   ['c0 > sdip, 'c = 'c0 -> i] ('c -> i) -> ('c -> i)

// please unify ['a > sid] ['b1 > ['c] 'c -> 'a]    ['c1 > ['c3] 'c3 -> 'a] 'b1 -> 'c1
//          :   ['a > sid] ['b2 > ['c] 'c -> i -> i, 'c2 = ['c3] 'c3 -> 'a] 'b2 -> 'c2
//          =   ['a = i -> i] ['b1 > ['c] 'c -> 'a] ['c1 = ['c3] 'c3 -> 'a] 'b1 -> 'c1

// please unify ['a > sid] ['b > sdup] ('b -> 'b) -> 'a
//          :   ['c > sid] 'c -> 'c
//          =   ['b > sdup] ('b -> 'b) -> ('b -> 'b)

// please failon_unify ['a] ['b = ['b0] 'b0 -> 'a] 'a -> 'b : sid


// (* PAGE 2 *)
// please unify ['a1 = ['b1 = sdup] ['c] 'c -> 'b1] 'a1 -> i
//          :   ['b2 = sdup] ['a2 = ['c3] 'c3 -> 'b2] 'a2 -> i
//          =   ['b2 = sdup] ['a2 = ['c3] 'c3 -> 'b2] 'a2 -> i

// please unify ['a1 = ['a2 = ['a3 = sdup] ['c] 'c -> 'a3 -> 'a3] 'a2 -> i] 'a1 -> i
//          :   ['a1 = ['a3 = sdup] ['a2 = ['c] 'c -> 'a3 -> 'a3] 'a2 -> i] 'a1 -> i
//          =   ['a1 = ['a3 = sdup] ['a2 = ['c] 'c -> 'a3 -> 'a3] 'a2 -> i] 'a1 -> i

// please failon_unify ['a1 = ['a2 > sdup] 'a2 -> 'a2] 'a1 -> i
//          :   ['a2 = sdup] ['a1 = 'a2 -> 'a2] 'a1 -> i

// please failon_unify ['a1 = ['a2 > sdup] ['a3 = ['a4 > siid] 'a2 -> 'a4] ['a5] 'a5 -> 'a3 -> i] 'a1 -> i
//          :   ['b2 > sdup] ['b3 = ['b4 > siid] 'b2 -> 'b4] ['b1 = ['b5] 'b5 -> 'b3 -> i] 'b1 -> i

// please unify ['a1 = ['a2 = sdup, 'a3 = sdup] 'a2 -> 'a3] 'a1 -> i
//          :   ['a1 = ['a = sdup] 'a -> 'a] 'a1 -> i
//          =   ['a1 = ['a = sdup] 'a -> 'a] 'a1 -> i

// please unify ['a1 = ['a2 = sdup, 'a3 = sdup] 'a2 -> 'a3] 'a1 -> i
//          :   ['a1 > ['a] 'a -> 'a] 'a1 -> i
//          =   ['a1 = ['a = sdup] 'a -> 'a] 'a1 -> i

// please unify ['a1 = ['a2 = ['a3 = sdup] ['b] 'b -> 'a3 -> i] ['c] 'c -> 'a2 -> i] 'a1 -> i
//          :   ['a3 = sdup] ['a1 = ['a2 = ['b] 'b -> 'a3 -> i] ['c] 'c -> 'a2 -> i] 'a1 -> i
//          =   ['a3 = sdup] ['a1 = ['a2 = ['b] 'b -> 'a3 -> i] ['c] 'c -> 'a2 -> i] 'a1 -> i

// please failon_unify ['a1 = ['a2 = ['a3 > sdup] ['b] 'b -> 'a3 -> i] ['c] 'c -> 'a2 -> i] 'a1 -> i
//          :   ['a3 = sdup] ['a2 = ['b] 'b -> 'a3 -> i] ['a1 = ['c] 'c -> 'a2 -> i] 'a1 -> i

// please unify ['a = ['a2 = ['b1 = sdup] i -> 'b1] ['a1 > ['c] 'c -> 'a2] 'a1 -> 'a1] 'a -> 'a
//          :   ['b1 = sdup] ['a = ['a1 > ['c] 'c -> i -> 'b1] 'a1 -> 'a1] 'a -> 'a
//          =   ['b1 = sdup] ['a = ['a1 > ['c] 'c -> i -> 'b1] 'a1 -> 'a1] 'a -> 'a

// please unify ['b > sid, 'a = ['a1 = siid, 'a2 = ['c] 'a1 -> 'b -> 'c, 'a3 = ['c] 'a1 -> 'c] 'a2 -> 'a3] 'a -> 'a
//          :   ['a = ['a1 = siid, 'a2 = ['c] 'a1 -> (i -> i) -> 'c, 'a3 = ['c] 'a1 -> 'c] 'a2 -> 'a3] 'a -> 'a
//          =   ['a = ['a1 = siid, 'a2 = ['c] 'a1 -> (i -> i) -> 'c, 'a3 = ['c] 'a1 -> 'c] 'a2 -> 'a3] 'a -> 'a

// please unify ['a1 = ['a2 = ['a3 = siid] i -> 'a3] j -> 'a2] i -> 'a1
//          :   ['a3 = siid] i -> j -> i -> 'a3
//          =   ['a3 = siid] i -> j -> i -> 'a3

// please failon_unify ['a1 = ['a2 = ['a3 = sdup] ['b] 'b -> 'a3 -> i] ['c] 'c -> 'a2 -> i] 'a1 -> i
//          :   ['a3 = sdup] ['a1 = ['a2 > ['b] 'b -> 'a3 -> i] ['c] 'c -> 'a2 -> i] 'a1 -> i


// please unify ['a1 = ['a2 = ['a3 = ['a4 = ['a5 = 0] 'a5 -> i]
//                                         ('a4 -> i) -> i]
//                                         ('a3 -> i) -> i] 'a2 -> i] 'a1 -> i
//          :   ['b1 = ['b2 = ['b3 = ['b4 = 0] ('b4 -> i) -> i]
//                                         ('b3 -> i) -> i]
//                                         ('b2 -> i) -> i] 'b1 -> i
//          =   ['c1 = ['c5 = 0] ((((('c5 -> i) -> i) -> i) -> i) -> i) -> i] 'c1 -> i

// please unify ['a1 > ['a2 > ['a3 > ['a4 > ['a5 > siid] 'a5 -> i]
//                                         ('a4 -> i) -> i]
//                                         ('a3 -> i) -> i] 'a2 -> i] 'a1 -> i
//          :   ['b1 > ['b2 > ['b3 > ['b4 > sdup] ('b4 -> i) -> i]
//                                         ('b3 -> i) -> i]
//                                         ('b2 -> i) -> i] 'b1 -> i
//          =   ['c1 > ['c5 > sdip] ((((('c5 -> i) -> i) -> i) -> i) -> i) -> i] 'c1 -> i

// (* Avec deux quantificateurs � remonter. *)
// please unify ['a2 > ['a4 > ['a6,'a7] ('a6 -> 'a7) -> i ] ('a4 -> i) -> i ] ('a2 -> i) -> i
//          :   ['b1 > ['b3 > ['b5 > ['b6,'b7] 'b6 -> 'b7 ] ('b5 -> i) -> i ] ('b3 -> i) -> i ] 'b1 -> i
//          =   ['c6,'c7] ((((('c6 -> 'c7) -> i) -> i) -> i) -> i) -> i


// (* Cet exemple cr�e un graphe mal form�. *)
// please failon_unify ['a] ['b = ['c] 'c -> 'a] 'b -> 'a
//          :   ['a] ['b > ['c] 'c -> list ('c)] 'b -> 'a

// (* Plus simple *)
// please failon_unify ['a] ['b = ['c] 'c -> 'a] 'b -> 'a
//          :   ['a] ['b > ['c] 'c -> 'c] 'b -> 'a

// (* Extrusion automatique de binders. *)
// please unify  ['a] ['b > ['c] 'c -> 'a] 'b -> 'a
//           :   ['a] ['b > ['c] 'c -> 'c] 'b -> 'a
//           =   ['c] ('c -> 'c) -> 'c

// (* Plus compliqu�. *)
// please unify  ['a] ['b > ['c] 'c -> 'a] 'b -> 'a
//           :   ['a] ['b > ['c] 'c -> list ('c)] 'b -> 'a
//           =   ['c] ('c -> list ('c)) -> list ('c)

// (* Variante *)
// please unify  ['a] ['b > ['c] ['d] 'c -> 'd] 'b -> 'a
//           :   ['a] ['b = ['c] 'c -> 'a] 'b -> 'a
//           =   ['a] ['b = ['c] 'c -> 'a] 'b -> 'a

// please failon_unify  ['a] ['b = ['c] ['d] 'c -> 'd] 'b -> 'a
//           :   ['a] ['b > ['c] 'c -> 'a] 'b -> 'a


// please unify ['a] ['b > ['c] ['d > ['e] 'c -> 'e] 'c -> 'd] 'b -> 'a
//          :   ['a] ['b > ['c] 'c -> 'a] 'b -> 'a
//          =   ['c] ['a > ['e] 'c -> 'e] ('c -> 'a) -> 'a

// please unify ['a] ['b > ['f] ['c] ['d > ['e] 'c -> 'e] 'f * 'c * 'd] 'b -> 'a
//          :   ['a] ['b > ['f] ['c] 'f * 'c * 'a] 'b -> 'a
//          =   ['c] ['a > ['e] 'c -> 'e] ['b > ['f] ('f * 'c * 'a)] 'b -> 'a

// please failon_unify ['a] ['b = ['c] ['d > ['e] 'c -> 'e] 'c -> 'd] 'b -> 'a
//          :   ['a] ['b > ['c] 'c -> 'a] 'b -> 'a

// please failon_unify ['a] ['b > ['c] ['d > ['e] 'c -> 'e] 'c -> 'd] 'b -> 'a
//          :   ['a] ['b = ['c] 'c -> 'a] 'b -> 'a



// please unify ['a] ['b > ['b1] ['c > ['c1] ['d > ['d1] list ('b1 * 'c1 * 'd1)] list ('d) ] list ('c) ] 'b -> 'a
//          :   ['a] (list (list (list ('a)))) -> 'a
//          =   ['b1] ['c1] ['d1] (list (list (list ('b1 * 'c1 * 'd1)))) -> ('b1 * 'c1 * 'd1)


// please notequiv ['b]['c] ('b * 'c)  -> ('b * 'c)
//          :   ['b]['c] ('b * 'c)  -> ('c * 'b)

// (* Unification d'une variable avec un sch�ma de types. *)
// type sid = ['a] 'a -> 'a
// let id y = y
// let succ n = n + 1
// let test = fun (x:'a) -> ((x:sid) , if true then x else id)
// untype fun (x:'a) -> ((x:sid) , if true then x else succ)
type Sid = forall 'a. 'a -> 'a
def id y = y
def succ n = n + 1
def test = fun (x : 'a) -> (x : Sid, if true then x else id)
def test2 = fun (x : 'a) -> (x : Sid, if true then x else succ)
//│ Defined type alias Sid
//│ id: 'a -> 'a
//│   = [Function: id1]
//│ succ: (int & 'a) -> (int | 'b)
//│     = [Function: succ1]
//│ test: (Sid & 'a & 'b & 'c) -> (Sid, forall 'c, 'd. 'd -> 'd | 'c,)
//│     = [Function: test]
//│ test2: (Sid & 'a & 'b & 'c) -> (Sid, forall 'c, 'd, 'e. (int & 'd) -> (int | 'e) | 'c,)
//│      = [Function: test21]


// (* Typable dans MLF, mais pas dans systeme F. *)
// type sid = ['a] 'a -> 'a
// type sa = ['b] ['a > sid] ('a -> 'b) -> 'b
type Sa = forall 'a 'b. (('a | Sid) -> 'b) -> 'b
//│ Defined type alias Sa


// let auto (x:sid) = x x
// let id x = x
// let k x y = x
def auto (x: Sid) = x x
def auto_ x = x x
def id x = x
def k x y = x
//│ auto: Sid -> (Sid | 'a)
//│     = [Function: auto]
//│ auto_: ('a -> 'b & 'a) -> 'b
//│      = [Function: auto_]
//│ id: 'a -> 'a
//│   = [Function: id2]
//│ k: 'a -> (forall 'b. 'b -> 'a)
//│  = [Function: k]

// let church_zero = fun f -> id
// let church_un = id
// let church_succ n = fun f x -> f (n f x)
// untype fun g -> k (g auto) ((fun t -> g t ; t church_un) (fun x -> (church_succ x) church_zero))
// let f  = fun (g:sa) -> k (g auto) ((fun t -> g t ; t church_un) (fun x -> (church_succ x) church_zero))
// let a = fun f -> f id
def church_zero = fun f -> id
def church_un = id
def church_succ n = fun f -> fun x -> f (n f x)
def f = fun (g: Sa) -> k (g auto) ((fun t -> let _ = g t in t church_un) (fun x -> (church_succ x) church_zero))
def f_ = fun g -> k (g auto_) ((fun t -> let _ = g t in t church_un) (fun x -> (church_succ x) church_zero))
def a = fun f -> f id
//│ church_zero: 'a -> (forall 'b. 'b -> 'b)
//│            = [Function: church_zero]
//│ church_un: 'a -> 'a
//│          = [Function: church_un]
//│ church_succ: 'a -> (forall 'b. 'b -> (forall 'c, 'a, 'd, 'e, 'f, 'b. ('e -> 'c
//│   where
//│     'b <: 'd -> 'c
//│     'a <: 'b -> ('e -> 'd & 'f))))
//│            = [Function: church_succ]
//│ f: Sa -> (forall 'a, 'b. Sid | 'b | 'a)
//│  = [Function: f]
//│ f_: ((forall 'a, 'b. ('a & 'b) -> (forall 'c, 'd, 'e, 'b, 'f, 'g. ('g -> 'e | 'c
//│   where
//│     'b <: (forall 'h, 'i. 'h -> (forall 'j. 'j -> 'j) | 'i) -> ('g -> 'f & 'd)
//│     forall 'h, 'i. 'h -> (forall 'j. 'j -> 'j) | 'i <: 'f -> 'e)) | 'k) -> 'l & (forall 'm, 'n. ('m -> 'n & 'm) -> 'n) -> ('o & 'p & 'q) & 'r) -> 'q
//│   = [Function: f_]
//│ a: ((forall 'a. 'a -> 'a) -> 'b & 'c) -> 'b
//│  = [Function: a]

// let app x y = x y
// let test1 = f a
// let test2 = app f a
def app x y = x y
def test1 = f a
def test2 = app f a
//│ app: 'a -> (forall 'a, 'b, 'c. ('b -> 'c
//│   where
//│     'a <: 'b -> 'c))
//│    = [Function: app]
//│ test1: Sid | 'a | 'b
//│      = [Function: test11]
//│ test2: Sid | 'a | 'b
//│      = [Function: test22]


// (* Create occur-checks. *)
// please failon_unify ['b] 'b -> ('b -> 'b)
//          :   ['a > ['c] ('c -> 'c) -> ('c -> 'c)]
//                   'a -> 'a

// please failon_unify ['i] 'i -> 'i
//          :   ['a > ['c] ('c -> 'c) -> ('c -> 'c)]
//              ['b > ['d] 'd -> 'a]
//              'b -> 'a

// ;;
// please failon_unify ['i] 'i -> 'i
//          :   ['a > ['c] ('c -> 'c) -> ('c -> 'c)]
//              ['b > ['d] 'd -> 'a]
//              'a -> 'b

// ;;


// let t = let x = fun y -> y in x x ;;
// let t = let x = ((fun y -> y) : ['a] 'a -> 'a) in x x ;;
// let t = let x = ((fun y -> y) : 'a) in x x ;;
def t = let x = fun y -> y in x x
def t = let x = (fun y -> y) : forall 'a. 'a -> 'a in x x
def t = let x = (fun y -> y) : 'a in x x
//│ t: 'a -> 'a
//│  = [Function: t5]
//│ t: 'a -> 'a
//│  = [Function: t6]
//│ t: 'a | 'b -> 'b
//│  = [Function: t7]


// untype  fun x -> ( (((x:'a) : sid):'a), (x:'a) x)
// untype  fun x -> ( ((x:'a) : sid), (x:'a) x)
// untype  fun x -> ( ((x : sid):'a), (x:'a) x)
// untype  fun x -> ( (((x:'a) : sid):'a), x x)
// untype  fun x -> ( (x : sid), (x:'a) x)
// let t = fun x -> ( (((x:'a) : sid):'a), (x:'a))
fun x -> ( (((x : 'a) : Sid) : 'a), (x : 'a) x)
fun x -> ( ((x : 'a) : Sid), (x : 'a) x)
fun x -> ( ((x : Sid) : 'a), (x : 'a) x)
fun x -> ( (((x : 'a) : Sid) : 'a), x x)
fun x -> ( (x : Sid), (x : 'a) x)
fun x -> ( (((x : 'a) : Sid) : 'a), x : 'a)
//│ res: (Sid & 'a -> 'b & 'a) -> (Sid, 'b,)
//│    = [Function: res]
//│ res: (Sid & 'a -> 'b & 'a) -> (Sid, 'b,)
//│    = [Function: res]
//│ res: (Sid & 'a -> 'b & 'a) -> (Sid, 'b,)
//│    = [Function: res]
//│ res: (Sid & 'a -> 'b & 'a) -> (Sid, 'b,)
//│    = [Function: res]
//│ res: (Sid & 'a -> 'b & 'a) -> (Sid, 'b,)
//│    = [Function: res]
//│ res: (Sid & 'a) -> (Sid, 'a,)
//│    = [Function: res]

// (* R�cursion polymorphe. *)
// untype let rec id x = if true then x else id id x in id

// FIXME
// Same as `id1` in `ex_demo.mls`; works with `:RecursiveTypes`
:e
rec def id_ x = if true then x else id_ id_ x
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression; a type annotation may be required
//│ ║  l.886: 	rec def id_ x = if true then x else id_ id_ x
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  (α2635' -> α2641')  <:  α2639'    FunctionType  TypeVariable
//│ ╙──  ... looks like:  (α2635' -> α2641')  <:  α2639'
//│ id_: 'id_
//│   where
//│     'id_ :> 'a -> 'b
//│     'a :> 'id_
//│        <: 'b
//│     'b :> 'id_
//│        <: 'a -> 'b
//│    = [Function: id_]

// let rec (id:sid) x = if true then x else id id x

def id: Sid
//│ id: Sid
//│   = <missing implementation>

// FIXME
rec def id x = if true then x else id id x
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression; a type annotation may be required
//│ ║  l.909: 	rec def id x = if true then x else id id x
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  (α2656' -> α2662')  <:  α2660'    FunctionType  TypeVariable
//│ ╙──  ... looks like:  (α2656' -> α2662')  <:  α2660'
//│ 'id
//│   where
//│     'id :> 'a -> 'b
//│     'a :> 'id
//│        <: 'b
//│     'b :> 'id
//│        <: 'a -> 'b
//│   <:  id:
//│ Sid
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.909: 	rec def id x = if true then x else id id x
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘a_2676` is not a function
//│ ║  l.736: 	type Sid = forall 'a. 'a -> 'a
//│ ║         	                  ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.909: 	rec def id x = if true then x else id id x
//│ ║         	                                   ^^^^^^^
//│ ╟── from reference:
//│ ║  l.909: 	rec def id x = if true then x else id id x
//│ ╙──       	                            ^
//│   = [Function: id3]


// let z = print_string "Ok, all tests passed."


