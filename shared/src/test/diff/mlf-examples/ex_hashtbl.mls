:NoRecursiveTypes
:NoJS



// ============ Dummy definitions to type the examples ============


class List[a]
  method Get: a
def nil: List['a]
def cons[a]: a -> List[a] -> List[a]
def isnil: List['a] -> bool
def car: List['a] -> 'a
def cdr: List['a] -> List['a]
def fst: (('a, 'b),) -> 'a
def snd: (('a, 'b),) -> 'b
//│ Defined class List[+a]
//│ Declared List.Get: List['a] -> 'a
//│ nil: List[nothing]
//│ cons: 'a -> List['a] -> List['a]
//│ isnil: List[?] -> bool
//│ car: List['a] -> 'a
//│ cdr: List['a] -> List['a]
//│ fst: ('a, anything,) -> 'a
//│ snd: (anything, 'b,) -> 'b


// (* Use the value restriction ! *)

// type option ('a) = None | Some of 'a
class None
class Some[a]: { val: a }
type Option[a] = None | Some[a]
def none: Option['a]
def none = None {}
def some: 'a -> Option['a]
def some val = Some { val }
//│ Defined class None
//│ Defined class Some[+a]
//│ Defined type alias Option[+a]
//│ none: Option[nothing]
//│ None
//│   <:  none:
//│ Option[nothing]
//│ some: 'a -> Option['a]
//│ 'val -> Some['val]
//│   <:  some:
//│ 'a -> Option['a]

def match_opt: forall 'a 'r. (() -> 'r, 'a -> 'r) -> Option['a] -> 'r
//│ match_opt: (() -> 'r, 'a -> 'r,) -> Option['a] -> 'r

match_opt (n, s) opt = case opt of
  None -> n(),
  Some -> s(opt.val)
//│ (() -> 'a, 'val -> 'a,) -> (None | Some[?] & {val: 'val}) -> 'a
//│   <:  match_opt:
//│ (() -> 'r, 'a -> 'r,) -> Option['a] -> 'r



// ============ The original examples ============


// let create_hashtbl () = []
def create_hashtbl () = nil
//│ create_hashtbl: () -> List[nothing]

// let hashtbl_add table key element = (key, element) :: table
def hashtbl_add table key element = cons ((key, element)) table
//│ hashtbl_add: List['a] -> 'b -> 'c -> List[('b, 'c,) | 'a]


// let rec find table key = 
//   if nil table then None
//   else if fst (car table) = key then Some (snd (car table))
//   else find (cdr table) key

rec def find table key =
  if isnil table then none
  else if eq (fst (car table)) key then some (snd (car table))
  else find (cdr table) key
//│ find: List[(anything, 'a,)] -> anything -> Option['a]

// :ns
// find

:ng
find(error:List[(int, string)])(unit)
//│ res: Option[string]


// * Versions with `_A` are versions we annotate that weren't originally annotated
def find_A: forall 'a 'b. List[('a, 'b)] -> 'a -> Option['b]
//│ find_A: List[(anything, 'b,)] -> anything -> Option['b]

def find_A table key =
  if isnil table then none
  else if eq (fst (car table)) key then some (snd (car table))
  else find_A (cdr table) key
//│ List[(anything, 'b,)] -> anything -> Option['b]
//│   <:  find_A:
//│ List[(anything, 'b,)] -> anything -> Option['b]


// let nfind table key =
//   begin match find table key with
//   | None -> fun f x -> x
//   | Some n -> n
//   end

def nfind table key =
  match_opt (
    fun () -> fun f -> fun x -> x,
    fun v -> v
  ) (find table key)
//│ nfind: List[(anything, 'a,)] -> anything -> (anything -> 'b -> 'b | 'a)


// type Int = ['a] ('a -> 'a) -> ('a -> 'a)
type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ Defined type alias ChurchInt

// let succ (n:Int) = fun f x -> f (n f x)
def succ (n: ChurchInt) = fun f -> fun x -> f (n f x)
//│ succ: ChurchInt -> ('a -> ('a & 'b)) -> 'a -> 'b

// * Versions with `_` are versions where we removed the annotatation
def succ_ n = fun f -> fun x -> f (n f x)
//│ succ_: ('a -> 'b -> 'c) -> ('c -> 'd & 'a) -> 'b -> 'd

// let add (n:Int) (m:Int) = n succ m
def add (n: ChurchInt) (m: ChurchInt) = n succ m
def add_ n m = n succ_ m
//│ add: ChurchInt -> ChurchInt -> (('a -> ('a & 'b)) -> 'a -> 'b | ChurchInt)
//│ add_: ((forall 'a 'b 'c 'd. ('a -> 'b -> 'c) -> ('c -> 'd & 'a) -> 'b -> 'd) -> 'e -> 'f) -> 'e -> 'f

// let printInt (n:Int) = print (n (fun x -> x+1) 0)
def printInt (n: ChurchInt) = toString (n (fun x -> x + 1) 0)
def printInt_ n = toString (n (fun x -> x + 1) 0)
//│ printInt: ChurchInt -> string
//│ printInt_: ((int -> int) -> 0 -> anything) -> string

// let table = create_hashtbl ()
// let table = hashtbl_add table "one" (fun f x -> f x)
// let table = hashtbl_add table "two" (fun f x -> f (f x))
table = create_hashtbl ()
table = hashtbl_add table "one" (fun f -> fun x -> f x)
table = hashtbl_add table "two" (fun f -> fun x -> f (f x))
//│ table: List[nothing]
//│ table: List[("one", forall 'a 'b. ('a -> 'b) -> 'a -> 'b,)]
//│ table: List[("one" | "two", forall 'a 'b 'c. ('a -> 'b & 'a -> 'c & 'c -> 'b) -> 'a -> 'b,)]

// let zog =
//   printInt (add (nfind table "one") (nfind table "two"))
:stats
zog = printInt (add (nfind table "one") (nfind table "two"))
//│ zog: string
//│ constrain calls  : 2238
//│ annoying  calls  : 76
//│ subtyping calls  : 13750

// * Some subexpressions typed individually:

:stats
a = add (nfind table "one")
//│ a: ChurchInt -> (('a -> ('a & 'b)) -> 'a -> 'b | ChurchInt)
//│ constrain calls  : 1065
//│ annoying  calls  : 38
//│ subtyping calls  : 6713

:stats
b = (nfind table "two")
//│ b: ('a -> ('b & 'c) & 'c -> 'b & 'a -> ('b & 'd) & 'd -> 'b & 'a -> ('b & 'e) & 'e -> 'b & 'a -> ('b & 'f) & 'f -> 'b & 'a -> ('b & 'g) & 'g -> 'b & 'a -> ('b & 'h) & 'h -> 'b & 'a -> ('b & 'i) & 'i -> 'b & 'a -> ('b & 'j) & 'j -> 'b) -> ('b & 'a) -> 'b
//│ constrain calls  : 401
//│ annoying  calls  : 38
//│ subtyping calls  : 5627

:stats
b (fun x -> x)
//│ res: 'a -> 'a
//│ constrain calls  : 536
//│ annoying  calls  : 0
//│ subtyping calls  : 3647

b (fun x -> x (not x))
//│ res: nothing -> nothing

b (fun x -> 0)
//│ res: 'a -> (0 | 'a)

// * Note: this one required `:DistributeForalls`
:stats
a b
//│ res: ('a -> ('a & 'b)) -> 'a -> 'b | ChurchInt
//│ constrain calls  : 674
//│ annoying  calls  : 0
//│ subtyping calls  : 4208


// * [FCP:patho] !! Note the stats here for this fully annotation-free version
:stats
// ==========================================================================================
:Fuel 20000
zog_ = printInt_ (add_ (nfind table "one") (nfind table "two"))
//│ zog_: string
//│ constrain calls  : 16345
//│ annoying  calls  : 76
//│ subtyping calls  : 70146

:stats
a_ = add_ (nfind table "one")
//│ a_: ('a -> 'b -> 'c & 'a -> 'b -> 'd & 'a -> 'b -> 'e & 'a -> 'b -> 'f & 'a -> 'b -> 'g & 'a -> 'b -> 'h & 'a -> 'b -> 'i & 'a -> 'b -> 'j & 'a -> 'b -> 'k & 'a -> 'b -> 'l & 'a -> 'b -> 'm & 'a -> 'b -> 'n & 'a -> 'b -> 'o & 'a -> 'b -> 'p & 'a -> 'b -> 'q & 'a -> 'b -> 'r & 's) -> (('q -> 't & 'r -> 'u & 'u -> 't & 'o -> 't & 'p -> 'v & 'v -> 't & 'm -> 't & 'n -> 'w & 'w -> 't & 'k -> 't & 'l -> 'x & 'x -> 't & 'i -> 't & 'j -> 'y & 'y -> 't & 'g -> 't & 'h -> 'z & 'z -> 't & 'e -> 't & 'f -> 'a1 & 'a1 -> 't & 'c -> 't & 'd -> 'b1 & 'b1 -> 't & 'a) -> 'b -> 't | 's)
//│ constrain calls  : 1223
//│ annoying  calls  : 38
//│ subtyping calls  : 13520

:stats
a_ b
//│ res: ('a -> ('b & 'c) & 'c -> 'b & 'a -> ('b & 'd) & 'd -> 'b & 'a -> ('b & 'e) & 'e -> 'b & 'a -> ('b & 'f) & 'f -> 'b & 'a -> ('b & 'g) & 'g -> 'b & 'a -> ('b & 'h) & 'h -> 'b & 'a -> ('b & 'i) & 'i -> 'b & 'a -> ('b & 'j) & 'j -> 'b & 'k -> 'l & 'm -> ('k & 'n) & 'n -> 'k & 'o -> 'p & 'm -> ('o & 'q) & 'q -> 'o & 'p -> 'l & 'r -> 'l & 'm -> ('r & 's) & 's -> 'r & 't -> 'u & 'm -> ('t & 'v) & 'v -> 't & 'u -> 'l & 'w -> 'l & 'm -> ('w & 'x) & 'x -> 'w & 'y -> 'z & 'm -> ('y & 'a1) & 'a1 -> 'y & 'z -> 'l & 'b1 -> 'l & 'm -> ('b1 & 'c1) & 'c1 -> 'b1 & 'd1 -> 'e1 & 'm -> ('d1 & 'f1) & 'f1 -> 'd1 & 'e1 -> 'l & 'g1 -> 'l & 'm -> ('g1 & 'h1) & 'h1 -> 'g1 & 'i1 -> 'j1 & 'm -> ('i1 & 'k1) & 'k1 -> 'i1 & 'j1 -> 'l & 'l1 -> 'l & 'm -> ('l1 & 'm1) & 'm1 -> 'l1 & 'n1 -> 'o1 & 'm -> ('n1 & 'p1) & 'p1 -> 'n1 & 'o1 -> 'l & 'q1 -> 'l & 'm -> ('q1 & 'r1) & 'r1 -> 'q1 & 's1 -> 't1 & 'm -> ('s1 & 'u1) & 'u1 -> 's1 & 't1 -> 'l & 'v1 -> 'l & 'm -> ('v1 & 'w1) & 'w1 -> 'v1 & 'x1 -> 'y1 & 'm -> ('x1 & 'z1) & 'z1 -> 'x1 & 'y1 -> 'l) -> ('a & 'k & 'm & 'o & 'r & 't & 'w & 'y & 'b1 & 'd1 & 'g1 & 'i1 & 'l1 & 'n1 & 'q1 & 's1 & 'v1 & 'x1) -> ('a | 'l | 'b)
//│ constrain calls  : 3489
//│ annoying  calls  : 0
//│ subtyping calls  : 137900
:ResetFuel
// ==========================================================================================







