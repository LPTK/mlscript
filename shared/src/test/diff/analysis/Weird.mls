
class Base1[A]
  method M1: A -> Base1[A]
//│ Defined class Base1[-A]
//│ Declared Base1.M1: Base1['A] -> 'A -> Base1['A]


:DistributeForalls

// * See [FIXME:1] — C should NOT be invariant here! (only happens with :DistributeForalls)
// * (Note: `Derived2{}` is not enough to trigger this as it's handled by refined app typing.)
class Derived2[C]: Base1[anything]
  method M1 r = id Derived2 {}
//│ Defined class Derived2[=C]
//│ Defined Derived2.M1: Derived2['C] -> anything -> Derived2['C0]

Derived2.M1
//│ res: Derived2['C] -> (forall 'C0. anything -> Derived2['C0])
//│    = undefined


:DontDistributeForalls

:w
class Derived3[C]: Base1[anything]
  method M1 r = id Derived3 {}
//│ Defined class Derived3[±C]
//│ Defined Derived3.M1: Derived3[?] -> anything -> Derived3[?]
//│ ╔══[WARNING] Type definition Derived3 has bivariant type parameters:
//│ ║  l.25: 	class Derived3[C]: Base1[anything]
//│ ║        	      ^^^^^^^^
//│ ╟── C is irrelevant and may be removed
//│ ║  l.25: 	class Derived3[C]: Base1[anything]
//│ ╙──      	               ^

Derived3.M1
//│ res: Derived3[?] -> anything -> Derived3[?]
//│    = undefined

