:BidirTyping


class A
  method Test = 0
  method Test2 = 0
//│ Defined class A
//│ Defined A.Test: A -> 0
//│ Defined A.Test2: A -> 0

def foooo(x) = x.(A.Test2)
//│ foooo: A -> 0
//│      = [Function: foooo]

class B
  method Test = "ok"
//│ Defined class B
//│ Defined B.Test: B -> "ok"


def foo1(x) = x + 1
//│ foo1: int -> int
//│     = [Function: foo1]

:e
def foo1(x) =
  x.Test
//│ ╔══[ERROR] Implicit call to method Test is forbidden because it is ambiguous.
//│ ║  l.27: 	  x.Test
//│ ║        	  ^^^^^^
//│ ╟── Unrelated methods named Test are defined by:
//│ ╟── • class A
//│ ║  l.4: 	class A
//│ ║       	      ^
//│ ╟── • class B
//│ ║  l.15: 	class B
//│ ╙──      	      ^
//│ foo1: anything -> error
//│     = [Function: foo11]

def foo2(x: A) =
  x.Test
//│ foo2: A -> 0
//│     = [Function: foo2]


def foo2: A -> int
//│ foo2: A -> int
//│     = <missing implementation>

def y : A
def fooo = y.Test
//│ y: A
//│  = <missing implementation>
//│ fooo: 0
//│     = <no result>
//│       y is not implemented

def foo2(x) =
  x.Test
//│ A -> int
//│   <:  foo2:
//│ A -> int
//│     = [Function: foo21]


def foo3(x: B) =
  x.Test
//│ foo3: B -> "ok"
//│     = [Function: foo3]


type T = (A, B)
//│ Defined type alias T

def foo4((x, y): T) =
  (x.Test, y.Test)
//│ foo4: T -> (0, "ok",)
//│     = [Function: foo4]



(fun x -> fun a -> a.Test) 1 : A -> int
//│ res: A -> int
//│    = [Function (anonymous)]


def test: (A -> int) -> int
//│ test: (A -> int) -> int
//│     = <missing implementation>

// * TODO: support
:e
test (fun a -> a.Test)
//│ ╔══[ERROR] Implicit call to method Test is forbidden because it is ambiguous.
//│ ║  l.94: 	test (fun a -> a.Test)
//│ ║        	               ^^^^^^
//│ ╟── Unrelated methods named Test are defined by:
//│ ╟── • class A
//│ ║  l.4: 	class A
//│ ║       	      ^
//│ ╟── • class B
//│ ║  l.15: 	class B
//│ ╙──      	      ^
//│ res: int
//│    = <no result>
//│      test is not implemented

// * FIXME
:e
test (fun a -> a.Test) : int
//│ ╔══[ERROR] Implicit call to method Test is forbidden because it is ambiguous.
//│ ║  l.111: 	test (fun a -> a.Test) : int
//│ ║         	               ^^^^^^
//│ ╟── Unrelated methods named Test are defined by:
//│ ╟── • class A
//│ ║  l.4: 	class A
//│ ║       	      ^
//│ ╟── • class B
//│ ║  l.15: 	class B
//│ ╙──      	      ^
//│ res: int
//│    = <no result>
//│      test is not implemented

// FIXME: should also use `ClassTag`s to disambiguate – also the error is wrong! (should be an ambiguity error)
let x = A{} in x.Test
//│ ╔══[ERROR] Method Test not found
//│ ║  l.127: 	let x = A{} in x.Test
//│ ╙──       	               ^^^^^^
//│ res: error
//│    = 0

let x = A{} : A in x.Test
//│ res: 0
//│    = 0

:e
(fun x -> x.Test) (A{})
//│ ╔══[ERROR] Implicit call to method Test is forbidden because it is ambiguous.
//│ ║  l.139: 	(fun x -> x.Test) (A{})
//│ ║         	          ^^^^^^
//│ ╟── Unrelated methods named Test are defined by:
//│ ╟── • class A
//│ ║  l.4: 	class A
//│ ║       	      ^
//│ ╟── • class B
//│ ║  l.15: 	class B
//│ ╙──      	      ^
//│ res: error
//│    = 0

:e
(fun x -> x.Test) (A{}:A)
//│ ╔══[ERROR] Implicit call to method Test is forbidden because it is ambiguous.
//│ ║  l.154: 	(fun x -> x.Test) (A{}:A)
//│ ║         	          ^^^^^^
//│ ╟── Unrelated methods named Test are defined by:
//│ ╟── • class A
//│ ║  l.4: 	class A
//│ ║       	      ^
//│ ╟── • class B
//│ ║  l.15: 	class B
//│ ╙──      	      ^
//│ res: error
//│    = 0


