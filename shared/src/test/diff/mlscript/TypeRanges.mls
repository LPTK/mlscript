

def set0: MutArray['a..'b] -> 'a -> ()
//│ set0: MutArray['b] -> 'b -> ()
//│     = <missing implementation>

def set1: MutArray['a..'b] -> 'b -> ()
//│ set1: MutArray['b] -> 'b -> ()
//│     = <missing implementation>

def set2: MutArray[int..number] -> int -> ()
//│ set2: MutArray[in number out int] -> int -> ()
//│     = <missing implementation>

:e
def set3: MutArray[number..int] -> 'b -> ()
//│ ╔══[ERROR] Type mismatch in type bounds:
//│ ║  l.16: 	def set3: MutArray[number..int] -> 'b -> ()
//│ ║        	                   ^^^^^^^^^^^
//│ ╟── type `number` is not an instance of `int`
//│ ║  l.16: 	def set3: MutArray[number..int] -> 'b -> ()
//│ ║        	                   ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.16: 	def set3: MutArray[number..int] -> 'b -> ()
//│ ╙──      	                           ^^^
//│ set3: MutArray[in int out number] -> anything -> ()
//│     = <missing implementation>


:ns
fun x -> set2 x 0
//│ res: forall 'a. 'a -> ()
//│   where
//│     'a <: MutArray[in int out number]
//│    = <no result>
//│      set2 is not implemented

// :ns
fun x -> set0 x 0
fun x -> set1 x 0
//│ res: MutArray['b | 0] -> ()
//│    = <no result>
//│      set0 is not implemented
//│ res: MutArray['b | 0] -> ()
//│    = <no result>
//│      set1 is not implemented


def foo: MutArray[int..number]
//│ foo: MutArray[in int out number]
//│    = <missing implementation>

:e
:ng
foo = foo
//│ MutArray[in int out number]
//│   <:  foo:
//│ MutArray[in int out number]

:e
foo = (mut 0,)
//│ (mut 'a,)
//│   where
//│     'a :> 0
//│   <:  foo:
//│ MutArray[in int out number]
//│    = [ 0 ]

:e
set0 foo
//│ res: anything -> ()
//│    = <no result>
//│      set0 is not implemented

:e
set2 foo
//│ res: int -> ()
//│    = <no result>
//│      set2 is not implemented

:e
foo : MutArray['a]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.82: 	foo : MutArray['a]
//│ ║        	^^^
//│ ╟── type `number` is not an instance of `int`
//│ ║  l.49: 	def foo: MutArray[int..number]
//│ ║        	                       ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.49: 	def foo: MutArray[int..number]
//│ ║        	                  ^^^
//│ ╟── from type bounds:
//│ ║  l.49: 	def foo: MutArray[int..number]
//│ ╙──      	                  ^^^^^^^^^^^
//│ res: MutArray['a]
//│   where
//│     'a :> number
//│        <: int
//│    = [ 0 ]

foo : Array['a]
//│ res: Array[nothing]
//│    = [ 0 ]

:e
foo[0] <- 1
//│ = []

foo[0]
//│ res: undefined
//│    = 1

res : number | undefined
//│ res: number | undefined
//│    = 1

foo[0]
//│ res: undefined
//│    = 1

:e
res : int | undefined
//│ res: int | undefined
//│    = 1


:e
foo2 = foo : MutArray['a..'b]
//│ foo2: MutArray['b]
//│     = [ 1 ]

foo2[0]
//│ res: undefined
//│    = 1

:e
res : undefined
//│ res: undefined
//│    = 1


:e
def foo: MutArray[number..int]
//│ ╔══[ERROR] Type mismatch in type bounds:
//│ ║  l.143: 	def foo: MutArray[number..int]
//│ ║         	                  ^^^^^^^^^^^
//│ ╟── type `number` is not an instance of `int`
//│ ║  l.143: 	def foo: MutArray[number..int]
//│ ║         	                  ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.143: 	def foo: MutArray[number..int]
//│ ╙──       	                          ^^^
//│ foo: MutArray[in number out int]
//│    = <missing implementation>

foo = (mut 0,)
//│ (mut 'a,)
//│   where
//│     'a :> 0
//│   <:  foo:
//│ MutArray[in number out int]
//│    = [ 0 ]

foo[0]
//│ res: undefined
//│    = 0

res : int | undefined
//│ res: int | undefined
//│    = 0

foo[0] <- 1
//│ = []

foo[0] <- (1/2)
//│ = []



:ng
bar = if true then error : MutArray[int] else error : MutArray[number]
//│ bar: MutArray[in int out number]

fun x -> (x : MutArray[int], x : MutArray[number])
//│ res: MutArray[in number out int] -> (MutArray[int], MutArray[number],)
//│    = [Function: res]

fun x -> if true then x : MutArray[int] else x : MutArray[number]
//│ res: MutArray[in number out int] -> MutArray[in int out number]
//│    = [Function: res]



// * FIXME
def maf: MutArray[int..number] -> MutArray[int..number]
//│ maf: MutArray[in number out int] -> MutArray[in int out number]
//│    = <missing implementation>
:ns
maf
//│ res: MutArray[in int out number] -> MutArray[in int out number]
//│    = <no result>
//│      maf is not implemented

// :ds
maf
//│ res: MutArray[in number out int] -> MutArray[in int out number]
//│    = <no result>
//│      maf is not implemented


:e
maf ((mut error,))
//│ res: MutArray[in int out number]
//│    = <no result>
//│      maf is not implemented

:e
fun x -> maf ((mut x,))
//│ res: anything -> MutArray[in int out number]
//│    = <no result>
//│      maf is not implemented

maf error
//│ res: MutArray[in int out number]
//│    = <no result>
//│      maf is not implemented


:e
def maf: MutArray[number..int] -> MutArray[int..number]
//│ ╔══[ERROR] Type mismatch in type bounds:
//│ ║  l.230: 	def maf: MutArray[number..int] -> MutArray[int..number]
//│ ║         	                  ^^^^^^^^^^^
//│ ╟── type `number` is not an instance of `int`
//│ ║  l.230: 	def maf: MutArray[number..int] -> MutArray[int..number]
//│ ║         	                  ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.230: 	def maf: MutArray[number..int] -> MutArray[int..number]
//│ ╙──       	                          ^^^
//│ maf: MutArray[in int out number] -> MutArray[in int out number]
//│    = <missing implementation>

maf ((mut error,))
fun x -> maf ((mut x,))
//│ res: MutArray[in int out number]
//│    = <no result>
//│      maf is not implemented
//│ res: anything -> MutArray[in int out number]
//│    = <no result>
//│      maf is not implemented




type R[A] = { get: A; set: A -> () }
//│ Defined type alias R[=A]

def foo: R[int..number]
foo = { get = 0; set = fun n -> () }
//│ foo: R[in int out number]
//│    = <missing implementation>
//│ {get: 0, set: anything -> ()}
//│   <:  foo:
//│ R[in int out number]
//│    = { get: 0, set: [Function: set] }

foo.get
//│ res: nothing
//│    = 0

:e
foo: R['a]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.272: 	foo: R['a]
//│ ║         	^^^
//│ ╟── type `number` is not an instance of `int`
//│ ║  l.258: 	def foo: R[int..number]
//│ ║         	                ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.258: 	def foo: R[int..number]
//│ ║         	           ^^^
//│ ╟── from type bounds:
//│ ║  l.258: 	def foo: R[int..number]
//│ ╙──       	           ^^^^^^^^^^^
//│ res: R['a]
//│   where
//│     'a :> error | number
//│        <: int
//│    = { get: 0, set: [Function: set] }

:e
foo: R['a..'b]
//│ res: R['b]
//│    = { get: 0, set: [Function: set] }

// * FIXME
res.get
//│ res: nothing
//│    = 0

type S[A] = { get: A; set: A -> () }
//│ Defined type alias S[=A]

:e
foo: S['a]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.305: 	foo: S['a]
//│ ║         	^^^
//│ ╟── type `number` is not an instance of `int`
//│ ║  l.258: 	def foo: R[int..number]
//│ ║         	                ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.258: 	def foo: R[int..number]
//│ ║         	           ^^^
//│ ╟── from type bounds:
//│ ║  l.258: 	def foo: R[int..number]
//│ ╙──       	           ^^^^^^^^^^^
//│ res: S['a]
//│   where
//│     'a :> error | number
//│        <: int
//│    = { get: 0, set: [Function: set] }

:e
foo: S['a..'b]
//│ res: S['b]
//│    = { get: 0, set: [Function: set] }

foo: { get: number; set: int -> () }
//│ res: {get: number, set: int -> ()}
//│    = { get: 0, set: [Function: set] }

:e
foo: { get: int }
//│ res: {get: int}
//│    = { get: 0, set: [Function: set] }

:e
foo: { set: number -> () }
//│ res: {set: number -> ()}
//│    = { get: 0, set: [Function: set] }

foo2 = foo: { get: 'a; set: 'b -> () }
//│ foo2: {get: number, set: int -> ()}
//│     = { get: 0, set: [Function: set] }

:e
foo2: S['a]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.348: 	foo2: S['a]
//│ ║         	^^^^
//│ ╟── type `number` is not an instance of `int`
//│ ║  l.258: 	def foo: R[int..number]
//│ ║         	                ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.258: 	def foo: R[int..number]
//│ ║         	           ^^^
//│ ╟── from type variable:
//│ ║  l.343: 	foo2 = foo: { get: 'a; set: 'b -> () }
//│ ╙──       	                            ^^
//│ res: S['a]
//│   where
//│     'a :> error | number
//│        <: int
//│    = { get: 0, set: [Function: set] }

:e
foo2: S['a..'b]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.368: 	foo2: S['a..'b]
//│ ║         	^^^^
//│ ╟── type `number` is not an instance of `int`
//│ ║  l.258: 	def foo: R[int..number]
//│ ║         	                ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.258: 	def foo: R[int..number]
//│ ║         	           ^^^
//│ ╟── from type variable:
//│ ║  l.343: 	foo2 = foo: { get: 'a; set: 'b -> () }
//│ ╙──       	                            ^^
//│ res: S['b | number]
//│    = { get: 0, set: [Function: set] }


{ a = 0 } : { a: 'a..'b }
//│ res: {a: nothing}
//│    = { a: 0 }


def maf: { get: int..number; set: (int..number) -> () } -> { get: int..number; set: (int..number) -> () }
//│ maf: {get: int, set: number -> ()} -> {get: number, set: int -> ()}
//│    = <missing implementation>



