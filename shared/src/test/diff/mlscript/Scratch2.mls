:NoRecursiveTypes
// :GeneralizeCurriedFunctions
:NoConstrainedTypes
:DontDistributeForalls


error: 'a -> 'b : forall 'c. 'c -> 'c
//│ res: 'c -> 'c
//│ Runtime error:
//│   Error: unexpected runtime error

def foo(a, b) = (a, b) : forall 'c. ('c, 'c)
//│ foo: (‘c_35_36, ‘c_35_37,) -> (forall 'c. ('c, 'c,))
//│    = [Function: foo]

foo(error, error)
//│ res: ('c, 'c,)
//│ Runtime error:
//│   Error: unexpected runtime error

def foo(a, b) = (a, b) : forall 'c. ('c, 'c -> 'c)
//│ foo: (‘c_54_55, ‘c_54_56 -> ‘c_54_56,) -> (forall 'c. ('c, 'c -> 'c,))
//│    = [Function: foo1]

def foo(a, b) = (a, b) : forall 'c. ('c -> 'c, 'c -> 'c)
//│ foo: (‘c_66_67 -> ‘c_66_67, ‘c_66_68 -> ‘c_66_68,) -> (forall 'c. ('c -> 'c, 'c -> 'c,))
//│    = [Function: foo2]

foo(id, id)
//│ res: ('c -> 'c, 'c -> 'c,)
//│    = [ [Function: id], [Function: id] ]


def foo(f) = (fun a -> f a) : forall 'c. 'c -> 'c
//│ foo: (‘c_88_89 -> ‘c_88_90) -> (forall 'c. 'c -> 'c)
//│    = [Function: foo3]

// foo(id)
// foo(fun f -> f)


def foo(a, b) = let tmp = (a, b) : forall 'c. ('c -> 'c, 0) in a
//│ foo: (‘c_101_102 -> ‘c_101_102 & 'a, 0,) -> 'a
//│    = [Function: foo4]

foo(id, 0)
//│ res: 'a -> 'a
//│    = [Function: id]

foo(fun x -> foo(fun y -> x, 0) x, 0)
//│ res: (‘c_101_102 & 'a) -> 'a
//│    = [Function (anonymous)]


def foo((a, b) : forall 'c. ('c -> 'c, 0)) = ()
//│ foo: (forall 'c. ('c -> 'c, 0,)) -> ()
//│    = [Function: foo5]

foo((id, 0))
//│ res: ()
//│    = []

:e
foo((fun x -> foo((fun y -> x, 0)), 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.64: 	foo((fun x -> foo((fun y -> x, 0)), 0))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘c_163` is not an instance of type `'c_157_159`
//│ ║  l.55: 	def foo((a, b) : forall 'c. ('c -> 'c, 0)) = ()
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.55: 	def foo((a, b) : forall 'c. ('c -> 'c, 0)) = ()
//│ ║        	                        ^^
//│ ╟── from reference:
//│ ║  l.64: 	foo((fun x -> foo((fun y -> x, 0)), 0))
//│ ╙──      	                            ^
//│ res: error
//│    = []


// def oops (i: forall 'a. 'a -> 'a) =
//   let _ = (i id) "hello"
//   in i

// def extrude f = let tmp = (f, 0) : forall 'c. ('c -> 'c, 0) in oops tmp._1

def oops (i: forall 'c. ('c -> 'c, 0)) =
  let _ = (i._1 id) "hello"
  in i._1
//│ oops: (forall 'c. ('c -> 'c, 0,)) -> 'c0 -> 'c0
//│     = [Function: oops]

def oops (i: forall 'c. ('c -> 'c, 0)) =
  let _ = log "Hi!"
  in (fun ((f, 0)) ->
    let _ = log f
    in let r = (f id) "hello"
    in let _ = log r
    in f) i
//│ oops: (forall 'c. ('c -> 'c, 0,)) -> ("hello" -> anything & 'c0) -> (forall 'c0, 'a. 'c0 | 'a -> 'a)
//│     = [Function: oops1]

def oops (i: forall 'c. ('c -> 'c, 0)) =
  let _ = log "Hi!"
  in let _ = (fun ((f, 0)) ->
    let _ = log f
    in let r = (f id) "hello"
    in log r) i
  in (fun ((f, 0)) -> f) i
//│ oops: (forall 'c. ('c -> 'c, 0,)) -> 'c0 -> 'c0
//│     = [Function: oops2]

// * Type?!
def extrude f = oops((f, 0))._1
//│ extrude: (forall 'c. ('c -> 'c, 0,)) -> 'c0 -> 'c0
//│        = [Function: extrude]

def extrude f = oops((f, 0))
//│ extrude: (‘c_255_256 -> ‘c_255_256) -> 'c -> 'c
//│        = [Function: extrude1]

extrude(id)
//│ res: 'c -> 'c
//│    = [Function: id]
//│ // Output
//│ Hi!
//│ [Function: id]
//│ hello

extrude(id)(42)
//│ res: 42
//│    = 42
//│ // Output
//│ Hi!
//│ [Function: id]
//│ hello

// extrude(id)(id)(42)



// :e
f = extrude (fun x -> extrude (fun y -> x) x)
//│ f: 'c -> 'c
//│  = [Function (anonymous)]
//│ // Output
//│ Hi!
//│ [Function (anonymous)]
//│ Hi!
//│ [Function (anonymous)]
//│ hello
//│ hello

:re
f 42 // Boom!
//│ res: 42
//│ Runtime error:
//│   TypeError: f(...) is not a function
//│ // Output
//│ Hi!
//│ [Function (anonymous)]




