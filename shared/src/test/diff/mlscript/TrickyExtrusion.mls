
// From SuperType tests

True = true
//│ True: true
//│     = true

def inc: int -> int
//│ inc: int -> int
//│    = <missing implementation>

test f =
  let r = fun x -> fun g -> (g x, )
  in (r 0 inc, r True not)
//│ test: anything -> ((int,), (bool,),)
//│     = <no result>
//│       inc is not implemented

// * Precise type:
test f = (f 0, f True)
//│ test: (0 -> 'a & true -> 'b) -> ('a, 'b,)
//│     = [Function: test]

// * Imprecise type (notice the `(0 | true)`):
// * Note: With inferred first-class constrained types and generalized curried functions,
// *  this approximation be avoided (see below).
test f =
  let r x = f x
  in (r 0, r True)
//│ test: (nothing -> anything) -> (nothing, nothing,)
//│     = [Function: test1]

// Same example, a little elaborated
test f =
  let r = fun x -> fun g -> (g x, f x)
  in (r 0 inc, r True not)
//│ test: (nothing -> anything) -> ((int, nothing,), (bool, nothing,),)
//│     = <no result>
//│       inc is not implemented




:GeneralizeCurriedFunctions



// * Note the still approximative type due to extrusion
test f =
  let r x = f x
  in (r 0, r True)
//│ test: (nothing -> anything) -> (nothing, nothing,)
//│     = [Function: test2]

:e // * Due to lack of precision
(test id)._1 + 1
//│ res: int
//│    = NaN

:e // * Due to lack of precision
not (test id)._2
//│ res: bool
//│    = true

:e // * Legit
not (test id)._1
//│ res: bool
//│    = true





// * === With Constrained Types ===

:DontDistributeForalls
:ConstrainedTypes



// * Note the precise type now
:ns
test f =
  let r x = f x
  in (r 0, r True)
//│ test: anything -> (nothing, nothing,)
//│     = [Function: test3]

// * Q: why does this type *appear* approximated after simplification?
test
//│ res: anything -> (nothing, nothing,)
//│    = [Function: test3]

// * We can tell the type is still precise enough because these work:

(test id)._1 + 1
//│ res: int
//│    = NaN

not (test id)._2
//│ res: bool
//│    = true

:e // * Legit
not (test id)._1
//│ res: bool
//│    = true


// * Note: works with dummy recursive definition (we used to have some hacks for rec defns)
rec def test f =
  let r x = f x
  in (r 0, r True)
//│ test: anything -> (nothing, nothing,)
//│     = [Function: test4]


