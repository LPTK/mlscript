:NoJS


// :stdout
// :s
// :d
// :ds
def f: { x: 'a } as 'a
//│ f: in {x: anything} out {x: nothing}


// :stdout
// :s
// :d
// :ds
rec def l x = l
//│ l: anything -> nothing

l
//│ res: anything -> nothing

:ns
m y = l y
//│ m: forall 'a. anything -> 'a
//│   where
//│     'a :> in anything out nothing

m
//│ res: anything -> nothing


fun a -> a a
//│ res: (nothing -> 'a) -> 'a


// :stdout
// :s
// :d
// :ds
:e
rec def f a = a a
//│ ('a -> 'b & 'a) -> 'b
//│   <:  f:
//│ {x: nothing}
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.50: 	rec def f a = a a
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` does not have field 'x'
//│ ║  l.50: 	rec def f a = a a
//│ ║        	          ^^^^^^^
//│ ╟── Note: constraint arises from record type:
//│ ║  l.8: 	def f: { x: 'a } as 'a
//│ ╙──     	       ^^^^^^^^^


// :stdout
// :s
// :d
// :ds
rec def g a = a a
//│ g: ('a -> 'b & 'a) -> 'b


// :ds
def ite x y z = if x then y else z
//│ ite: bool -> 'a -> 'a -> 'a



class Some[A]: { v: A }
//│ Defined class Some[+A]

def Some v = Some{v}
//│ Some: 'v -> Some['v]


def foo(x: Some['a]) =
  let _ = x.v : Some[?]
  in x: Some['a & some]
//│ foo: Some[Some[nothing] & 'a] -> Some[Some[?] & 'a]

def f: Some['a]
//│ f: Some[nothing]



def foo(x: 'a) = (x + 1, x)
//│ foo: (int & 'a) -> (int, 'a,)

// * NOTE: currently each parameter type is typed independently – so these 'a are different!
def foo(x: 'a, y: 'a) = (x + 1, y)
//│ foo: (int, 'a,) -> (int, 'a,)

def foo(f: 'a -> 'a, x: 'a) =
  let _ = x + 1
  in error: Some['a & some]
//│ foo: ('a -> 'a, int,) -> Some[nothing]


