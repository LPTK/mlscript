

:d
def o = (fun x -> x x)
//│ 1. Typing term '(' (x,) => x (x,) ')'
//│ | 1. Typing term (x,) => x (x,)
//│ | | TYPING POLY LAM
//│ | | 2. Typing pattern x,
//│ | | | 2. Typing pattern x
//│ | | | 2. : x8''
//│ | | 2. : (x8'',)
//│ | | 2. Typing term x (x,)
//│ | | | 2. Typing term x
//│ | | | 2. : x8''
//│ | | | 2. Typing term x
//│ | | | 2. : x8''
//│ | | | CONSTRAIN x8'' <! (x8'' -> α9'')
//│ | | |   where 
//│ | | | 2. C x8'' <! (x8'' -> α9'')    (0)
//│ | | | | NEW x8'' UB (2)
//│ | | 2. : α9''
//│ | | Inferred poly constr: (x8'' -> α9'')  —— where 
//│ 		x8'' <: (x8'' -> α9'')
//│ | | 1. Online simplification
//│ | | | Analysis[+] (x8'' -> α9'')  []
//│ | | | | Analysis[-] (x8'',)  []
//│ | | | | | Analysis[-] x8''  []
//│ | | | | | | !! x8'' Some(false) List((x8'' -> α9''))
//│ | | | | | | Analysis[-] (x8'' -> α9'')  [x8'']
//│ | | | | | | | Analysis[+] (x8'',)  []
//│ | | | | | | | | Analysis[+] x8''  []
//│ | | | | | | | | | REC x8''
//│ | | | | | | | Analysis[-] α9''  []
//│ | | | | | | | | !! α9'' Some(false) List()
//│ | | | | Analysis[+] α9''  []
//│ | | | | | !! α9'' Some(true) List()
//│ | | | Unif-pre: HashMap()
//│ | | | Pos: HashSet(α9'')
//│ | | | Neg: HashSet(x8'', α9'')
//│ | | | Rec: HashSet(x8'')
//│ | | | Unif: HashMap()
//│ | | | subst((x8'' -> α9''))
//│ | | | | subst((x8'',))
//│ | | | | | subst(x8'')
//│ | | | | | | Repr: x8''
//│ | | | | | | It's recursive!
//│ | | | | | | subst((x8'' -> α9''))
//│ | | | | | | | subst((x8'',))
//│ | | | | | | | | subst(x8'')
//│ | | | | | | | | | Repr: x8''
//│ | | | | | | | | = x8''
//│ | | | | | | | = (x8'',)
//│ | | | | | | | subst(α9'')
//│ | | | | | | | | Repr: α9''
//│ | | | | | | | = α9''
//│ | | | | | | = (x8'' -> α9'')
//│ | | | | | = x8''
//│ | | | | = (x8'',)
//│ | | | | subst(α9'')
//│ | | | | | Repr: α9''
//│ | | | | = α9''
//│ | | | = (x8'' -> α9'')
//│ | | 1. Simplified: (x8'' -> α9'') where 
//│ 		x8'' <: (x8'' -> α9'')
//│ | | UNSTASHING... (out)
//│ | 1. : ‹∀ 1. (x8'' -> α9'')›
//│ 1. : ‹∀ 1. (x8'' -> α9'')›
//│ UNSTASHING... (out)
//│ Inferred let-bound term type: ‹∀ 1. (x8'' -> α9'')› where 
//│ 		x8'' <: (x8'' -> α9'')
//│ 0. Online simplification
//│ | Analysis[+] ‹∀ 1. (x8'' -> α9'')›  []
//│ | Unif-pre: HashMap()
//│ | Pos: HashSet()
//│ | Neg: HashSet()
//│ | Rec: HashSet()
//│ | Unif: HashMap()
//│ | subst(‹∀ 1. (x8'' -> α9'')›)
//│ | = ‹∀ 1. (x8'' -> α9'')›
//│ 0. Simplified: ‹∀ 1. (x8'' -> α9'')› where 
//│ 		x8'' <: (x8'' -> α9'')
//│ ⬤ Typed as: ‹∀ 1. (x8'' -> α9'')›
//│  where: 
//│ 		x8'' <: (x8'' -> α9'')
//│ o: ('x -> 'a & 'x) -> 'a
//│  = [Function: o]


:e
:d
o o
//│ 0. Typing term o (o,)
//│ | 0. Typing term o
//│ | 0. : ‹∀ 1. (x8'' -> α9'')›
//│ | 0. Typing term o
//│ | 0. : ‹∀ 1. (x8'' -> α9'')›
//│ | CONSTRAIN ‹∀ 1. (x8'' -> α9'')› <! (‹∀ 1. (x8'' -> α9'')› -> α16)
//│ |   where 
//│ 		x8'' <: (x8'' -> α9'')
//│ | 0. C ‹∀ 1. (x8'' -> α9'')› <! (‹∀ 1. (x8'' -> α9'')› -> α16)    (0)
//│ | | could be distribbed: Set(α9'')
//│ | | cannot be distribbed: Set(x8'', α9'')
//│ | | INST [1]   ‹∀ 1. (x8'' -> α9'')›
//│ | |   where  
//│ 		x8'' <: (x8'' -> α9'')
//│ | | TO [0] ~>  (x8_17 -> α9_18)
//│ | |   where  
//│ 		x8_17 <: (x8_17 -> α9_18)
//│ | | 0. C (x8_17 -> α9_18) <! (‹∀ 1. (x8'' -> α9'')› -> α16)    (2)
//│ | | | 0. C (‹∀ 1. (x8'' -> α9'')›,) <! (x8_17,)    (2)
//│ | | | | 0. C ‹∀ 1. (x8'' -> α9'')› <! x8_17    (3)
//│ | | | | | NEW x8_17 LB (0)
//│ | | | | | 0. C ‹∀ 1. (x8'' -> α9'')› <! (x8_17 -> α9_18)    (6)
//│ | | | | | | could be distribbed: Set(α9'')
//│ | | | | | | cannot be distribbed: Set(x8'', α9'')
//│ | | | | | | INST [1]   ‹∀ 1. (x8'' -> α9'')›
//│ | | | | | |   where  
//│ 		x8'' <: (x8'' -> α9'')
//│ | | | | | | TO [0] ~>  (x8_19 -> α9_20)
//│ | | | | | |   where  
//│ 		x8_19 <: (x8_19 -> α9_20)
//│ | | | | | | 0. C (x8_19 -> α9_20) <! (x8_17 -> α9_18)    (9)
//│ | | | | | | | 0. C (x8_17,) <! (x8_19,)    (6)
//│ | | | | | | | | 0. C x8_17 <! x8_19    (7)
//│ | | | | | | | | | NEW x8_17 UB (0)
//│ | | | | | | | | | 0. C ‹∀ 1. (x8'' -> α9'')› <! x8_19    (10)
//│ | | | | | | | | | | SHADOWING DETECTED!
//│ | | | | | | | | | | CONSTRAIN error<> <! α16
//│ | | | | | | | | | |   where 
//│ | | | | | | | | | | 0. C error<> <! α16    (0)
//│ | | | | | | | | | | | NEW α16 LB (0)
//│ | | | | | | | 0. C α9_20 <! α9_18    (6)
//│ | | | | | | | | NEW α9_20 UB (0)
//│ | | | 0. C α9_18 <! α16    (2)
//│ | | | | NEW α9_18 UB (0)
//│ 0. : α16
//│ ⬤ Typed as: α16
//│  where: 
//│ 		α16 :> error<>
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.91: 	o o
//│ ║        	^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ res: error
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded


:d
def foo x = x.a
//│ 1. Typing term (x,) => (x).a
//│ | TYPING POLY LAM
//│ | 2. Typing pattern x,
//│ | | 2. Typing pattern x
//│ | | 2. : x22''
//│ | 2. : (x22'',)
//│ | 2. Typing term (x).a
//│ | | 2. Typing term x
//│ | | 2. : x22''
//│ | | CONSTRAIN x22'' <! {a: a23''}
//│ | |   where 
//│ | | 2. C x22'' <! {a: a23''}    (0)
//│ | | | NEW x22'' UB (2)
//│ | 2. : a23''
//│ | Inferred poly constr: (x22'' -> a23'')  —— where 
//│ 		x22'' <: {a: a23''}
//│ | 1. Online simplification
//│ | | Analysis[+] (x22'' -> a23'')  []
//│ | | | Analysis[-] (x22'',)  []
//│ | | | | Analysis[-] x22''  []
//│ | | | | | !! x22'' Some(false) List({a: a23''})
//│ | | | | | Analysis[-] {a: a23''}  [x22'']
//│ | | | | | | Analysis[-] a23''  []
//│ | | | | | | | !! a23'' Some(false) List()
//│ | | | Analysis[+] a23''  []
//│ | | | | !! a23'' Some(true) List()
//│ | | Unif-pre: HashMap()
//│ | | Pos: HashSet(a23'')
//│ | | Neg: HashSet(x22'', a23'')
//│ | | Rec: HashSet()
//│ | | Unif: HashMap()
//│ | | subst((x22'' -> a23''))
//│ | | | subst((x22'',))
//│ | | | | subst(x22'')
//│ | | | | | Repr: x22''
//│ | | | | | subst({a: a23''})
//│ | | | | | | subst(a23'')
//│ | | | | | | | Repr: a23''
//│ | | | | | | = a23''
//│ | | | | | = {a: a23''}
//│ | | | | = x22''
//│ | | | = (x22'',)
//│ | | | subst(a23'')
//│ | | | | Repr: a23''
//│ | | | = a23''
//│ | | = (x22'' -> a23'')
//│ | 1. Simplified: (x22'' -> a23'') where 
//│ 		x22'' <: {a: a23''}
//│ | UNSTASHING... (out)
//│ 1. : ‹∀ 1. (x22'' -> a23'')›
//│ UNSTASHING... (out)
//│ Inferred let-bound term type: ‹∀ 1. (x22'' -> a23'')› where 
//│ 		x22'' <: {a: a23''}
//│ 0. Online simplification
//│ | Analysis[+] ‹∀ 1. (x22'' -> a23'')›  []
//│ | Unif-pre: HashMap()
//│ | Pos: HashSet()
//│ | Neg: HashSet()
//│ | Rec: HashSet()
//│ | Unif: HashMap()
//│ | subst(‹∀ 1. (x22'' -> a23'')›)
//│ | = ‹∀ 1. (x22'' -> a23'')›
//│ 0. Simplified: ‹∀ 1. (x22'' -> a23'')› where 
//│ 		x22'' <: {a: a23''}
//│ ⬤ Typed as: ‹∀ 1. (x22'' -> a23'')›
//│  where: 
//│ 		x22'' <: {a: a23''}
//│ foo: {a: 'a} -> 'a
//│    = [Function: foo]

:d
def foo x = id x
//│ 1. Typing term (x,) => id (x,)
//│ | TYPING POLY LAM
//│ | 2. Typing pattern x,
//│ | | 2. Typing pattern x
//│ | | 2. : x28''
//│ | 2. : (x28'',)
//│ | 2. Typing term id (x,)
//│ | | 2. Typing term id
//│ | | 2. : ‹∀ 0. (α5' -> α5')›
//│ | | 2. Typing term x
//│ | | 2. : x28''
//│ | | CONSTRAIN ‹∀ 0. (α5' -> α5')› <! (x28'' -> α29'')
//│ | |   where 
//│ | | 2. C ‹∀ 0. (α5' -> α5')› <! (x28'' -> α29'')    (0)
//│ | | | could be distribbed: Set(α5')
//│ | | | cannot be distribbed: Set(α5')
//│ | | | INST [0]   ‹∀ 0. (α5' -> α5')›
//│ | | |   where  
//│ | | | TO [2] ~>  (α5_30'' -> α5_30'')
//│ | | |   where  
//│ | | | 2. C (α5_30'' -> α5_30'') <! (x28'' -> α29'')    (2)
//│ | | | | 2. C (x28'',) <! (α5_30'',)    (2)
//│ | | | | | 2. C x28'' <! α5_30''    (3)
//│ | | | | | | NEW x28'' UB (2)
//│ | | | | 2. C α5_30'' <! α29''    (2)
//│ | | | | | NEW α5_30'' UB (2)
//│ | 2. : α29''
//│ | Inferred poly constr: (x28'' -> α29'')  —— where 
//│ 		x28'' <: α5_30''
//│ 		α5_30'' <: α29''
//│ | 1. Online simplification
//│ | | Analysis[+] (x28'' -> α29'')  []
//│ | | | Analysis[-] (x28'',)  []
//│ | | | | Analysis[-] x28''  []
//│ | | | | | !! x28'' Some(false) List(α5_30'')
//│ | | | | | Analysis[-] α5_30''  [x28'']
//│ | | | | | | !! α5_30'' Some(false) List(α29'')
//│ | | | | | | Analysis[-] α29''  [x28'' ~> α5_30'']
//│ | | | | | | | !! α29'' Some(false) List()
//│ | | | Analysis[+] α29''  []
//│ | | | | !! α29'' Some(true) List()
//│ | | Unif-pre: HashMap()
//│ | | Pos: HashSet(α29'')
//│ | | Neg: HashSet(x28'', α29'', α5_30'')
//│ | | Rec: HashSet()
//│ | | Unif: HashMap()
//│ | | subst((x28'' -> α29''))
//│ | | | subst((x28'',))
//│ | | | | subst(x28'')
//│ | | | | | Repr: x28''
//│ | | | | | subst(α5_30'')
//│ | | | | | | Repr: α5_30''
//│ | | | | | | subst(α29'')
//│ | | | | | | | Repr: α29''
//│ | | | | | | = α29''
//│ | | | | | = α29''
//│ | | | | = α29''
//│ | | | = (α29'',)
//│ | | | subst(α29'')
//│ | | | | Repr: α29''
//│ | | | = α29''
//│ | | = (α29'' -> α29'')
//│ | 1. Simplified: (α29'' -> α29'') where 
//│ | UNSTASHING... (out)
//│ 1. : ‹∀ 1. (α29'' -> α29'')›
//│ UNSTASHING... (out)
//│ Inferred let-bound term type: ‹∀ 1. (α29'' -> α29'')› where 
//│ 0. Online simplification
//│ | Analysis[+] ‹∀ 1. (α29'' -> α29'')›  []
//│ | Unif-pre: HashMap()
//│ | Pos: HashSet()
//│ | Neg: HashSet()
//│ | Rec: HashSet()
//│ | Unif: HashMap()
//│ | subst(‹∀ 1. (α29'' -> α29'')›)
//│ | = ‹∀ 1. (α29'' -> α29'')›
//│ 0. Simplified: ‹∀ 1. (α29'' -> α29'')› where 
//│ ⬤ Typed as: ‹∀ 1. (α29'' -> α29'')›
//│  where: 
//│ foo: 'a -> 'a
//│    = [Function: foo1]

:d
def foo() = id : 'a -> 'a
//│ 1. Typing term () => id : 'a -> 'a
//│ | TYPING POLY LAM
//│ | 2. Typing pattern 
//│ | 2. : ()
//│ | 2. Typing term id : 'a -> 'a
//│ | | 2. Typing term id
//│ | | 2. : ‹∀ 0. (α5' -> α5')›
//│ | | Typing type 'a -> 'a
//│ | | | vars=Map() newDefsInfo=Map()
//│ | | | 2. type 'a -> 'a
//│ | | | | 2. type ('a,)
//│ | | | | | 2. type 'a
//│ | | | | | => 'a34''
//│ | | | | => ('a34'',)
//│ | | | | 2. type 'a
//│ | | | | => 'a34''
//│ | | | => ('a34'' -> 'a34'')
//│ | | => ('a34'' -> 'a34'') ——— 'a34''
//│ | | CONSTRAIN ‹∀ 0. (α5' -> α5')› <! ('a34'' -> 'a34'')
//│ | |   where 
//│ | | 2. C ‹∀ 0. (α5' -> α5')› <! ('a34'' -> 'a34'')    (0)
//│ | | | could be distribbed: Set(α5')
//│ | | | cannot be distribbed: Set(α5')
//│ | | | INST [0]   ‹∀ 0. (α5' -> α5')›
//│ | | |   where  
//│ | | | TO [2] ~>  (α5_35'' -> α5_35'')
//│ | | |   where  
//│ | | | 2. C (α5_35'' -> α5_35'') <! ('a34'' -> 'a34'')    (2)
//│ | | | | 2. C ('a34'',) <! (α5_35'',)    (2)
//│ | | | | | 2. C 'a34'' <! α5_35''    (3)
//│ | | | | | | NEW 'a34'' UB (2)
//│ | | | | 2. C α5_35'' <! 'a34''    (2)
//│ | | | | | NEW α5_35'' UB (2)
//│ | 2. : ('a34'' -> 'a34'')
//│ | Inferred poly constr: (() -> ('a34'' -> 'a34''))  —— where 
//│ 		'a34'' <: α5_35''
//│ 		α5_35'' <: 'a34''
//│ | 1. Online simplification
//│ | | Analysis[+] (() -> ('a34'' -> 'a34''))  []
//│ | | | Analysis[-] ()  []
//│ | | | Analysis[+] ('a34'' -> 'a34'')  []
//│ | | | | Analysis[-] ('a34'',)  []
//│ | | | | | Analysis[-] 'a34''  []
//│ | | | | | | !! 'a34'' Some(false) List(α5_35'')
//│ | | | | | | Analysis[-] α5_35''  ['a34'']
//│ | | | | | | | !! α5_35'' Some(false) List('a34'')
//│ | | | | | | | Analysis[-] 'a34''  ['a34'' ~> α5_35'']
//│ | | | | | | | | UNIFYING 'a34'' with α5_35''
//│ | | | | | | | | HashMap(α5_35'' -> 'a34'')
//│ | | | | Analysis[+] 'a34''  []
//│ | | | | | !! 'a34'' Some(true) List(α5_35'')
//│ | | Unif-pre: HashMap(α5_35'' -> 'a34'')
//│ | | Pos: HashSet('a34'')
//│ | | Neg: HashSet('a34'', α5_35'')
//│ | | Rec: HashSet()
//│ | | Unif: HashMap(α5_35'' -> 'a34'')
//│ | | subst((() -> ('a34'' -> 'a34'')))
//│ | | | subst(())
//│ | | | = ()
//│ | | | subst(('a34'' -> 'a34''))
//│ | | | | subst(('a34'',))
//│ | | | | | subst('a34'')
//│ | | | | | | Repr: 'a34''
//│ | | | | | | subst(α5_35'')
//│ | | | | | | | Repr: 'a34''
//│ | | | | | | = ⊤..⊥
//│ | | | | | = 'a34''
//│ | | | | = ('a34'',)
//│ | | | | subst('a34'')
//│ | | | | | Repr: 'a34''
//│ | | | | = 'a34''
//│ | | | = ('a34'' -> 'a34'')
//│ | | = (() -> ('a34'' -> 'a34''))
//│ | 1. Simplified: (() -> ('a34'' -> 'a34'')) where 
//│ 		'a34'' <: ⊤..⊥
//│ | UNSTASHING... (out)
//│ 1. : ‹∀ 1. (() -> ('a34'' -> 'a34''))›
//│ UNSTASHING... (out)
//│ Inferred let-bound term type: ‹∀ 1. (() -> ('a34'' -> 'a34''))› where 
//│ 		'a34'' <: ⊤..⊥
//│ 0. Online simplification
//│ | Analysis[+] ‹∀ 1. (() -> ('a34'' -> 'a34''))›  []
//│ | Unif-pre: HashMap()
//│ | Pos: HashSet()
//│ | Neg: HashSet()
//│ | Rec: HashSet()
//│ | Unif: HashMap()
//│ | subst(‹∀ 1. (() -> ('a34'' -> 'a34''))›)
//│ | = ‹∀ 1. (() -> ('a34'' -> 'a34''))›
//│ 0. Simplified: ‹∀ 1. (() -> ('a34'' -> 'a34''))› where 
//│ 		'a34'' <: ⊤..⊥
//│ ⬤ Typed as: ‹∀ 1. (() -> ('a34'' -> 'a34''))›
//│  where: 
//│ 		'a34'' <: ⊤..⊥
//│ foo: () -> 'a -> 'a
//│    = [Function: foo2]


:d
rec def foo x = foo x.a
//│ 1. Typing term (x,) => foo ((x).a,)
//│ | 1. Typing pattern x,
//│ | | 1. Typing pattern x
//│ | | 1. : x40'
//│ | 1. : (x40',)
//│ | 1. Typing term foo ((x).a,)
//│ | | 1. Typing term foo
//│ | | 1. : foo39'
//│ | | 1. Typing term (x).a
//│ | | | 1. Typing term x
//│ | | | 1. : x40'
//│ | | | CONSTRAIN x40' <! {a: a41'}
//│ | | |   where 
//│ | | | 1. C x40' <! {a: a41'}    (0)
//│ | | | | NEW x40' UB (1)
//│ | | 1. : a41'
//│ | | CONSTRAIN foo39' <! (a41' -> α42')
//│ | |   where 
//│ | | 1. C foo39' <! (a41' -> α42')    (0)
//│ | | | NEW foo39' UB (1)
//│ | 1. : α42'
//│ 1. : (x40' -> α42')
//│ CONSTRAIN (x40' -> α42') <! foo39'
//│   where 
//│ 		foo39' <: (a41' -> α42')
//│ 		x40' <: {a: a41'}
//│ 1. C (x40' -> α42') <! foo39'    (0)
//│ | NEW foo39' LB (1)
//│ | 1. C (x40' -> α42') <! (a41' -> α42')    (2)
//│ | | 1. C (a41',) <! (x40',)    (2)
//│ | | | 1. C a41' <! x40'    (3)
//│ | | | | NEW a41' UB (1)
//│ | | 1. C α42' <! α42'    (2)
//│ | | | Already a subtype by <:<
//│ UNSTASHING... (out)
//│ Inferred let-bound term type: foo39'# where 
//│ 		foo39'# := (x40' -> α42')
//│ 		x40' <: {a: a41'}
//│ 		a41' <: x40'
//│ 0. Online simplification
//│ | Analysis[+] foo39'#  []
//│ | | Analysis[+] (x40' -> α42')  [foo39'#]
//│ | | | Analysis[-] (x40',)  []
//│ | | | | Analysis[-] x40'  []
//│ | | | | | !! x40' Some(false) List({a: a41'})
//│ | | | | | Analysis[-] {a: a41'}  [x40']
//│ | | | | | | Analysis[-] a41'  []
//│ | | | | | | | !! a41' Some(false) List(x40')
//│ | | | | | | | Analysis[-] x40'  [a41']
//│ | | | | | | | | REC x40'
//│ | | | Analysis[+] α42'  []
//│ | | | | !! α42' Some(true) List()
//│ | Unif-pre: HashMap()
//│ | Pos: HashSet(foo39'#, α42')
//│ | Neg: HashSet(x40', a41')
//│ | Rec: HashSet(x40')
//│ | Unif: HashMap()
//│ | subst(foo39'#)
//│ | | Repr: foo39'#
//│ | | subst((x40' -> α42'))
//│ | | | subst((x40',))
//│ | | | | subst(x40')
//│ | | | | | Repr: x40'
//│ | | | | | It's recursive!
//│ | | | | | subst({a: a41'})
//│ | | | | | | subst(a41')
//│ | | | | | | | Repr: a41'
//│ | | | | | | | subst(x40')
//│ | | | | | | | | Repr: x40'
//│ | | | | | | | = x40'
//│ | | | | | | = x40'
//│ | | | | | = {a: x40'}
//│ | | | | = x40'
//│ | | | = (x40',)
//│ | | | subst(α42')
//│ | | | | Repr: α42'
//│ | | | = ⊥
//│ | | = (x40' -> ⊥)
//│ | = foo39'#
//│ 0. Simplified: foo39'# where 
//│ 		foo39'# := (x40' -> ⊥)
//│ 		x40' <: {a: x40'}
//│ ⬤ Typed as: ‹∀ 0. foo39'#›
//│  where: 
//│ 		foo39'# := (x40' -> ⊥)
//│ 		x40' <: {a: x40'}
//│ foo: 'x -> nothing
//│   where
//│     'x <: {a: 'x}
//│    = [Function: foo3]




