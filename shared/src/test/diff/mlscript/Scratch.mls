
:d
def f b = if b then 0 else 1
//│ 1. Typing term (b,) => if (b,) (0,) (1,)
//│ | 1. Typing pattern b,
//│ | | 1. Typing pattern b
//│ | | 1. : b21'
//│ | 1. : (b21',)
//│ | 1. Typing term if (b,) (0,) (1,)
//│ | | 1. Typing term if (b,) (0,)
//│ | | | 1. Typing term if (b,)
//│ | | | | 1. Typing term if
//│ | | | | 1. : ‹∀ 0. (bool<> -> (α20' -> (α20' -> α20')))›
//│ | | | | 1. Typing term b
//│ | | | | 1. : b21'
//│ | | | | CONSTRAIN ‹∀ 0. (bool<> -> (α20' -> (α20' -> α20')))› <! (b21' -> α22')
//│ | | | |   where 
//│ | | | | 1. C ‹∀ 0. (bool<> -> (α20' -> (α20' -> α20')))› <! (b21' -> α22')    (0)
//│ | | | | | DISTRIB-L  ~>  (bool<> -> ‹∀ 0. (α20' -> (α20' -> α20'))›)
//│ | | | | | 1. C (bool<> -> ‹∀ 0. (α20' -> (α20' -> α20'))›) <! (b21' -> α22')    (2)
//│ | | | | | | 1. C (b21',) <! (bool<>,)    (2)
//│ | | | | | | | 1. C b21' <! bool<>    (3)
//│ | | | | | | | | NEW b21' UB (0)
//│ | | | | | | 1. C ‹∀ 0. (α20' -> (α20' -> α20'))› <! α22'    (2)
//│ | | | | | | | NEW α22' LB (0)
//│ | | | 1. : α22'
//│ | | | 1. Typing term 0
//│ | | | 1. : 0<int,number>
//│ | | | CONSTRAIN α22' <! (0<int,number> -> α23')
//│ | | |   where 
//│ 		α22' :> ‹∀ 0. (α20' -> (α20' -> α20'))›
//│ | | | 1. C α22' <! (0<int,number> -> α23')    (0)
//│ | | | | NEW α22' UB (1)
//│ | | | | 1. C ‹∀ 0. (α20' -> (α20' -> α20'))› <! (0<int,number> -> α23')    (2)
//│ | | | | | could be distribbed: TreeSet(α20')
//│ | | | | | cannot be distribbed: TreeSet(α20')
//│ | | | | | INST [0]   ‹∀ 0. (α20' -> (α20' -> α20'))›
//│ | | | | |   where  
//│ | | | | | TO [1] ~>  (α20_24' -> (α20_24' -> α20_24'))
//│ | | | | |   where  
//│ | | | | | 1. C (α20_24' -> (α20_24' -> α20_24')) <! (0<int,number> -> α23')    (4)
//│ | | | | | | 1. C (0<int,number>,) <! (α20_24',)    (3)
//│ | | | | | | | 1. C 0<int,number> <! α20_24'    (4)
//│ | | | | | | | | NEW α20_24' LB (0)
//│ | | | | | | 1. C (α20_24' -> α20_24') <! α23'    (3)
//│ | | | | | | | NEW α23' LB (1)
//│ | | 1. : α23'
//│ | | 1. Typing term 1
//│ | | 1. : 1<int,number>
//│ | | CONSTRAIN α23' <! (1<int,number> -> α25')
//│ | |   where 
//│ 		α23' :> (α20_24' -> α20_24')
//│ 		α20_24' :> 0<int,number>
//│ | | 1. C α23' <! (1<int,number> -> α25')    (0)
//│ | | | NEW α23' UB (1)
//│ | | | 1. C (α20_24' -> α20_24') <! (1<int,number> -> α25')    (2)
//│ | | | | 1. C (1<int,number>,) <! (α20_24',)    (2)
//│ | | | | | 1. C 1<int,number> <! α20_24'    (3)
//│ | | | | | | NEW α20_24' LB (0)
//│ | | | | 1. C α20_24' <! α25'    (2)
//│ | | | | | NEW α20_24' UB (1)
//│ | | | | | 1. C 1<int,number> <! α25'    (4)
//│ | | | | | | NEW α25' LB (0)
//│ | | | | | 1. C 0<int,number> <! α25'    (4)
//│ | | | | | | NEW α25' LB (0)
//│ | 1. : α25'
//│ 1. : (b21' -> α25')
//│ UNSTASHING... (out)
//│ ⬤ Typed as: ‹∀ 0. (b21' -> α25')›
//│  where: 
//│ 		b21' <: bool<>
//│ 		α25' :> 0<int,number> | 1<int,number>
//│ f: bool -> (0 | 1)
//│  = [Function: f]

