
def intToString: int -> string
def intToString x = toString x
def done x = case x of {}
//│ intToString: int -> string
//│            = <missing implementation>
//│ anything -> string
//│   <:  intToString:
//│ int -> string
//│            = [Function: intToString]
//│ done: nothing -> nothing
//│     = [Function: done]



class Lit: { val: int }
class Add[E]: { lhs: E; rhs: E }
def lit val = Lit { val }
def add lhs rhs = Add { lhs; rhs }
//│ Defined class Lit
//│ Defined class Add[+E]
//│ lit: (int & 'val) -> (Lit with {val: 'val})
//│    = [Function: lit]
//│ add: ('lhs & 'E) -> ('E & 'rhs) -> (Add['E] with {lhs: 'lhs, rhs: 'rhs})
//│    = [Function: add]



rec def eval1_stub k e = case e of {
  | Add -> eval1_stub k e.lhs
  | _ -> k e
  }
//│ /!!!\ Uncaught error: java.lang.StackOverflowError

rec def eval1_stub k e = case e of {
  | Add -> eval1_stub k e.lhs + eval1_stub k e.rhs
  | _ -> k e
  }
//│ eval1_stub: ('a -> int) -> 'b -> int
//│   where
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | 'a & ~#Add
//│           = [Function: eval1_stub]

:ns
rec def eval1_stub e = case e of {
  | Lit -> 1
  | Add -> eval1_stub e.lhs
  | _ -> 0
  }
//│ /!!!\ Uncaught error: java.lang.StackOverflowError

eval1_stub
//│ res: 'a -> (0 | 1)
//│   where
//│     'a <: Add[?] & {lhs: 'a} | Lit | ~Add[?] & ~Lit
//│    = [Function: eval1_stub]

// def eval1: ('b -> int) -> Expr['b] -> int
:stats
rec def eval1 k e = case e of {
  | Lit -> e.val
  | Add -> eval1 k e.lhs + eval1 k e.rhs
  | _ -> k e
  }
//│ eval1: ('a -> int) -> 'b -> int
//│   where
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | Lit | 'a & ~#Add & ~#Lit
//│      = [Function: eval1]
//│ constrain calls  : 79
//│ annoying  calls  : 0
//│ subtyping calls  : 307

:ns
eval1
//│ res: forall 'a 'eval1 'b 'c 'val. 'eval1
//│   where
//│     'eval1 := ('a -> 'b) -> 'c -> ('val | int | 'b)
//│     'c <: #Lit & {val: 'val} | (#Add & {rhs: 'c} & {lhs: 'c} | 'a & ~#Add) & ~#Lit
//│     'val <: int
//│     'b <: int
//│    = [Function: eval1]

:re
error: ~Add[?]
//│ res: ~Add[nothing]
//│ Runtime error:
//│   Error: unexpected runtime error

:re
error: ('a & ~Lit) -> 'a
//│ res: ('a & ~Lit) -> 'a
//│ Runtime error:
//│   Error: unexpected runtime error

:re
error: ('a) -> ('a & Add[?])
error: ('a) -> ('a & ~Add[?])
error: ('a & ~Add[?]) -> 'a
//│ res: 'a -> (Add[?] & 'a)
//│ Runtime error:
//│   Error: unexpected runtime error
//│ res: 'a -> ('a & ~Add[nothing])
//│ Runtime error:
//│   Error: unexpected runtime error
//│ res: ('a & ~Add[?]) -> 'a
//│ Runtime error:
//│   Error: unexpected runtime error

:re
error: ('a & ~add) -> 'a
//│ res: ('a & ~#Add) -> 'a
//│ Runtime error:
//│   Error: unexpected runtime error

:ns
def eval1_ty_ugly: ('a -> int) -> (Lit | Add['b] | 'a & ~Lit & ~Add[?] as 'b) -> int
//│ eval1_ty_ugly: forall 'a 'b. ('a -> int) -> 'b -> int
//│   where
//│     'b := Lit | Add['b] | 'a & ~Lit & ~Add[?]
//│              = <missing implementation>

eval1_ty_ugly
//│ res: ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~Add[?] & ~Lit | Add['b] | Lit
//│    = <no result>
//│      eval1_ty_ugly is not implemented

:stats
def eval1_ty_ugly = eval1
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | Lit | 'a & ~#Add & ~#Lit
//│   <:  eval1_ty_ugly:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~Add[?] & ~Lit | Add['b] | Lit
//│              = [Function: eval1_ty_ugly]
//│ constrain calls  : 51
//│ annoying  calls  : 36
//│ subtyping calls  : 715

:ns
def eval1_ty: ('a -> int) -> (Lit | Add['b] | 'a & ~lit & ~add as 'b) -> int
//│ eval1_ty: forall 'a 'b. ('a -> int) -> 'b -> int
//│   where
//│     'b := Lit | Add['b] | 'a & ~#Lit & ~#Add
//│         = <missing implementation>

eval1_ty
//│ res: ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~#Add & ~#Lit | Add['b] | Lit
//│    = <no result>
//│      eval1_ty is not implemented

:stats
def eval1_ty = eval1
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | Lit | 'a & ~#Add & ~#Lit
//│   <:  eval1_ty:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~#Add & ~#Lit | Add['b] | Lit
//│         = [Function: eval1_ty]
//│ constrain calls  : 51
//│ annoying  calls  : 36
//│ subtyping calls  : 714

:stats
eval1_ty_ugly = eval1_ty
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~#Add & ~#Lit | Add['b] | Lit
//│   <:  eval1_ty_ugly:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~Add[?] & ~Lit | Add['b] | Lit
//│              = [Function: eval1]
//│ constrain calls  : 36
//│ annoying  calls  : 33
//│ subtyping calls  : 442

:stats
eval1_ty = eval1_ty_ugly
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~Add[?] & ~Lit | Add['b] | Lit
//│   <:  eval1_ty:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~#Add & ~#Lit | Add['b] | Lit
//│         = [Function: eval1]
//│ constrain calls  : 208
//│ annoying  calls  : 529
//│ subtyping calls  : 4578


// Workaround:
:ns
type E1[A] = Lit | Add[E1[A]] | A & ~lit & ~add
def eval1_ty: ('a -> int) -> E1['a] -> int
//│ Defined type alias E1[+A]
//│ eval1_ty: forall 'a. ('a -> int) -> E1['a] -> int
//│         = <missing implementation>

eval1_ty
//│ res: ('a -> int) -> E1['a] -> int
//│    = <no result>
//│      eval1_ty is not implemented

:stats
def eval1_ty = eval1
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | Lit | 'a & ~#Add & ~#Lit
//│   <:  eval1_ty:
//│ ('a -> int) -> E1['a] -> int
//│         = [Function: eval1_ty2]
//│ constrain calls  : 43
//│ annoying  calls  : 21
//│ subtyping calls  : 556


:stats
rec def pretty1 k e = case e of {
  | Lit -> intToString e.val
  | Add -> concat (pretty1 k e.lhs) (pretty1 k e.rhs)
  | _ -> k e
  }
//│ pretty1: ('a -> string) -> 'b -> string
//│   where
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | Lit | 'a & ~#Add & ~#Lit
//│        = [Function: pretty1]
//│ constrain calls  : 87
//│ annoying  calls  : 0
//│ subtyping calls  : 340


:stats
rec def prettier1 k ev e = case e of {
  | Lit -> intToString e.val
  | Add ->
      if ev e.lhs == 0 then prettier1 k ev e.rhs
      else if ev e.rhs == 0 then prettier1 k ev e.lhs
      else concat (prettier1 k ev e.lhs) (prettier1 k ev e.rhs)
  | _ -> k e
  }
//│ /!!!\ Uncaught error: java.lang.StackOverflowError

:stats
rec def prettier11 k ev e = case e of {
  | Lit -> intToString e.val
  | Add ->
      let tmp = pretty1 k e.lhs
      in if ev e.rhs == 0 then tmp else concat tmp (prettier11 k ev e.rhs)
  | _ -> k e
  }
//│ prettier11: ('a -> string) -> ('rhs -> number) -> 'b -> string
//│   where
//│     'b <: Add[?] & {lhs: 'c, rhs: 'rhs & 'b} | Lit | 'a & ~#Add & ~#Lit
//│     'c <: Add[?] & {lhs: 'c, rhs: 'c} | Lit | 'a & ~#Add & ~#Lit
//│           = [Function: prettier11]
//│ constrain calls  : 179
//│ annoying  calls  : 0
//│ subtyping calls  : 724

// Doesn't make much sense, but generates very ugly type unless aggressively simplified:
:stats
rec def prettier12 k ev e = case e of {
  | Lit -> intToString e.val
  | Add ->
      let tmp = pretty1 k e.lhs
      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
  | _ -> k e
  }
//│ prettier12: ('a -> 'b & 'c -> string) -> ('d -> number) -> (Add[?] & {lhs: 'e, rhs: 'f} & 'd | Lit | 'a & ~#Add & ~#Lit) -> (string | 'b)
//│   where
//│     'f <: Add[?] & {lhs: 'f, rhs: 'f} | Lit | 'c & ~#Add & ~#Lit
//│     'e <: Add[?] & {lhs: 'e, rhs: 'e} | Lit | 'c & ~#Add & ~#Lit
//│           = [Function: prettier12]
//│ constrain calls  : 159
//│ annoying  calls  : 0
//│ subtyping calls  : 781


:stats
e1 = Add{lhs = Lit {val = 1}; rhs = Add{lhs = Lit {val = 2}; rhs = Lit {val = 3}}}
eval1 done e1
pretty1 done e1
prettier1 done (eval1 done) e1
prettier11 done (eval1 done) e1
prettier12 done (eval1 done) e1
//│ e1: Add[Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}} | Lit & {val: 1}] with {lhs: Lit & {val: 1}, rhs: Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}
//│ res: int
//│ res: string
//│ res: string
//│ res: string
//│ res: string
//│ Code generation encountered an error:
//│   unresolved symbol prettier1
//│ constrain calls  : 923
//│ annoying  calls  : 396
//│ subtyping calls  : 10888


e1 = add (lit 1) (add (lit 2) (lit 3))
eval1 done e1
pretty1 done e1
prettier1 done (eval1 done) e1
prettier11 done (eval1 done) e1
prettier12 done (eval1 done) e1
//│ e1: Add[Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}} | Lit & {val: 1}] with {lhs: Lit & {val: 1}, rhs: Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}
//│ res: int
//│ res: string
//│ res: string
//│ res: string
//│ res: string
//│ Code generation encountered an error:
//│   unresolved symbol prettier1



class Nega[E]: { arg: E }
def nega arg = Nega { arg }
//│ Defined class Nega[+E]
//│ nega: 'arg -> Nega['arg]
//│     = [Function: nega]



rec def eval2 k = eval1 (fun x -> case x of {
  | Nega -> 0 - (eval2 k x.arg)
  | _ -> k x
  })
//│ eval2: ('a -> int) -> 'b -> int
//│   where
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | Lit | 'c & ~#Add & ~#Lit
//│     'c <: Nega[?] & {arg: 'd} | 'a & ~#Nega
//│     'd <: Add[?] & {lhs: 'd, rhs: 'd} | Lit | 'c & ~#Add & ~#Lit
//│      = [Function: eval2]


:stats
rec def prettier2 k ev = prettier1 (fun x -> case x of {
  | Nega -> concat "-" (prettier2 k ev x.arg)
  | _ -> k x
  }) ev
//│ /!!!\ Uncaught error: java.lang.StackOverflowError

:stats
rec def prettier22 k ev = prettier12 (fun x -> case x of {
  | Nega -> concat "-" (prettier22 k ev x.arg)
  | _ -> k x
  }) ev
//│ prettier22: ('a -> string) -> ('b -> number) -> 'arg -> string
//│   where
//│     'b <: {lhs: 'c, rhs: 'd}
//│     'd <: Add[?] & {lhs: 'd, rhs: 'd} | Lit | 'e & ~#Add & ~#Lit
//│     'c <: Add[?] & {lhs: 'c, rhs: 'c} | Lit | 'e & ~#Add & ~#Lit
//│     'e <: Nega[?] & {arg: 'arg} | 'a & ~#Nega
//│     'arg <: Add[?] & 'b | Lit | 'e & ~#Add & ~#Lit
//│           = [Function: prettier22]
//│ constrain calls  : 195
//│ annoying  calls  : 0
//│ subtyping calls  : 997



:stats
eval2 done e1
//│ res: int
//│ Runtime error:
//│   ReferenceError: e11 is not defined
//│ constrain calls  : 112
//│ annoying  calls  : 56
//│ subtyping calls  : 1317

e2 = add (lit 1) (nega e1)
//│ e2: Add[Lit & {val: 1} | Nega[Add[Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}} | Lit & {val: 1}] with {lhs: Lit & {val: 1}, rhs: Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}]] with {lhs: Lit & {val: 1}, rhs: Nega[Add[Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}} | Lit & {val: 1}] with {lhs: Lit & {val: 1}, rhs: Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}]}
//│ Runtime error:
//│   ReferenceError: e11 is not defined

:stats
eval2 done e2
//│ res: int
//│ Runtime error:
//│   ReferenceError: e2 is not defined
//│ constrain calls  : 142
//│ annoying  calls  : 75
//│ subtyping calls  : 1885

d2 = nega (add (lit 1) (nega (lit 1)))
//│ d2: Nega[Add[Lit & {val: 1} | Nega[Lit & {val: 1}]] with {lhs: Lit & {val: 1}, rhs: Nega[Lit & {val: 1}]}]
//│   = Nega { arg: Add { lhs: Lit { val: 1 }, rhs: Nega { arg: [Lit] } } }

:stats
eval2 done d2
//│ res: int
//│    = 0
//│ constrain calls  : 99
//│ annoying  calls  : 49
//│ subtyping calls  : 1241


prettier2 done
//│ res: ((Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}} | 'lhs | Lit & {val: 1 | 2 | 3}) -> number) -> 'a -> string
//│   where
//│     'a <: Add[?] & {lhs: 'lhs & 'a & 'b & 'c, rhs: 'lhs & 'a & 'd & 'e} | Lit
//│     'e <: Add[?] & {lhs: 'e, rhs: 'e} | Lit
//│     'd <: Add[?] & {lhs: 'd, rhs: 'd} | Lit
//│     'c <: Add[?] & {lhs: 'c, rhs: 'c} | Lit
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | Lit
//│ Code generation encountered an error:
//│   unresolved symbol prettier2

prettier22 done
//│ res: ('a -> number) -> 'arg -> string
//│   where
//│     'a <: {lhs: 'b, rhs: 'c}
//│     'c <: Add[?] & {lhs: 'c, rhs: 'c} | Lit | 'd & ~#Add & ~#Lit
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | Lit | 'd & ~#Add & ~#Lit
//│     'd <: Nega[?] & {arg: 'arg}
//│     'arg <: Add[?] & 'a | Lit | 'd & ~#Add & ~#Lit
//│    = [Function (anonymous)]

:stats
prettier2 done (eval1 done)
//│ res: 'a -> string
//│   where
//│     'a <: Add[?] & {lhs: 'a & 'b & 'c & 'd, rhs: 'a & 'e & 'f & 'g} | Lit
//│     'g <: Add[?] & {lhs: 'g, rhs: 'g} | Lit
//│     'f <: Add[?] & {lhs: 'f, rhs: 'f} | Lit
//│     'e <: Add[?] & {lhs: 'e, rhs: 'e} | Lit
//│     'd <: Add[?] & {lhs: 'd, rhs: 'd} | Lit
//│     'c <: Add[?] & {lhs: 'c, rhs: 'c} | Lit
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | Lit
//│ Code generation encountered an error:
//│   unresolved symbol prettier2
//│ constrain calls  : 215
//│ annoying  calls  : 64
//│ subtyping calls  : 2246



prettier22 done (eval1 done)
//│ res: 'arg -> string
//│   where
//│     'arg <: Add[?] & {lhs: 'a, rhs: 'b} & 'c | Lit | 'd & ~#Add & ~#Lit
//│     'c <: Add[?] & {lhs: 'c, rhs: 'c} | Lit
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | Lit | 'd & ~#Add & ~#Lit
//│     'a <: Add[?] & {lhs: 'a, rhs: 'a} | Lit | 'd & ~#Add & ~#Lit
//│     'd <: Nega[?] & {arg: 'arg}
//│    = [Function (anonymous)]

// * TODO could probably merge `c` and `b` here!
:stats
prettier2 done (eval2 done)
//│ res: 'a -> string
//│   where
//│     'a <: Add[?] & {lhs: 'a & 'b & 'c & 'd & 'e, rhs: 'a & 'f & 'g & 'h & 'i} | Lit
//│     'i <: Add[?] & {lhs: 'i, rhs: 'i} | Lit | 'j & ~#Add & ~#Lit
//│     'j <: Nega[?] & {arg: 'k}
//│     'k <: Add[?] & {lhs: 'k, rhs: 'k} | Lit | 'j & ~#Add & ~#Lit
//│     'h <: Add[?] & {lhs: 'h, rhs: 'h} | Lit
//│     'g <: Add[?] & {lhs: 'g, rhs: 'g} | Lit
//│     'f <: Add[?] & {lhs: 'f, rhs: 'f} | Lit
//│     'e <: Add[?] & {lhs: 'e, rhs: 'e} | Lit | 'l & ~#Add & ~#Lit
//│     'l <: Nega[?] & {arg: 'm}
//│     'm <: Add[?] & {lhs: 'm, rhs: 'm} | Lit | 'l & ~#Add & ~#Lit
//│     'd <: Add[?] & {lhs: 'd, rhs: 'd} | Lit
//│     'c <: Add[?] & {lhs: 'c, rhs: 'c} | Lit
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | Lit
//│ Code generation encountered an error:
//│   unresolved symbol prettier2
//│ constrain calls  : 228
//│ annoying  calls  : 64
//│ subtyping calls  : 2559

prettier2 done (eval2 done) e2
prettier2 done (eval2 done) d2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.481: 	prettier2 done (eval2 done) e2
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Nega[?E] with {Nega#E = ?E, arg: forall ?E0 ?E1. Add[?E0] with {Add#E = ?E0, lhs: Lit & {val: 1}, rhs: Add[?E1] with {Add#E = ?E1, lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}}` does not match type `nothing`
//│ ║  l.326: 	def nega arg = Nega { arg }
//│ ║         	               ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.4: 	def done x = case x of {}
//│ ║       	                  ^
//│ ╟── from field selection:
//│ ║  l.247: 	      else concat (prettier1 k ev e.lhs) (prettier1 k ev e.rhs)
//│ ╙──       	                                                         ^^^^^
//│ res: error | string
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.482: 	prettier2 done (eval2 done) d2
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Nega[?E] with {Nega#E = ?E, arg: Add[?E0] with {Add#E = ?E0, lhs: Lit & {val: 1}, rhs: Nega[?E1] with {Nega#E = ?E1, arg: Lit & {val: 1}}}}` does not match type `nothing`
//│ ║  l.326: 	def nega arg = Nega { arg }
//│ ║         	               ^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `nothing`
//│ ║  l.482: 	prettier2 done (eval2 done) d2
//│ ║         	                            ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.4: 	def done x = case x of {}
//│ ║       	                  ^
//│ ╟── from reference:
//│ ║  l.242: 	rec def prettier1 k ev e = case e of {
//│ ╙──       	                                ^
//│ res: error | string
//│ Code generation encountered an error:
//│   unresolved symbol prettier2

:stats
prettier22 done (eval2 done)
prettier22 done (eval2 done) e2
prettier22 done (eval2 done) d2
//│ res: 'arg -> string
//│   where
//│     'arg <: Add[?] & {lhs: 'a, rhs: 'b} & 'c | Lit | 'd & ~#Add & ~#Lit
//│     'c <: Add[?] & {lhs: 'c, rhs: 'c} | Lit | 'e & ~#Add & ~#Lit
//│     'e <: Nega[?] & {arg: 'f}
//│     'f <: Add[?] & {lhs: 'f, rhs: 'f} | Lit | 'e & ~#Add & ~#Lit
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | Lit | 'd & ~#Add & ~#Lit
//│     'a <: Add[?] & {lhs: 'a, rhs: 'a} | Lit | 'd & ~#Add & ~#Lit
//│     'd <: Nega[?] & {arg: 'arg}
//│    = [Function (anonymous)]
//│ res: string
//│ Runtime error:
//│   ReferenceError: e2 is not defined
//│ res: string
//│    = '-1'
//│ constrain calls  : 707
//│ annoying  calls  : 262
//│ subtyping calls  : 11426




// === === === ERROR CASES === === === //


:ShowRelativeLineNums


:e
eval1 done e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	eval1 done e2
//│ ║        	^^^^^^^^^^^^^
//│ ╟── application of type `Nega[?E] with {Nega#E = ?E, arg: forall ?E0 ?E1. Add[?E1] with {Add#E = ?E1, lhs: Lit & {val: 1}, rhs: Add[?E0] with {Add#E = ?E0, lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}}` does not match type `nothing`
//│ ║  l.326: 	def nega arg = Nega { arg }
//│ ║         	               ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.4: 	def done x = case x of {}
//│ ║       	                  ^
//│ ╟── from field selection:
//│ ║  l.62: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ╙──      	                                   ^^^^^
//│ res: error | int
//│ Runtime error:
//│   ReferenceError: e2 is not defined


:e
prettier2 done eval1 e1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval1 e1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Nega[?E] with {Nega#E = ?E, arg: forall ?E0 ?E1. Add[?E0] with {Add#E = ?E0, lhs: Lit & {val: 1}, rhs: Add[?E1] with {Add#E = ?E1, lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}}` is not a function
//│ ║  l.326: 	def nega arg = Nega { arg }
//│ ║         	               ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.63: 	  | _ -> k e
//│ ║        	         ^^^
//│ ╟── from reference:
//│ ║  l.63: 	  | _ -> k e
//│ ╙──      	         ^
//│ res: error
//│ Code generation encountered an error:
//│   unresolved symbol prettier2


:e
:stats
prettier2 done (eval1 done) e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done (eval1 done) e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Nega[?E] with {Nega#E = ?E, arg: forall ?E0 ?E1. Add[?E0] with {Add#E = ?E0, lhs: Lit & {val: 1}, rhs: Add[?E1] with {Add#E = ?E1, lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}}` does not match type `nothing`
//│ ║  l.326: 	def nega arg = Nega { arg }
//│ ║         	               ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.4: 	def done x = case x of {}
//│ ║       	                  ^
//│ ╟── from reference:
//│ ║  l.60: 	rec def eval1 k e = case e of {
//│ ╙──      	                         ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done (eval1 done) e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Nega[?E] with {Nega#E = ?E, arg: forall ?E0 ?E1. Add[?E0] with {Add#E = ?E0, lhs: Lit & {val: 1}, rhs: Add[?E1] with {Add#E = ?E1, lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}}` does not match type `nothing`
//│ ║  l.326: 	def nega arg = Nega { arg }
//│ ║         	               ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.4: 	def done x = case x of {}
//│ ║       	                  ^
//│ ╟── from field selection:
//│ ║  l.247: 	      else concat (prettier1 k ev e.lhs) (prettier1 k ev e.rhs)
//│ ╙──       	                                                         ^^^^^
//│ res: error | string
//│ Code generation encountered an error:
//│   unresolved symbol prettier2
//│ constrain calls  : 549
//│ annoying  calls  : 197
//│ subtyping calls  : 7532

:e
:stats
prettier2 done eval2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Nega[?E] with {Nega#E = ?E, arg: forall ?E0 ?E1. Add[?E0] with {Add#E = ?E0, lhs: Lit & {val: 1}, rhs: Add[?E1] with {Add#E = ?E1, lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}}` is not a function
//│ ║  l.326: 	def nega arg = Nega { arg }
//│ ║         	               ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.335: 	  | _ -> k x
//│ ║         	         ^^^
//│ ╟── from reference:
//│ ║  l.335: 	  | _ -> k x
//│ ╙──       	         ^
//│ res: error
//│ Code generation encountered an error:
//│   unresolved symbol prettier2
//│ constrain calls  : 81
//│ annoying  calls  : 8
//│ subtyping calls  : 1397

:e
:stats
prettier2 done eval2 e1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2 e1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Nega[?E] with {Nega#E = ?E, arg: forall ?E0 ?E1. Add[?E0] with {Add#E = ?E0, lhs: Lit & {val: 1}, rhs: Add[?E1] with {Add#E = ?E1, lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}}` is not a function
//│ ║  l.326: 	def nega arg = Nega { arg }
//│ ║         	               ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.335: 	  | _ -> k x
//│ ║         	         ^^^
//│ ╟── from reference:
//│ ║  l.335: 	  | _ -> k x
//│ ╙──       	         ^
//│ res: error
//│ Code generation encountered an error:
//│   unresolved symbol prettier2
//│ constrain calls  : 89
//│ annoying  calls  : 8
//│ subtyping calls  : 1408

:e
:stats
prettier2 done eval2 e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2 e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Nega[?E] with {Nega#E = ?E, arg: forall ?E0 ?E1. Add[?E0] with {Add#E = ?E0, lhs: Lit & {val: 1}, rhs: Add[?E1] with {Add#E = ?E1, lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}}` is not a function
//│ ║  l.326: 	def nega arg = Nega { arg }
//│ ║         	               ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.335: 	  | _ -> k x
//│ ║         	         ^^^
//│ ╟── from reference:
//│ ║  l.335: 	  | _ -> k x
//│ ╙──       	         ^
//│ res: error
//│ Code generation encountered an error:
//│   unresolved symbol prettier2
//│ constrain calls  : 90
//│ annoying  calls  : 8
//│ subtyping calls  : 1409

:e
:stats
prettier2 done eval2 d2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2 d2
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Nega[?E] with {Nega#E = ?E, arg: forall ?E0 ?E1. Add[?E0] with {Add#E = ?E0, lhs: Lit & {val: 1}, rhs: Add[?E1] with {Add#E = ?E1, lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}}` is not a function
//│ ║  l.326: 	def nega arg = Nega { arg }
//│ ║         	               ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.335: 	  | _ -> k x
//│ ║         	         ^^^
//│ ╟── from reference:
//│ ║  l.335: 	  | _ -> k x
//│ ╙──       	         ^
//│ res: error
//│ Code generation encountered an error:
//│   unresolved symbol prettier2
//│ constrain calls  : 91
//│ annoying  calls  : 8
//│ subtyping calls  : 1410

:e
:stats
prettier2 done eval1 e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval1 e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Nega[?E] with {Nega#E = ?E, arg: forall ?E0 ?E1. Add[?E0] with {Add#E = ?E0, lhs: Lit & {val: 1}, rhs: Add[?E1] with {Add#E = ?E1, lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}}` is not a function
//│ ║  l.326: 	def nega arg = Nega { arg }
//│ ║         	               ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.63: 	  | _ -> k e
//│ ║        	         ^^^
//│ ╟── from reference:
//│ ║  l.63: 	  | _ -> k e
//│ ╙──      	         ^
//│ res: error
//│ Code generation encountered an error:
//│   unresolved symbol prettier2
//│ constrain calls  : 91
//│ annoying  calls  : 8
//│ subtyping calls  : 1402

