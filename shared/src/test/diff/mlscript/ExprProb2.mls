
// --- Lit, Add ---


class Lit: { val: int }
class Add[E]: { lhs: E; rhs: E }
def lit val = Lit { val }
def add lhs rhs = Add { lhs; rhs }
//│ Defined class Lit
//│ Defined class Add[+E]
//│ lit: (int & 'val) -> (Lit with {val: 'val})
//│    = [Function: lit]
//│ add: ('lhs & 'E) -> ('E & 'rhs) -> (Add['E] with {lhs: 'lhs, rhs: 'rhs})
//│    = [Function: add]


:stats
def eval1 eval1 e = case e of {
  | Lit -> e.val
  | Add -> eval1 eval1 e.lhs + eval1 eval1 e.rhs
  }
//│ eval1: ('a -> 'rhs -> int & 'a -> 'lhs -> int & 'a) -> ((Add[?] with {lhs: 'lhs, rhs: 'rhs}) | (Lit with {val: 'val})) -> (int | 'val)
//│      = [Function: eval1]
//│ constrain calls  : 36
//│ annoying  calls  : 0
//│ subtyping calls  : 55

:stats
:js
def eval1f eval1 e = case e of {
  | Lit -> e.val
  | Add -> eval1 e.lhs + eval1 e.rhs
  }
//│ // Query 1
//│ globalThis.eval1f = function eval1f(eval1) {
//│   return ((e) => {
//│     let a;
//│     return (a = e, a instanceof Lit ? e.val : a instanceof Add ? eval1(e.lhs) + eval1(e.rhs) : (() => {
//│       throw new Error("non-exhaustive case expression");
//│     })());
//│   });
//│ };
//│ // End of generated code
//│ eval1f: ('rhs -> int & 'lhs -> int) -> ((Add[?] with {lhs: 'lhs, rhs: 'rhs}) | (Lit with {val: 'val})) -> (int | 'val)
//│       = [Function: eval1f]
//│ constrain calls  : 32
//│ annoying  calls  : 0
//│ subtyping calls  : 52


e1 = add (lit 1) (add (lit 2) (lit 3))
//│ e1: (Add[forall 'a, 'b. (Add[forall 'c, 'd. Lit & {val: 2 | 3} | 'c | 'd] with {lhs: forall 'c. Lit & {val: 2} | 'c, rhs: forall 'd. Lit & {val: 3} | 'd}) | Lit & {val: 1} | 'a | 'b] with {lhs: forall 'a. Lit & {val: 1} | 'a, rhs: forall 'b. (Add[forall 'c, 'd. Lit & {val: 2 | 3} | 'c | 'd] with {lhs: forall 'c. Lit & {val: 2} | 'c, rhs: forall 'd. Lit & {val: 3} | 'd}) | 'b}) | 'e
//│   = Add {
//│       lhs: Lit { val: 1 },
//│       rhs: Add { lhs: Lit { val: 2 }, rhs: Lit { val: 3 } }
//│     }


:e
eval1 eval1 e1
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.60: 	eval1 eval1 e1
//│ ║        	^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α55' -> (α56' -> (val58' | α67')))›  <:  α55_208    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α55' -> (α56' -> (val58' | α67')))›  <:  α55'
//│ res: error
//│    = 6

:e
def eval1_fixed_1 = eval1 eval1
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.71: 	def eval1_fixed_1 = eval1 eval1
//│ ║        	                    ^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α55' -> (α56' -> (val58' | α67')))›  <:  α55_245'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α55' -> (α56' -> (val58' | α67')))›  <:  α55'
//│ eval1_fixed_1: error
//│              = [Function: eval1_fixed_1]

eval1_fixed_1 e1
//│ res: error
//│    = 6


rec def eval1_fixed_2 = eval1f (fun x -> eval1f eval1_fixed_2 x)
//│ eval1_fixed_2: ('a & (Add['b] & 'b & 'c | (Lit with {val: 'val}) & 'd)) -> (int | 'val | 'e)
//│   where
//│     'c <: {lhs: 'f, rhs: 'f}
//│     'f <: Add['b] & {lhs: Add['b] & 'c | Lit, rhs: Add['b] & 'c | Lit} | Lit
//│              = [Function: eval1_fixed_2]

eval1_fixed_2 e1
//│ res: int | 'a
//│    = 6


:e
// Tying the knot without a recursive def:
def eval1_fixed_3 =
  let fixed fixed = eval1f (fun x -> eval1f (fixed fixed) x)
  in fixed fixed
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.102: 	  in fixed fixed
//│ ║         	     ^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 1. (α411'' -> α455'')›  <:  α411_582'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 1. (α411'' -> α455'')›  <:  α411''
//│ eval1_fixed_3: error
//│              = [Function: eval1_fixed_3]

eval1_fixed_3 e1
//│ res: error
//│    = 6



// --- Nega ---


class Nega[E]: { arg: E }
def nega arg = Nega { arg }
//│ Defined class Nega[+E]
//│ nega: 'arg -> Nega['arg]
//│     = [Function: nega]


def eval2 eval2 e = case e of {
  | Nega -> 0 - (eval2 eval2 e.arg)
  | _ -> eval1 eval2 e
  }
//│ eval2: ('a -> 'rhs -> int & 'a -> 'lhs -> int & 'a -> 'arg -> int & 'a) -> ((Add[?] with {lhs: 'lhs, rhs: 'rhs}) | (Lit with {val: 'val}) | (Nega[?] with {arg: 'arg})) -> (forall 'b. int | 'val | 'b)
//│      = [Function: eval2]

def eval2f eval2 e = case e of {
  | Nega -> 0 - (eval2 e.arg)
  | _ -> eval1f eval2 e
  }
//│ eval2f: ('arg -> int & 'rhs -> int & 'lhs -> int) -> ((Add[?] with {lhs: 'lhs, rhs: 'rhs}) | (Lit with {val: 'val}) | (Nega[?] with {arg: 'arg})) -> (forall 'a. int | 'val | 'a)
//│       = [Function: eval2f]


e2 = add (lit 1) (nega e1)
//│ e2: (Add[forall 'a, 'b. Lit & {val: 1} | Nega[forall 'c. (Add[forall 'd, 'e. (Add[forall 'f, 'g. Lit & {val: 2 | 3} | 'f | 'g] with {lhs: forall 'f. Lit & {val: 2} | 'f, rhs: forall 'g. Lit & {val: 3} | 'g}) | Lit & {val: 1} | 'd | 'e] with {lhs: forall 'd. Lit & {val: 1} | 'd, rhs: forall 'e. (Add[forall 'f, 'g. Lit & {val: 2 | 3} | 'f | 'g] with {lhs: forall 'f. Lit & {val: 2} | 'f, rhs: forall 'g. Lit & {val: 3} | 'g}) | 'e}) | 'c] | 'a | 'b] with {lhs: forall 'a. Lit & {val: 1} | 'a, rhs: forall 'b. Nega[forall 'c. (Add[forall 'd, 'e. (Add[forall 'f, 'g. Lit & {val: 2 | 3} | 'f | 'g] with {lhs: forall 'f. Lit & {val: 2} | 'f, rhs: forall 'g. Lit & {val: 3} | 'g}) | Lit & {val: 1} | 'd | 'e] with {lhs: forall 'd. Lit & {val: 1} | 'd, rhs: forall 'e. (Add[forall 'f, 'g. Lit & {val: 2 | 3} | 'f | 'g] with {lhs: forall 'f. Lit & {val: 2} | 'f, rhs: forall 'g. Lit & {val: 3} | 'g}) | 'e}) | 'c] | 'b}) | 'h
//│   = Add {
//│       lhs: Lit { val: 1 },
//│       rhs: Nega { arg: Add { lhs: [Lit], rhs: [Add] } }
//│     }


:e
def eval2_fixed_1 = eval2 eval2
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.152: 	def eval2_fixed_1 = eval2 eval2
//│ ║         	                    ^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α632' -> (α633' -> (α639' | α659')))›  <:  α632_867'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α632' -> (α633' -> (α639' | α659')))›  <:  α632'
//│ eval2_fixed_1: error
//│              = [Function: eval2_fixed_1]

eval2_fixed_1 e1
eval2_fixed_1 e2
//│ res: error
//│    = 6
//│ res: error
//│    = -5

// FIXME strange type
// :e
def fix f = let fixed = fun x -> f (fun v -> (x x) v) in fixed fixed
//│ fix: ((forall 'a, 'b, 'c, 'd, 'e. ('c -> 'b
//│   where
//│     forall 'f, 'g. ('e & 'f) -> ('g | 'd) | 'e <: (forall 'f, 'g. ('e & 'f) -> ('g | 'd) | 'e) -> ('c -> 'b & 'a))) -> 'd) -> (forall 'h. 'h | 'd)
//│    = [Function: fix]

//:e // due to tapping
// :e // Works since inconsistent constrained types...
def eval2_fixed_2 = fix eval2f
//│ eval2_fixed_2: ('a & (Nega['b] & 'c & 'd | 'e & 'f & (Add['b] & 'g | (Lit with {val: 'val}) & 'b))) -> (forall 'h. int | 'val | 'i | 'j | 'h) | 'k | 'l
//│   where
//│     'd <: {arg: Add['b] & 'g | Lit | Nega['b] & 'd}
//│     'g <: {lhs: Add['b] & 'g | Lit | Nega['b] & 'd, rhs: Add['b] & 'g | Lit | Nega['b] & 'd}
//│              = [Function: eval2_fixed_2]

eval2_fixed_2 e1
eval2_fixed_2 e2
//│ res: int | 'a | 'b | 'c
//│    = 6
//│ res: int | 'a | 'b | 'c
//│    = -5




// === === === ERROR CASES === === === //



:ge
let rec eval1_fixed = eval1f (eval1f eval1_fixed) in eval1_fixed e1
//│ res: int | 'a
//│ Code generation encountered an error:
//│   recursive non-function definition eval1_fixed is not supported

:js
rec def eval1_fixed = eval1f (eval1f eval1_fixed)
//│ // Query 1
//│ globalThis["eval1_fixed"] = function eval1_fixed() {
//│   return eval1f(eval1f(eval1_fixed()));
//│ };
//│ // End of generated code
//│ eval1_fixed: ('a & (Add['b] & 'b & 'c | (Lit with {val: 'val}) & 'd)) -> (int | 'val | 'e)
//│   where
//│     'c <: {lhs: Add['b] & 'c | Lit, rhs: Add['b] & 'c | Lit}
//│            = [Function: eval1_fixed]

:re
eval1_fixed e1
//│ res: int | 'a
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

rec def eval1_fixed() = eval1f (eval1f (eval1_fixed()))
//│ eval1_fixed: () -> (forall 'a, 'b, 'val, 'c, 'd. ('b & (Add['d] & 'd & 'e | (Lit with {val: 'val}) & 'c)) -> (int | 'val | 'a))
//│   where
//│     'e <: {lhs: Add['d] & 'e | Lit, rhs: Add['d] & 'e | Lit}
//│            = [Function: eval1_fixed1]

:re
eval1_fixed() e1
//│ res: int | 'a
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded



:ShowRelativeLineNums
:AllowTypeErrors



def eval1_fixed = eval1f (fun x -> eval1f eval1f x)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	def eval1_fixed = eval1f (fun x -> eval1f eval1f x)
//│ ║        	                                   ^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (forall ?b. ?val | ?b)` is not an instance of type `int`
//│ ║  l.30: 	def eval1f eval1 e = case e of {
//│ ║        	                 ^^^^^^^^^^^^^^^
//│ ║  l.31: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.32: 	  | Add -> eval1 e.lhs + eval1 e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.32: 	  | Add -> eval1 e.lhs + eval1 e.rhs
//│ ╙──      	                         ^^^^^^^^^^^
//│ eval1_fixed: ('a & (Add['b] & 'b | (Lit with {val: 'val}) & 'c)) -> (int | 'val | 'd)

rec def eval1_fixed = eval1f (fun x -> eval1_fixed eval1_fixed x)
//│ ╔══[ERROR] Type mismatch in binding of application:
//│ ║  l.+1: 	rec def eval1_fixed = eval1f (fun x -> eval1_fixed eval1_fixed x)
//│ ║        	                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (forall ?b. ?val | ?b)` does not match type `Add[?] & ?c | Lit & ?d`
//│ ║  l.30: 	def eval1f eval1 e = case e of {
//│ ║        	                 ^^^^^^^^^^^^^^^
//│ ║  l.31: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.32: 	  | Add -> eval1 e.lhs + eval1 e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	  }
//│ ║        	^^^
//│ ╟── but it flows into application with expected type `Add[?] & ?e | Lit & ?f`
//│ ║  l.+1: 	rec def eval1_fixed = eval1f (fun x -> eval1_fixed eval1_fixed x)
//│ ║        	                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.30: 	def eval1f eval1 e = case e of {
//│ ╙──      	                          ^
//│ eval1_fixed: ('a & (Add['b] & 'b | (Lit with {val: 'val}) & 'c)) -> (int | 'val | 'd)

:e
rec def eval1_fixed = eval1f eval1_fixed e1
//│ ╔══[ERROR] Type mismatch in binding of application:
//│ ║  l.+1: 	rec def eval1_fixed = eval1f eval1_fixed e1
//│ ║        	                      ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not a function
//│ ║  l.32: 	  | Add -> eval1 e.lhs + eval1 e.rhs
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `?rhs -> ?a`
//│ ║  l.+1: 	rec def eval1_fixed = eval1f eval1_fixed e1
//│ ║        	                      ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.32: 	  | Add -> eval1 e.lhs + eval1 e.rhs
//│ ║        	                         ^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.+1: 	rec def eval1_fixed = eval1f eval1_fixed e1
//│ ╙──      	                             ^^^^^^^^^^^
//│ eval1_fixed: int | 'a


def eval2_broken eval2 e = case e of {
  | Nega -> e.arg
  | _ -> eval1 eval2 e
  }
//│ eval2_broken: ('a -> 'rhs -> int & 'a -> 'lhs -> int & 'a) -> ((Add[?] with {lhs: 'lhs, rhs: 'rhs}) | (Lit with {val: 'arg}) | (Nega[?] with {arg: 'arg})) -> (forall 'b. 'arg | int | 'b)

:e
eval2_broken eval2_broken e2
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.+1: 	eval2_broken eval2_broken e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α2005' -> (α2006' -> (arg2008' | α2028')))›  <:  α2005_2103    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α2005' -> (α2006' -> (arg2008' | α2028')))›  <:  α2005'
//│ res: error


def eval2f_oops eval2 e = case e of {
  | Nega -> 0 - (eval2 e.arg)
  | _ -> eval1 eval2 e // should be: eval1f eval2 e
  }
//│ eval2f_oops: ('arg -> int & 'a -> 'rhs -> int & 'a -> 'lhs -> int & 'a) -> ((Add[?] with {lhs: 'lhs, rhs: 'rhs}) | (Lit with {val: 'val}) | (Nega[?] with {arg: 'arg})) -> (forall 'b. int | 'val | 'b)

// :e
fix eval2f_oops e2
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.+1: 	fix eval2f_oops e2
//│ ║        	^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 1. (α2124_2221'' -> (α2129_2228'' | α2149_2229''))›  <:  ((α897_2281,) -> α899_2282)    PolymorphicType  FunctionType
//│ ╙──  ... looks like:  ‹∀ 1. (α2124_2201'' -> (α2129_2208'' | α2149_2209''))›  <:  ((α897_2197''',) -> α899_2198''')
//│ res: error


