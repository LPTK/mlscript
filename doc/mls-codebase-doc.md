# Document to the Codebase of the MLscript Compiler

This is the document to the codebase of the MLscript Compiler for the reuse
of our MLscript implementation.

## Overview

The codebase of the MLscript Programming Language has all the basic components
of a static-typed programming language: lexing, parsing, typing, and code generation.
In addition, there is a web demo implementation of MLscript, as well as a differential testing
suite.
In this section, we give a high-level introduction to each component and its correspondence to
our Scala sources. Note that source file paths are rooted in `/shared/src/main/scala/mlscript`.

### Lexing

A lexer does lexical analysis, that is, it accepts source strings and returns tokens for parsing.
The corresponding files are:

- `NewLexer.scala` contains the lexer class.
- `Token.scala` contains token datatypes.

### Parsing

A parser does syntactic analysis, that is, it accepts tokens generated by the lexer and
returns an abstract syntax tree of the input program in the surface syntax.
The corresponding files are:

- `NewParser.scala` contains the parser class.
- `syntax.scala` contains **surface** syntax datatypes of the language.

### Typing

A typer does type checking, that is, it accepts an abstract syntax tree of a program
and type checks the program.
MLscript's typer supports type inference with subtyping. For more about the type system,
please refer to [MLstruct](https://dl.acm.org/doi/abs/10.1145/3563304).

The corresponding files are:
- `Typer.scala` contains the typer class. It inherits class `ucs.Desugarer` and
trait `TypeSimplifier`.
- `TypeSimplifier.scala` contains type simplification algorithms to simplify
inferred types.
- `ucs/Desugarer.scala` contains class `ucs.Desugarer` which implements desugaring
methods. It inherits class `TypeDefs.scala`.
- `TypeDefs.scala` and `NuTypeDefs.scala` contain class `TypeDef` and methods for
declarations like classes, interfaces, and type aliases. Class `TypeDefs` inherits 
class `NuTypeDefs`, and `NuTypeDefs` inherits class `ConstraintSolver`.
- `ConstraitSolver.scala` contains class `ConstraintSolver` which solves subtyping
constraints. It inherits class `NormalForms`.
- `NormalForms.scala` contains class `NormalForms` which provides the infrastructure
to solve tricker subtyping constraints with disjunct normal forms (DNF) on the left
and conjunct normal forms (CNF) on the right. It inherits class `TyperDatatypes`.
- `TyperDatatypes.scala` contains class `TyperDatatypes` which contains
datatypes to support **internal** representations of types with mutable states to do
type inference with subtyping. It inherits class `TyperHelpers`.
- `TyperHelpers.scala` contains class `TyperHelpers` that provides helper methods
for the typer.

### Code Generation

A code generator does code generation, that is,
it translates MLscript AST into JavaScript AST, and then generates the corresponding JavaScript code.

The corresponding files are:

- `codegen/Codegen.scala` contains the definitions of JavaScript AST nodes
  and methods for JavaScript code generation.
- `codegen/Scope.scala` contains the class `Scope` which manages symbols
  and provides the hygienic runtime name generation.
- `codegen/Symbol.scala` contains classes `NewClassSymbol`, `MixinSymbol`,
  and `ModuleSymbol` which contain corresponding definition information of `class`, `mixin` and `module`.
- `JSBackend.scala` contains the class `JSBackend` that translates the MLscript AST
  into JavaScript AST, and two classes `JSWebBackend` and `JSTestBackend` that inherit class `JSBackend`,
  generating adapted code for the web demo and testing.

### Web Demo and Testing


The way testing works in MLscript is as follows:
 - the MLscript compiler reads a given test file one code block at a time (code blocks are separated by empty lines);
 - after reading a code block, it outputs the corresponding inferred types, as well as any encountered type errors;
 - after that, it executes the code block through NodeJS (by shelling out to the `node` process) and outputs the results.

We have a web demo for users to test our implementation in any modern browser.
It has a textbox for MLscript source code input and it produces typing and running
results live. The corresponding source is `/js/src/main/scala/Main.scala`.

We have a differential testing suite to test our implementation. It detects user changes
to MLscript test sources, generates typing and running results, and inserts those results
into test sources. The differential testing implementation is
`/shared/src/test/scala/mlscript/DiffTests.scala`. MLscript test sources are in `/shared/src/test/diff`.

---

In later sections, we introduce the idea of implementing each component of the compiler
in more detail.

## Lexing

Class `NewLexer` in `NewLexer.scala` is the lexer class. It takes an `origin`,
which is the original source string together with the source file name,
the number of the first line, and some helper functions. Method `tokens` generates
a list of tokens with their location in the source code. Method `bracketedTokens`
converts the lexed tokens into structured tokens,
which use a `BRACKETS` construct instead of `OPEN_BRACKET`/`CLOSE_BRACKET` and `INDENT`/`DEINDENT`.
The token and structured token datatypes can be found in `Tokens.scala`.

## Parsing

Class `NewParser` in `NewParser.scala` is the parser class. It takes a list
of structured tokens with their location information. Method `typingUnit`
calls method `block` to parse the token list into a list of `Statement`s or
`IfBody` which are defined in `syntax.scala`, filters out unexpected `then/else`
clauses introduced by `Ifbody`s, and returns a `TypingUnit` which is a list of `Statement`s.

File `syntax.scala` contains surface syntax datatypes of MLscript
(which is immutable and different from internal representations in the typer to be used for type inference).
Here we introduce several datatypes:

- Classes `Decl`, `TypeDef`, `MethodDef` are deprecated.
- Class `TypeDefKind` includes type definition kinds including classes and mixins, etc.
- Class `Term` includes MLscript term datatypes. Case class `Bind` is no longer used.
Case class `Splc` is for the rest of the parameter list, like the rest parameter in JavaScript.
Case classes `Forall` and `Inst` are for first-class polymorphism.
- Class `IfBody` includes if-then-else structure datatypes.
- Class `CaseBranches` includes case branch datatypes for MLscript pattern matching.
- Class `TypeLike` includes `Type`, `Signature`, and `NuDecl`.
- Class `Type` includes MLscript type datatypes. Case class `Rem` is for record member removal.
Case class `WithExtension` is for record type extension. For example, `A with {x : int}`
is equivalent to `A\x & {x : int}`.
- Class `TypeVar` represents the type variable. Its identifier can be an `Int` which
is generated internally by the compiler and `Str` which is specified by the user.
- Class `NuTypeDef` is a `NuDef`. It is for type definitions.
Note that it has optional `superAnnot`
and `thisAnnot` for precisely-typed open recursion.
- Class `NuFunDef` is a `NuDef`. It is for function and let-bindings.

## Typing

The MLscript typer (class `Typer`) works with a typing context (class `Ctx`) which
mainly maintains bindings of names of all global and local bindings to their types.
The typer accepts a typing unit from the parser, types the typing unit, and returns a typed typing unit.
During typing, the typer has its own **internal** representations of types
(defined in `TyperDatatypes.scala`)
with mutable states for type inference with subtyping. The typed typing unit
is then sent to the type simplifier, and is finally expanded, i.e., to be converted
back to types in the surface syntax for presentation.

We first introduce several typer datatypes defined in `TyperDatatypes.scala`:

- Class `TypeProvenance` stores the location where a type is introduced.
- Class `LazyTypeInfo` is for type definitions including classes, mixins, modules,
and let-/fun-bindings. Its type is lazily computed to support *mutual recursive* type
definitions. It has a `complete` method to complete typing of the corresponding type definition.
- Class `PolymorphicType` represents a type with universally quantified type variables.
By convention, type variables in the quantified type body of level greater than
the polymorphic type's level are considered quantified.
- Class `Methodtype` is deprecated.
- Class `SimpleType` is a general type form for all types.
It has a field `level` for level-based polymorphism.
- Class `BaseType` includes base types such as function types, arrays, tuples, and class tags.
It can later be refined by `RecordType`.
- Class `RecordType` is a record type with a list of bindings from record fields to their types.
- Class `SpliceType` is not used for now.
- Class `ProxyType` is a derived type form storing more type provenance information.
- Class `TypeRef` is a reference to named types, for example, type definitions like classes.
It has a list of type arguments. A type reference with type arguments is expanded to
a class tag type with its type members refined by the corresponding type arguments.
For example, `Foo[Int]` is expanded to `#Foo & {Foo.A: int..int}`.
- Class `TypeTag` has different kinds of type tags including class tags and abstract tags, etc.
- Class `FieldType` can represent a term field type or a type member.
When it represents a term field type, `lb` represents if the type is mutable.
Otherwise, `lb` is the lower bound of the type member.
- Class `TypeVariable` represents a type variable, which has upper bounds and lower bounds
for type inference with subtyping.

Method `typeTypingUnit` accepts the typing unit to type. It inspects each statement
in the typing unit. If the statement is a type definition, a `LazyTypeInfo` is produced
and stored in the typing context. Note the typing context only uses `tyDefs2` to store
type definitions. Otherwise, it desugars the statement and calls `typeTerms` to type
the desuguared statements. For a single `Term`, it will be passed to `typeTerm` to type.
Method `typeTerm` types a term. If the term needs type information of a `LazyTypeInfo`,
the lazy type will be completed. Subtyping contraints are generated during typing
and will be sent to `ConstraintSolver` to propagate constraints to type variables.
For more about type inference of subtyping, please refer to [MLstruct](https://dl.acm.org/doi/abs/10.1145/3563304).

Of particular interest in the implementation of precisely-typed open recursion,
we introduce how classes and mixins are typed in more detail.
Method `complete` of `LazyTypeInfo` types type definitions i.e. classes, modules, and mixins
and let-/fun-bindings.

When a class (`Cls` which is a `NuTypeDef`) is typed, class fields are first
added into the typing context, and `this` is associated with a new type variable.
The `inherit` helper method deals with the inheritance clause of the class.
It inspects each parent, accumulates its members, and updates the `super` type on the way.
The inheritance process starts with an empty record type as the `super` type.
For each parent, it can only be a mixin with possible mixin arguments.
If the typing context has the mixin defined, it completes the type of the mixin
and freshens each type variable of the mixin as each mixin's type should be constrained
differently at different use sites. Then, the current `super` type and the final
object type (`this` type) should be a subtype of mixin's `super` and `this` type refinements,
so two subtyping constraints are generated. Finally, the current `super` type is
updated as methods in mixins are always *overriding* using `WithType`,
and the mixin's members are accumulated. After processing the whole inheritance clause,
the class fields' types are used to update the current `super` type, and the resulting
type is the final `this` type of the class.

Typing of mixins is not that interesting. Note that we put `this` and `super` associated
with fresh type variables in the typing context, and then we type the mixin body.

## Code Generation

The code generation consists of three steps.
Firstly, the class `JSBackend` translates MLscript datatypes (i.e. class `NuTypeDef`)
into corresponding symbols. Then the class `JSBackend` generates JavaScript AST nodes
based on those symbols.
Finally, we generate JavaScript code from JavaScript AST nodes.

The first step's implementation is in the method `declareNewTypeDefs`.
Here we extract information (including name, parameter list, type, members, and parents)
of classes, mixins, and modules from the given `NuTypeDef` list and generate 
a hygienic runtime name for each symbol.

In the second step, we translate `NewClassSymbol`, `MixinSymbol`, and `ModuleSymbol`
into JavaScript AST nodes by using methods `translateNewClassDeclaration`, `translateMixinDeclaration` and `translateModuleDeclaration`.
All classes, mixins, and modules are translated into JavaScript classes.
The method `translateNewClassMember` contains the translation of members.
We call `translateParents` to get the parent class of a type.
Assuming we have code:
```ts
module A extends B, C
```

The method `translateParents` processes the inheritance in a left-to-right way:

- First, we process the parent `B`:
  - If `B` is a `class` or a `module`, the inheritance would be like `class A extends B`.
  - If `B` is a `mixin`, we need a base class for `B`.
    Here we choose `Object` in JavaScript and the inheritance would be like `class A extends B(Object)`
- Then we process the parent `C`:
  - If `C` is a `mixin`, we can use `B(Object)` as `C`'s base class.
    The inheritance would be like `class A extends C(B(Object))`.
  - Otherwise, we reject the code because a JavaScript class can have only one parent.
  - If module `A` has more parents on the right-hand side of `C`, 
    we can process them in a similar way to how we deal with `C`.

If there are initialization parameters in the parent list,
we move them into the constructor and pass them to `super()`.
Especially, we need to reverse the order of parameters belonging to `mixin`.
For example, assuming we have MLscript code below:

```ts
module A extends MixinA(1), MixinB(2, 3), MixinC(4)
```

The parameters in `super()` would be:
```js
super(4, 2, 3, 1);
```

We generate the JavaScript classes inside `typing_unit` objects.
Notably, we create `...rest` parameters in each constructor of `mixin`
because we have no information about the actual parent class until the function is called.
For modules, we store the instance of the JavaScript class in the cache and for classes, we store the arrow functions that instantiate classes in the cache. We store nothing for mixins because of the uncertainty of the `base` parameter.

In the final step, we emit the JavaScript code by using `toSourceCode` methods in each JavaScript AST node class.

For a class in MLscript:
```ts
class Lit(n: int)
```

The generated code would be like this:
```js
let typing_unit = {
  cache: {},
  get Lit() {
    const cache = this.cache;
    if (this.cache.Lit === undefined) {
      class Lit {
        #n;
        get n() { return this.#n; }
        constructor(n) {
          this.#n = n;
        }
      };
      this.cache.Lit = ((n) => new Lit(n));
      this.cache.Lit["class"] = Lit;
    }
    return this.cache.Lit;
  }
};
globalThis.Lit = typing_unit.Lit;
```

For a mixin in MLscript:
```ts
mixin EvalBase {
  fun eval(e) =
    if e is
      Lit(n) then n: int
}
```

The generated code would be like this:
```js
let typing_unit = {
  cache: {},
  EvalBase(base) {
    return (class EvalBase extends base {
      constructor(...rest) {
        super(...rest);
      }
      eval(e) {
        return ((() => {
          let a;
          return (a = e, a instanceof Lit["class"] ? ((n) => n) (e.n) : (() => {
            throw new Error("non-exhaustive case expression");
          })());
        })());
      }
    });
  }
};
globalThis.EvalBase = typing_unit.EvalBase;
```

For a module in MLscript:
```ts
module TestLang extends EvalBase, EvalNeg, EvalNegNeg
```

The generated code would be like this:
```js
let typing_unit = {
  cache: {},
  get TestLang() {
    if (this.cache.TestLang === undefined) {
      class TestLang extends EvalNegNeg(EvalNeg(EvalBase(Object))) {
        constructor() {
          super();
        }
      }
      this.cache.TestLang = new TestLang();
      this.cache.TestLang["class"] = TestLang;
    }
    return this.cache.TestLang;
  }
};
globalThis.TestLang = typing_unit.TestLang;
```

More details about generated code are located in the test file `shared/src/test/diff/codegen/Mixin.mls`.
