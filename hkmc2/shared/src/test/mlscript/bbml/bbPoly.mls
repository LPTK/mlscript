:global
:bbml

42: [A] -> Int
//│ Type: forall α1_2: Int

:e
42: [A] -> Str
//│ ╔══[ERROR] Type error in integer literal with expected type Str
//│ ║  l.8: 	42: [A] -> Str
//│ ║       	^^
//│ ╙── because: cannot constrain  Int  <:  Str
//│ Type: forall α2_2: Str

fun id: [A] -> A -> A
fun id(x) = x
//│ Type: ⊤

id
//│ Type: forall α4_2: (α4_2) ->{⊥} α4_2

:e
(x => x + 1): [A] -> A -> A
//│ ╔══[ERROR] Type error in reference with expected type Int
//│ ║  l.23: 	(x => x + 1): [A] -> A -> A
//│ ║        	      ^
//│ ╙── because: cannot constrain  <α>5_2  <:  Int
//│ ╔══[ERROR] Type error in function literal with expected type (<α>5_2) ->{⊥} <α>5_2
//│ ║  l.23: 	(x => x + 1): [A] -> A -> A
//│ ║        	 ^^^^^^^^^^
//│ ╙── because: cannot constrain  Int  <:  <α>5_2
//│ Type: forall α5_2: (α5_2) ->{⊥} α5_2


(x => x): [A] -> A -> A
//│ Type: forall α6_2: (α6_2) ->{⊥} α6_2

id: [A] -> A -> A
//│ Type: forall α7_2: (α7_2) ->{⊥} α7_2

id: Int -> Int
//│ Type: (Int) ->{⊥} Int

fun myInc(inc: Int -> Int, x: Int) = inc(x)
//│ Type: ⊤

myInc(id, 0)
//│ Type: Int

let t = 42 in ((x => x): [A] -> A -> A)
//│ Type: forall α14_2: (α14_2) ->{⊥} α14_2


id(42)
//│ Type: Int

id("abc")
//│ Type: Str


class Pair[A, B](a: A, b: B)
//│ Type: ⊤

new Pair(42, true)
//│ Type: Pair[α17_1, α18_1]
//│ Where:
//│   Int <: α17_1
//│   Bool <: α18_1

fun swap: [A, B] -> Pair[out A, out B] -> Pair[out B, out A]
fun swap(p) = new Pair(p.Pair#b, p.Pair#a)
//│ Type: ⊤


swap
//│ Type: forall α21_2, α22_2: (Pair[out α21_2, out α22_2]) ->{⊥} Pair[out α22_2, out α21_2]

let t = new Pair(42, true) in swap(t)
//│ Type: Pair[out Bool, out Int]

let t = new Pair("114", "514") in swap(t)
//│ Type: Pair[out Str, out Str]

let id = ((x => x): [A] -> A -> A) in new Pair(id(42), id("42"))
//│ Type: Pair[α42_1, α43_1]
//│ Where:
//│   Int <: α42_1
//│   Str <: α43_1

fun foo: ([A] -> A -> A) -> Int
fun foo(x) = 42
//│ Type: ⊤

foo
//│ Type: (forall α47_2: (α47_2) ->{⊥} α47_2) ->{⊥} Int

foo(id)
//│ Type: Int

foo(x => x)
//│ Type: Int

class Foo(foo: [A] -> A -> A)
//│ Type: ⊤

new Foo(id)
//│ Type: Foo


new Foo(x => x)
//│ Type: Foo

let foo = new Foo(id) in foo.Foo#foo(42)
//│ Type: Int

class Bar[A](x: A, f: [B] -> B -> B)
//│ Type: ⊤


new Bar(0, id)
//│ Type: Bar[α56_1]
//│ Where:
//│   Int <: α56_1

let bar = new Bar(0, id) in bar.Bar#f(bar.Bar#x)
//│ Type: Int

class Some[A](value: A)
//│ Type: ⊤

new Some((x => x): [A] -> A -> A)
//│ Type: Some[α68_1]
//│ Where:
//│   α70_1 ->{⊥} α70_1 <: α68_1

let s = new Some((x => x): [A] -> A -> A) in let t = s.Some#value(42) in s.Some#value(false)
//│ Type: Bool ∨ Int

fun gen: Int -> [A] -> A -> A
fun gen(x) =
  let t = x + 1 in ((y => y): [A] -> A -> A)
//│ Type: ⊤

gen
//│ Type: (Int) ->{⊥} forall α83_2: (α83_2) ->{⊥} α83_2


gen(42)
//│ Type: forall α83_2: (α83_2) ->{⊥} α83_2

// FIXME: toLoc
:fixme
:e
fun cnt: Some[out [A] -> A -> A] -> Int
fun cnt(x) = 42
//│ ╔══[ERROR] General type is not allowed here.
//│ ║  l.154: 	fun cnt: Some[out [A] -> A -> A] -> Int
//│ ╙──       	                         ^^^^^^
//│ ╔══[ERROR] General type is not allowed here.
//│ ║  l.154: 	fun cnt: Some[out [A] -> A -> A] -> Int
//│ ╙──       	                         ^^^^^^
//│ Type: ⊤

(x => x): [A] -> A -> A
//│ Type: forall α88_2: (α88_2) ->{⊥} α88_2
