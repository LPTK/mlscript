:global
:bbml


class Reg[Rg, Br]
//│ Type: ⊤

fun letreg: [E, Res] -> ([Rg] -> Reg[Rg, E] ->{E | Rg} Res) ->{E} Res
//│ Type: ⊤

fun subreg: [E, Rg, Br, Res] -> Reg[Rg, Br] -> ([Rg2] -> Reg[Rg2 & ~Rg, E] ->{E | Rg2} Res) ->{E} Res
//│ Type: ⊤

fun read: [Rg, Br] -> Reg[Rg, Br] ->{Br} Int
fun write: [Rg, Br] -> Reg[Rg, Br] ->{Rg} Int
//│ Type: ⊤


fun borrow: [Rg, Br, Res] -> Reg[Rg, Br] ->{Rg} (() ->{Br} Res) ->{Br} Res
//│ Type: ⊤

letreg of r =>
  read(r)
  borrow(r) of () =>
    read(r)
  write(r)
//│ Type: Int

:e
letreg of r =>
  read(r)
  borrow(r) of () =>
    write(r)
    read(r)
  write(r)
//│ ╔══[ERROR] Type error in block
//│ ║  l.30: 	letreg of r =>
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.31: 	  read(r)
//│ ║        	^^^^^^^^^
//│ ║  l.32: 	  borrow(r) of () =>
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	    write(r)
//│ ║        	^^^^^^^^^^^^
//│ ║  l.34: 	    read(r)
//│ ║        	^^^^^^^^^^^
//│ ║  l.35: 	  write(r)
//│ ║        	^^^^^^^^^^
//│ ╟── because: cannot constrain  α27_1  <:  <α>0_0
//│ ╙── because: cannot constrain  ⊤  <:  <α>0_0
//│ Type: Int


fun borrow: [Rg, Br, Res] -> Reg[Rg, Br] ->{Rg} (() ->{Br | ~Rg} Res) ->{Br} Res
//│ Type: ⊤

letreg of r =>
  read(r)
  borrow(r) of () =>
    read(r)
  write(r)
//│ Type: Int

// FIXME why no error?
// :e
letreg of r =>
  read(r)
  borrow(r) of () =>
    write(r)
    read(r)
  write(r)
//│ Type: Int


// * TODO...


