:global
:bbml


class Reg[Rg, Br]
//│ Type: ⊤

// fun letreg: [E,Outer,Res] -> ([R] -> Reg[R, Out] ->{E | R} Res) ->{E} Res

fun letreg: [E, Res] -> ([Rg] -> Reg[Rg, E] ->{E | Rg} Res) ->{E} Res
//│ Type: ⊤

letreg
//│ Type: forall α1_2, α2_2: (forall α3_3: (Reg[α3_3, α1_2]) ->{α1_2 ∨ α3_3} α2_2) ->{α1_2} α2_2

fun use: [Rg, Br] -> Reg[Rg, Br] ->{Rg} Int
//│ Type: ⊤


class MutVec[A, Rg, Br]
//│ Type: ⊤

fun mkVec: [A, Rg, Br] -> Reg[Rg, Br] -> MutVec[A, Rg, Br]
//│ Type: ⊤

fun clear: [A, Rg, Br] -> MutVec[A, Rg, Br] ->{Rg} Int
//│ Type: ⊤

clear
//│ Type: forall α9_2, α10_2, α11_2: (MutVec[α9_2, α10_2, α11_2]) ->{α10_2} Int

class Iter[A, Rg]
//│ Type: ⊤

fun iterate: [A, Rg, Br, Res] -> MutVec[A, Rg, Br] -> (Iter[A, Br] ->{Br} Res) ->{Br} Res
//│ Type: ⊤

fun integers: [Rg, Br, Res] -> Reg[Rg, Br] ->{Rg} (Iter[Int, Br] ->{Br} Res) ->{Br} Res
//│ Type: ⊤


fun next: [A, Br] -> Iter[A, Br] ->{Br} A
//│ Type: ⊤

letreg(r => r)
//│ Type: Reg[?, α21_1]
//│ Where:
//│   α21_1 <: <α>0_0

letreg of r =>
  let b = mkVec(r)
  clear(b)
  iterate(b) of it =>
    next(it)
    123
  clear(b)
  r
//│ Type: Reg[?, α23_1]
//│ Where:
//│   α23_1 <: <α>0_0

:e
letreg of r =>
  let b = mkVec(r)
  clear(b)
  iterate(b) of it =>
    next(it)
    clear(b)
    123
  clear(b)
  r
//│ ╔══[ERROR] Type error in block
//│ ║  l.63: 	letreg of r =>
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.64: 	  let b = mkVec(r)
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.65: 	  clear(b)
//│ ║        	^^^^^^^^^^
//│ ║  l.66: 	  iterate(b) of it =>
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.67: 	    next(it)
//│ ║        	^^^^^^^^^^^^
//│ ║  l.68: 	    clear(b)
//│ ║        	^^^^^^^^^^^^
//│ ║  l.69: 	    123
//│ ║        	^^^^^^^
//│ ║  l.70: 	  clear(b)
//│ ║        	^^^^^^^^^^
//│ ║  l.71: 	  r
//│ ║        	^^^
//│ ╟── because: cannot constrain  α40_1  <:  <α>0_0
//│ ╙── because: cannot constrain  ⊤  <:  <α>0_0
//│ Type: Reg[?, α40_1]
//│ Where:
//│   ⊤ <: α40_1
//│   α40_1 <: <α>0_0


letreg of r =>
  use(r)
  integers(r) of it =>
    next(it)
  use(r)
  r
//│ Type: Reg[?, α60_1]
//│ Where:
//│   α60_1 <: <α>0_0

:e
letreg of r =>
  use(r)
  integers(r) of it =>
    use(r)
    next(it)
  use(r)
  r
//│ ╔══[ERROR] Type error in block
//│ ║  l.110: 	letreg of r =>
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.111: 	  use(r)
//│ ║         	^^^^^^^^
//│ ║  l.112: 	  integers(r) of it =>
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.113: 	    use(r)
//│ ║         	^^^^^^^^^^
//│ ║  l.114: 	    next(it)
//│ ║         	^^^^^^^^^^^^
//│ ║  l.115: 	  use(r)
//│ ║         	^^^^^^^^
//│ ║  l.116: 	  r
//│ ║         	^^^
//│ ╟── because: cannot constrain  α71_1  <:  <α>0_0
//│ ╙── because: cannot constrain  ⊤  <:  <α>0_0
//│ Type: Reg[?, α71_1]
//│ Where:
//│   ⊤ <: α71_1
//│   α71_1 <: <α>0_0

letreg of r0 =>
  letreg of r1 =>
    integers(r1) of it =>
      use(r0)
      next(it)
    use(r1)
    r1
//│ Type: Reg[?, in α97_1]
//│ Where:
//│   α97_1 <: <α>0_0

