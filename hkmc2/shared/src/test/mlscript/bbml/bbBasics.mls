:global
:bbml


123
//│ Type: Int

3.14
//│ Type: Num

false
//│ Type: Bool

"bbml"
//│ Type: Str

()
//│ Type: ⊤

fun id(x) = x
id
//│ Type: α2_1 ->{⊥} α2_1

fun inc(x) = x + 1
//│ Type: ⊤

fun mul(x, y) = x * y
//│ Type: ⊤

x => x
//│ Type: (α8_1) ->{⊥} α8_1

+
//│ Type: (Int, Int) ->{⊥} Int

(x, y) => x + y
//│ Type: (Int, Int) ->{⊥} Int

((x, y) => x + y)(40, 2)
//│ Type: Int

:e
114 + "514"
//│ ╔══[ERROR] Type error in string literal with expected type Int
//│ ║  l.43: 	114 + "514"
//│ ║        	      ^^^^^
//│ ╙── because: cannot constrain  Str  <:  Int
//│ Type: Int


inc(42)
//│ Type: Int

let x = 42 in x
//│ Type: Int

let x = 1 in let y = 2 in x + y
//│ Type: Int

:e
let x = 0 in x + "1"
//│ ╔══[ERROR] Type error in string literal with expected type Int
//│ ║  l.61: 	let x = 0 in x + "1"
//│ ║        	                 ^^^
//│ ╙── because: cannot constrain  Str  <:  Int
//│ Type: Int

class Foo(x: Int)
//│ Type: ⊤

:e
new Nothingness(0)
//│ ╔══[ERROR] Class Nothingness not found.
//│ ║  l.72: 	new Nothingness(0)
//│ ╙──      	    ^^^^^^^^^^^^^^
//│ Type: ⊥

:e
new 42
//│ ╔══[ERROR] Illegal new expression.
//│ ║  l.79: 	new 42
//│ ╙──      	    ^^
//│ Type: ⊥


new Foo(42)
//│ Type: Foo


class Point(x: Num, y: Num, z: Num)
//│ Type: ⊤


new Point(0.0, 0.0, 0.0)
//│ Type: Point

:e
new Foo("1!5!")
//│ ╔══[ERROR] Type error in string literal with expected type Int
//│ ║  l.98: 	new Foo("1!5!")
//│ ║        	        ^^^^^^
//│ ╙── because: cannot constrain  Str  <:  Int
//│ Type: Foo


class Some[A](value: A)
//│ Type: ⊤

new Some(true)
//│ Type: Some[α15_1]
//│ Where:
//│   Bool <: α15_1

new Some(42)
//│ Type: Some[α16_1]
//│ Where:
//│   Int <: α16_1

let p = new Point(1.0, 0.0, 0.0) in p.Point#x
//│ Type: Num

let t = new Some(true) in t.Some#value
//│ Type: Bool

:fixme
:pe
42.Some#value
//│ ╔══[LEXICAL ERROR] Expect at least one digit after the  decimal point
//│ ║  l.127: 	42.Some#value
//│ ╙──       	   ^
//│ ╔══[PARSE ERROR] Expected end of input; found identifier instead
//│ ║  l.127: 	42.Some#value
//│ ╙──       	   ^^^^
//│ Type: Num


class Printer[T](f: T -> Str)
//│ Type: ⊤

fun foofoo(x) =
  let t = x + 1 in "foo"
//│ Type: ⊤

new Printer(foofoo)
//│ Type: Printer[α22_1]
//│ Where:
//│   α22_1 <: Int

let ip = new Printer(foofoo) in ip.Printer#f(42)
//│ Type: Str

:e
let ip = new Printer(foofoo) in ip.Printer#f("42")
//│ ╔══[ERROR] Type error in string literal with expected type α27_1
//│ ║  l.153: 	let ip = new Printer(foofoo) in ip.Printer#f("42")
//│ ║         	                                             ^^^^
//│ ╟── because: cannot constrain  Str  <:  α27_1
//│ ╟── because: cannot constrain  Str  <:  α26_1
//│ ╟── because: cannot constrain  Str  <:  α21_1
//│ ╙── because: cannot constrain  Str  <:  Int
//│ Type: Str

class TFun[T](f: T -> T)
//│ Type: ⊤

fun inc(x) = x + 1
//│ Type: ⊤

new TFun(inc)
//│ Type: TFun[α31_1]
//│ Where:
//│   Int <: α31_1
//│   α31_1 <: Int

let tf = new TFun(inc) in tf.TFun#f(1)
//│ Type: Int

:e
let tf = new TFun(inc) in tf.TFun#f("1")
//│ ╔══[ERROR] Type error in string literal with expected type α36_1
//│ ║  l.179: 	let tf = new TFun(inc) in tf.TFun#f("1")
//│ ║         	                                    ^^^
//│ ╟── because: cannot constrain  Str  <:  α36_1
//│ ╟── because: cannot constrain  Str  <:  α35_1
//│ ╟── because: cannot constrain  Str  <:  α30_1
//│ ╙── because: cannot constrain  Str  <:  Int
//│ Type: Str ∨ Int

class Pair[A, B](fst: A, snd: B)
//│ Type: ⊤

(new Pair(42, true)).Pair#fst
//│ Type: Int

(new Pair(42, true)).Pair#snd
//│ Type: Bool


if 1 < 2 then 1 else 0
//│ FAILURE: Unexpected exception
//│ /!!!\ Uncaught error: scala.MatchError: Cons(Branch(Ref(scrut@128),LitPat(BoolLit(true)),Else(Lit(IntLit(1)))),Else(Lit(IntLit(0)))) (of class hkmc2.semantics.Split$Cons)
//│ 	at: hkmc2.bbml.BBTyper.typeSplit(bbML.scala:380)
//│ 	at: hkmc2.bbml.BBTyper.typeSplit(bbML.scala:375)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck$$anonfun$3(bbML.scala:570)
//│ 	at: utils.TraceLogger.trace(TraceLogger.scala:14)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck(bbML.scala:608)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck$$anonfun$3(bbML.scala:496)
//│ 	at: utils.TraceLogger.trace(TraceLogger.scala:14)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck(bbML.scala:608)
//│ 	at: hkmc2.bbml.BBTyper.typePurely(bbML.scala:611)
//│ 	at: hkmc2.BbmlDiffMaker.processTerm(BbmlDiffMaker.scala:29)

if false then 1 else "1"
//│ FAILURE: Unexpected exception
//│ /!!!\ Uncaught error: scala.MatchError: Cons(Branch(Ref(scrut@131),LitPat(BoolLit(true)),Else(Lit(IntLit(1)))),Else(Lit(StrLit(1)))) (of class hkmc2.semantics.Split$Cons)
//│ 	at: hkmc2.bbml.BBTyper.typeSplit(bbML.scala:380)
//│ 	at: hkmc2.bbml.BBTyper.typeSplit(bbML.scala:375)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck$$anonfun$3(bbML.scala:570)
//│ 	at: utils.TraceLogger.trace(TraceLogger.scala:14)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck(bbML.scala:608)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck$$anonfun$3(bbML.scala:496)
//│ 	at: utils.TraceLogger.trace(TraceLogger.scala:14)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck(bbML.scala:608)
//│ 	at: hkmc2.bbml.BBTyper.typePurely(bbML.scala:611)
//│ 	at: hkmc2.BbmlDiffMaker.processTerm(BbmlDiffMaker.scala:29)


if 1 is Int then 1 else 0
//│ Type: Int

fun test(x) =
  if x is Int then x + 1 else 0
test
//│ Type: (Int ∧ (¬Int ∨ Int)) ->{⊥} Int

test(1)
//│ Type: Int


test("1")
//│ FAILURE: Unexpected type error
//│ ╔══[ERROR] Type error in application
//│ ║  l.240: 	test("1")
//│ ║         	^^^^^^^^^
//│ ╟── because: cannot constrain  α54_1  <:  Str ->{α60_1} α61_1
//│ ╟── because: cannot constrain  α54_1  <:  (((Str ∧ ⊤) ∧ ⊤) ∨ ⊥) ->{((⊤ ∧ ⊤) ∧ α60_1) ∨ ⊥} (((⊤ ∧ ⊤) ∧ α61_1) ∨ ⊥)
//│ ╟── because: cannot constrain  (Int ∧ (¬Int ∨ Int)) ->{⊥} Int  <:  (((Str ∧ ⊤) ∧ ⊤) ∨ ⊥) ->{((⊤ ∧ ⊤) ∧ α60_1) ∨ ⊥} (((⊤ ∧ ⊤) ∧ α61_1) ∨ ⊥)
//│ ╙── because: cannot constrain  ((Str ∧ ⊤) ∧ ⊤) ∨ ⊥  <:  (((Int ∧ ⊤) ∧ ¬Int) ∨ ((Int ∧ ⊤) ∧ ⊤)) ∨ ⊥
//│ Type: Int


fun fact(n) =
  if n > 1 then n * fact(n - 1) else 1
//│ FAILURE: Unexpected exception
//│ /!!!\ Uncaught error: scala.MatchError: Cons(Branch(Ref(scrut@145),LitPat(BoolLit(true)),Else(App(Ref(*),Tup(List(Fld(‹›,Ref(n@144),None), Fld(‹›,App(Ref(fact),Tup(List(Fld(‹›,App(Ref(-),Tup(List(Fld(‹›,Ref(n@144),None), Fld(‹›,Lit(IntLit(1)),None)))),None)))),None)))))),Else(Lit(IntLit(1)))) (of class hkmc2.semantics.Split$Cons)
//│ 	at: hkmc2.bbml.BBTyper.typeSplit(bbML.scala:380)
//│ 	at: hkmc2.bbml.BBTyper.typeSplit(bbML.scala:375)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck$$anonfun$3(bbML.scala:570)
//│ 	at: utils.TraceLogger.trace(TraceLogger.scala:14)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck(bbML.scala:608)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck$$anonfun$3(bbML.scala:512)
//│ 	at: utils.TraceLogger.trace(TraceLogger.scala:14)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck(bbML.scala:608)
//│ 	at: hkmc2.bbml.BBTyper.typeFunDef(bbML.scala:340)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck$$anonfun$3$$anonfun$1(bbML.scala:491)

fact
//│ Type: ⊥

fact(1)
//│ Type: ⊥


fun fact2 = case
  0 then 1
  n then n * fact2(n - 1)
//│ FAILURE: Unexpected exception
//│ /!!!\ Uncaught error: scala.MatchError: Cons(Branch(Ref(scrut@159),LitPat(BoolLit(true)),Else(Lit(IntLit(1)))),Else(App(Ref(*),Tup(List(Fld(‹›,Ref(n@155),None), Fld(‹›,App(Ref(fact2),Tup(List(Fld(‹›,App(Ref(-),Tup(List(Fld(‹›,Ref(n@155),None), Fld(‹›,Lit(IntLit(1)),None)))),None)))),None)))))) (of class hkmc2.semantics.Split$Cons)
//│ 	at: hkmc2.bbml.BBTyper.typeSplit(bbML.scala:380)
//│ 	at: hkmc2.bbml.BBTyper.typeSplit(bbML.scala:375)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck$$anonfun$3(bbML.scala:570)
//│ 	at: utils.TraceLogger.trace(TraceLogger.scala:14)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck(bbML.scala:608)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck$$anonfun$3(bbML.scala:512)
//│ 	at: utils.TraceLogger.trace(TraceLogger.scala:14)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck(bbML.scala:608)
//│ 	at: hkmc2.bbml.BBTyper.typeFunDef(bbML.scala:340)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck$$anonfun$3$$anonfun$1(bbML.scala:491)

fact2
//│ Type: ⊥

fact2(0)
//│ Type: ⊥


class Foo[A](x: A -> A)
//│ Type: ⊤

new Foo(x => x)
//│ Type: Foo[α73_1]

fun f(g) = new Foo(g)
f
//│ Type: (α76_1 ->{⊥} α76_1) ->{⊥} Foo[α76_1]

f(x => x).Foo#x
//│ Type: (α76_1) ->{⊥} α76_1

g => (new Foo(g)).Foo#x
//│ Type: (α83_1 ->{⊥} α83_1) ->{⊥} (α83_1) ->{⊥} α83_1


