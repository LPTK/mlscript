:global
:bbml

fun f(y) =
  let local = ((x => y(x) + 1): [A] -> A -> Int) in y
//│ Type: ⊤

// * the parameter type of y is extruded.
f
//│ Type: α2_1 ->{⊥} α2_1
//│ Where:
//│   α2_1 <: ⊤ ->{⊥} Int

fun foo: [A] -> A -> Int
fun foo(x) = 0
//│ Type: ⊤

foo
//│ Type: forall α9_2: (⊤) ->{⊥} Int

f(foo)
//│ Type: ⊤ ->{⊥} Int

fun g: ([A] -> A -> Int) -> ([A] -> A -> Int)
fun g(y) =
  let local = ((x => y(x) + 1): ([A] -> A -> Int)) in y
//│ Type: ⊤

g
//│ Type: (forall α15_2: (⊥) ->{⊥} Int) ->{⊥} forall α16_2: (⊤) ->{⊥} Int

g(foo)
//│ Type: forall α16_2: (⊤) ->{⊥} Int

:e
y `=> (let t = run(x `=> x `+ y) in y)
//│ ╔══[ERROR] Type error in quoted term with expected type CodeBase[out α23_3, ⊥, ?]
//│ ║  l.36: 	y `=> (let t = run(x `=> x `+ y) in y)
//│ ║        	                   ^^^^^^^^^^^^
//│ ╟── because: cannot constrain  CodeBase[out α24_5 ->{⊥} α31_5, out α33_4, ?]  <:  CodeBase[out α23_3, ⊥, ?]
//│ ╟── because: cannot constrain  ((⊤ ∧ ⊤) ∧ α33_4) ∨ ⊥  <:  ⊥ ∨ ⊥
//│ ╟── because: cannot constrain  α33_4  <:  ⊥
//│ ╙── because: cannot constrain  <α>22_3  <:  ⊥
//│ Type: CodeBase[out α21_3 ->{⊥} α21_3, ⊥, ?]
//│ Where:
//│   α21_3 <: Int

class C[A](m: A, n: A -> Int)
//│ Type: ⊤


fun f: [A] -> ([B] -> (C[out B] & A) -> B) -> A -> Int
f
//│ Type: forall α39_2: (forall α40_3: (C[out α40_3] ∧ α39_2) ->{⊥} α40_3) ->{⊥} (α39_2) ->{⊥} Int

fun g: [D] -> C[in Int out D] -> D
g
//│ Type: forall α41_2: (C[in Int out α41_2]) ->{⊥} α41_2


f(g)
//│ Type: (¬C[?] ∨ C[in Int out ⊥]) ->{⊥} Int

fun foo: C[in Int out Nothing]
foo
//│ Type: C[in Int out ⊥]

fun bar: C[in Int out Int]
bar
//│ Type: C[Int]

f(g)(foo)
//│ Type: Int

:fixme // ???
f(g)(bar)
//│ ╔══[ERROR] Type error in reference with expected type α48_1
//│ ║  l.76: 	f(g)(bar)
//│ ║        	     ^^^
//│ ╟── because: cannot constrain  C[Int]  <:  α48_1
//│ ╟── because: cannot constrain  C[((Int ∧ ⊤) ∧ ⊤) ∨ ⊥]  <:  α48_1
//│ ╟── because: cannot constrain  C[((Int ∧ ⊤) ∧ ⊤) ∨ ⊥]  <:  ¬C[in ⊥ ∨ ⊥ out ⊤ ∧ ⊤] ∨ C[in ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥ out (⊤ ∧ ⊤) ∧ α50_1]
//│ ╟── because: cannot constrain  ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥  <:  ((⊤ ∧ ⊤) ∧ α50_1) ∨ ⊥
//│ ╟── because: cannot constrain  Int  <:  α50_1
//│ ╙── because: cannot constrain  Int  <:  ⊥
//│ Type: Int
