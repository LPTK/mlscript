:global
:bbml



fun letreg: [E,Res] -> ([R] -> Region[R] ->{E | R} Res) ->{E} Res
//│ Type: ⊤

letreg
//│ Type: forall α0_2, α1_2: (forall α2_3: (Region[α2_3]) ->{α0_2 ∨ α2_3} α1_2) ->{α0_2} α1_2

letreg(r => r)
//│ Type: Region[?]

:e
letreg(r => r).ref 1
//│ ╔══[ERROR] Type error in reference creation
//│ ║  l.16: 	letreg(r => r).ref 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α6_1  <:  Region[α7_1]
//│ ╟── because: cannot constrain  α6_1  <:  ¬(~{Region[α7_1]})
//│ ╟── because: cannot constrain  Region[out ¬⊥] ∧ ¬⊥  <:  ¬(~{Region[α7_1]})
//│ ╟── because: cannot constrain  D(  )  <:  α7_1
//│ ╟── because: cannot constrain    <:  α7_1
//│ ╙── because: cannot constrain    <:  ¬()
//│ ╔══[ERROR] Type error in block
//│ ║  l.16: 	letreg(r => r).ref 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α7_1 ∨ α5_1  <:  Alloc
//│ ╟── because: cannot constrain  α7_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain    <:  ¬(~{Alloc})
//│ Type: Ref[Int, ?]

letreg(r => r.ref 1)
//│ Type: Ref[Int, ?]

letreg(r => !(r.ref 1))
//│ Type: Int

:e
!letreg(r => r.ref 1)
//│ ╔══[ERROR] Type error in block
//│ ║  l.41: 	!letreg(r => r.ref 1)
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α21_1 ∨ α17_1  <:  Alloc
//│ ╟── because: cannot constrain  α21_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  α20_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  α20_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain  ¬⊥  <:  ¬(~{Alloc})
//│ Type: Int

letreg of r =>
  let x = r.ref 1
  x := !x + 1
  !x
//│ Type: Int

let f = letreg(r => arg => r.ref arg)
//│ Type: ⊤

:e
f
//│ ╔══[ERROR] Variable not found: f
//│ ║  l.62: 	f
//│ ╙──      	^
//│ Type: ⊥

:e
letreg(r => arg => r.ref arg)(0)
//│ ╔══[ERROR] Type error in block
//│ ║  l.69: 	letreg(r => arg => r.ref arg)(0)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α45_1 ∨ α38_1  <:  Alloc
//│ ╟── because: cannot constrain  α45_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  α44_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  α44_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain  ¬⊥  <:  ¬(~{Alloc})
//│ Type: Ref[α42_1, ?]
//│ Where:
//│   Int <: α42_1



// * An incorrect one, just for testing the error:

fun letreg: [E,Res] -> ([R] -> Region[R] -> Res) ->{E} Res
//│ Type: ⊤

:e
letreg(r => r.ref 1)
//│ ╔══[ERROR] Type error in function literal with expected type (Region[<α>49_2]) ->{⊥} α51_1
//│ ║  l.90: 	letreg(r => r.ref 1)
//│ ║        	       ^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α52_2  <:  ⊥
//│ ╟── because: cannot constrain  α52_2  <:  ¬()
//│ ╙── because: cannot constrain  <α>49_2  <:  ¬()
//│ Type: Ref[Int, ?]

:e
letreg(r => !(r.ref 1))
//│ ╔══[ERROR] Type error in function literal with expected type (Region[<α>49_2]) ->{⊥} α55_1
//│ ║  l.100: 	letreg(r => !(r.ref 1))
//│ ║         	       ^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α57_2 ∨ α56_2  <:  ⊥
//│ ╟── because: cannot constrain  α57_2  <:  ¬()
//│ ╟── because: cannot constrain  α56_2  <:  ¬()
//│ ╟── because: cannot constrain  α56_2  <:  ¬()
//│ ╙── because: cannot constrain  <α>49_2  <:  ¬()
//│ ╔══[ERROR] Type error in function literal with expected type (Region[<α>49_2]) ->{⊥} α55_1
//│ ║  l.100: 	letreg(r => !(r.ref 1))
//│ ║         	       ^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α57_2 ∨ α56_2  <:  ⊥
//│ ╟── because: cannot constrain  α56_2  <:  ¬()
//│ ╙── because: cannot constrain  <α>49_2  <:  ¬()
//│ Type: Int


